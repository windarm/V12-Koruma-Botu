/*[system-bundles-config]*/
System.bundles = {"bundles/can-dom-mutate/test.css!":["qunit@2.9.2#qunit/qunit.css!steal-css@1.3.2#css"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global, require, exports, module) {
        var slice = Array.prototype.slice;
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var conditionalModuleRegEx = /#\{[^\}]+\}|#\?.+$/;
        var gitUrlEx = /(git|http(s?)):\/\//;
        var supportsSet = typeof Set === 'function';
        var utils = {
            extend: function (d, s, deep, existingSet) {
                var val;
                var set = existingSet;
                if (deep) {
                    if (!set) {
                        if (supportsSet) {
                            set = new Set();
                        } else {
                            set = [];
                        }
                    }
                    if (supportsSet) {
                        if (set.has(s)) {
                            return s;
                        } else {
                            set.add(s);
                        }
                    } else {
                        if (set.indexOf(s) !== -1) {
                            return s;
                        } else {
                            set.push(s);
                        }
                    }
                }
                for (var prop in s) {
                    val = s[prop];
                    if (deep) {
                        if (utils.isArray(val)) {
                            d[prop] = slice.call(val);
                        } else if (utils.isPlainObject(val)) {
                            d[prop] = utils.extend({}, val, deep, set);
                        } else {
                            d[prop] = s[prop];
                        }
                    } else {
                        d[prop] = s[prop];
                    }
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(arr[i]);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            flow: function (fns) {
                return function () {
                    var res = fns[0].apply(this, arguments);
                    for (var i = 1; i < fns.length; i++) {
                        res = fns[i].call(this, res);
                    }
                    return res;
                };
            },
            isObject: function (obj) {
                return typeof obj === 'object';
            },
            isPlainObject: function (obj) {
                return utils.isObject(obj) && (!obj || obj.__proto__ === Object.prototype);
            },
            isArray: Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) === '[object Array]';
            },
            isEnv: function (name) {
                return this.isEnv ? this.isEnv(name) : this.env === name;
            },
            isGitUrl: function (str) {
                return gitUrlEx.test(str);
            },
            warnOnce: function (msg) {
                var w = this._warnings = this._warnings || {};
                if (w[msg])
                    return;
                w[msg] = true;
                this.warn(msg);
            },
            warn: function (msg) {
                if (typeof steal !== 'undefined' && typeof console !== 'undefined' && console.warn) {
                    steal.done().then(function () {
                        if (steal.dev && steal.dev.warn) {
                        } else if (console.warn) {
                            console.warn('steal.js WARNING: ' + msg);
                        } else {
                            console.log(msg);
                        }
                    });
                }
            },
            relativeURI: function (baseURL, url) {
                return typeof steal !== 'undefined' ? steal.relativeURI(baseURL, url) : url;
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        var version = descriptor.version;
                        if (version && version[0] !== '^') {
                            version = encodeURIComponent(decodeURIComponent(version));
                        }
                        return descriptor.packageName + (version ? '@' + version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isConditional: function (moduleName) {
                    return conditionalModuleRegEx.test(moduleName);
                },
                isFullyConvertedNpm: function (parsedModuleName) {
                    return !!(parsedModuleName.packageName && parsedModuleName.version && parsedModuleName.modulePath);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName, global, context) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else if (currentPackageName && utils.path.isInHomeDir(moduleName, context)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0].split('/').slice(1).join('/');
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    modulePath = utils.path.removeJS(modulePath);
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName,
                        isGlobal: global
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName, undefined, { loader: loader }), isRelative = utils.path.isRelative(parsedModuleName.modulePath);
                    if (isRelative && !parentName) {
                        throw new Error('Cannot resolve a relative module identifier ' + 'with no parent module:', name);
                    }
                    if (isRelative) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            var makePathRelative = true;
                            if (name === '../' || name === './' || name === '..') {
                                var relativePath = utils.path.relativeTo(parentParsed.modulePath, name);
                                var isInRoot = utils.path.isPackageRootDir(relativePath);
                                if (isInRoot) {
                                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                                    makePathRelative = false;
                                } else {
                                    parsedModuleName.modulePath = name + (utils.path.endsWithSlash(name) ? '' : '/') + 'index';
                                }
                            }
                            if (makePathRelative) {
                                parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                            }
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), refSteal = utils.pkg.config(refPkg), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refSteal || !refSteal.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName, !!global);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                },
                isBareIdentifier: function (identifier) {
                    return identifier && identifier[0] !== '.' && identifier[0] !== '@';
                }
            },
            pkg: {
                name: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.name || pkg.name;
                },
                main: function (pkg) {
                    var main;
                    var steal = utils.pkg.config(pkg);
                    if (steal && steal.main) {
                        main = steal.main;
                    } else if (typeof pkg.browser === 'string') {
                        if (utils.path.endsWithSlash(pkg.browser)) {
                            main = pkg.browser + 'index';
                        } else {
                            main = pkg.browser;
                        }
                    } else if (typeof pkg.jam === 'object' && pkg.jam.main) {
                        main = pkg.jam.main;
                    } else if (pkg.main) {
                        main = pkg.main;
                    } else {
                        main = 'index';
                    }
                    return utils.path.removeJS(utils.path.removeDotSlash(main));
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = utils.pkg.directoriesLib(pkg);
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                isRoot: function (loader, pkg) {
                    var root = utils.pkg.getDefault(loader);
                    return pkg && pkg.name === root.name && pkg.version === root.version;
                },
                homeAlias: function (context) {
                    return context && context.loader && context.loader.homeAlias || '~';
                },
                getDefault: function (loader) {
                    return loader.npmPaths.__default;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var startingAddress = utils.relativeURI(loader.baseURL, moduleAddress);
                            var packageFolder = utils.pkg.folderAddress(startingAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : utils.pkg.getDefault(loader);
                        } else {
                            return utils.pkg.getDefault(loader);
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPkg, name) {
                    if (loader.npm && refPkg && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + refPkg.resolutions[name];
                        var pkg = loader.npm[nameAndVersion];
                        return pkg;
                    }
                },
                findDepWalking: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                findByNameAndVersion: function (loader, name, version) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + version;
                        return loader.npm[nameAndVersion];
                    }
                },
                findByUrl: function (loader, url) {
                    if (loader.npm) {
                        var fullUrl = utils.pkg.folderAddress(url);
                        return loader.npmPaths[fullUrl];
                    }
                },
                directoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    var lib = steal && steal.directories && steal.directories.lib;
                    var ignores = [
                            '.',
                            '/'
                        ], ignore;
                    if (!lib)
                        return undefined;
                    while (!!(ignore = ignores.shift())) {
                        if (lib[0] === ignore) {
                            lib = lib.substr(1);
                        }
                    }
                    return lib;
                },
                hasDirectoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.directories && !!steal.directories.lib;
                },
                findPackageInfo: function (context, pkg) {
                    var pkgInfo = context.pkgInfo;
                    if (pkgInfo) {
                        var out;
                        utils.forEach(pkgInfo, function (p) {
                            if (pkg.name === p.name && pkg.version === p.version) {
                                out = p;
                            }
                        });
                        return out;
                    }
                },
                saveResolution: function (context, refPkg, pkg) {
                    var npmPkg = utils.pkg.findPackageInfo(context, refPkg);
                    npmPkg.resolutions[pkg.name] = refPkg.resolutions[pkg.name] = pkg.version;
                },
                config: function (pkg) {
                    return pkg.steal || pkg.system;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                isInHomeDir: function (path, context) {
                    return path.substr(0, 2) === utils.pkg.homeAlias(context) + '/';
                },
                joinURIs: function (baseUri, rel) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    var href = parseURI(rel || '');
                    var base = parseURI(baseUri || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                removeDotSlash: function (path) {
                    return utils.path.startsWithDotSlash(path) ? path.substr(2) : path;
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                basename: function (address) {
                    var parts = address.split('/');
                    return parts[parts.length - 1];
                },
                relativeTo: function (modulePath, rel) {
                    var parts = modulePath.split('/');
                    var idx = 1;
                    while (rel[idx] === '.') {
                        parts.pop();
                        idx++;
                    }
                    return parts.join('/');
                },
                isPackageRootDir: function (pth) {
                    return pth.indexOf('/') === -1;
                }
            },
            json: {
                transform: function (loader, load, data) {
                    data.steal = utils.pkg.config(data);
                    var fn = loader.jsonOptions && loader.jsonOptions.transform;
                    if (!fn)
                        return data;
                    return fn.call(loader, load, data);
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/]*(?::[^:@\/]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-extension*/
define('npm-extension', [
    'require',
    'exports',
    'module',
    '@steal',
    './npm-utils'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'format cjs';
        var steal = require('@steal');
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isBrowser = typeof window !== 'undefined' && !isNode && !isWorker;
        exports.addExtension = function (System) {
            if (System._extensions) {
                System._extensions.push(exports.addExtension);
            }
            var oldNormalize = System.normalize;
            System.normalize = function (identifier, parentModuleName, parentAddress, pluginNormalize) {
                var name = identifier;
                var parentName = parentModuleName;
                if (parentName && this.npmParentMap && this.npmParentMap[parentName]) {
                    parentName = this.npmParentMap[parentName];
                }
                var hasNoParent = !parentName;
                var nameIsRelative = utils.path.isRelative(name);
                var parentIsNpmModule = utils.moduleName.isNpm(parentName);
                var identifierEndsWithSlash = utils.path.endsWithSlash(name);
                if (parentName && nameIsRelative && !parentIsNpmModule) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (utils.moduleName.isConditional(name)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var hasContextualMap = typeof this.map[parentName] === 'object' && this.map[parentName][name];
                if (hasContextualMap) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var isPointingAtParentFolder = name === '../' || name === './';
                if (parentIsNpmModule && isPointingAtParentFolder) {
                    var parsedParentModuleName = utils.moduleName.parse(parentName);
                    var parentModulePath = parsedParentModuleName.modulePath || '';
                    var relativePath = utils.path.relativeTo(parentModulePath, name);
                    var isInRoot = utils.path.isPackageRootDir(relativePath);
                    if (isInRoot) {
                        name = refPkg.name + '#' + utils.path.removeJS(refPkg.main);
                    } else {
                        name = name + 'index';
                    }
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var isRoot = utils.pkg.isRoot(this, refPkg);
                var parsedPackageNameIsReferringPackage = parsedModuleName.packageName === refPkg.name;
                var isRelativeToParentNpmModule = parentIsNpmModule && nameIsRelative && parsedPackageNameIsReferringPackage;
                var depPkg, wantedPkg;
                if (isRelativeToParentNpmModule) {
                    depPkg = refPkg;
                }
                var context = this.npmContext;
                var crawl = context && context.crawl;
                var isDev = !!crawl;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = nameIsRelative ? null : crawl.matchedVersion(context, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            wantedPkg = depMap[parsedModuleName.packageName];
                            if (wantedPkg) {
                                var wantedVersion = refPkg.resolutions && refPkg.resolutions[wantedPkg.name] || wantedPkg.version;
                                var foundPkg = crawl.matchedVersion(this.npmContext, wantedPkg.name, wantedVersion);
                                if (foundPkg) {
                                    depPkg = utils.pkg.findByUrl(this, foundPkg.fileUrl);
                                }
                            }
                        }
                    } else {
                        if (isRoot) {
                            depPkg = utils.pkg.findDepWalking(this, refPkg, parsedModuleName.packageName);
                        } else {
                            depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                        }
                    }
                }
                if (parsedPackageNameIsReferringPackage) {
                    depPkg = utils.pkg.findByNameAndVersion(this, parsedModuleName.packageName, refPkg.version);
                }
                var lookupByName = parsedModuleName.isGlobal || hasNoParent;
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                var isThePackageWeWant = !isDev || !depPkg || (wantedPkg ? crawl.pkgSatisfies(depPkg, wantedPkg.version) : true);
                if (!isThePackageWeWant) {
                    depPkg = undefined;
                } else if (isDev && depPkg) {
                    utils.pkg.saveResolution(context, refPkg, depPkg);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName.moduleName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && isRoot && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                var loader = this;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = crawl.matchedVersion(this.npmContext, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            depPkg = depMap[parsedModuleName.packageName];
                            if (!depPkg) {
                                var parents = crawl.findPackageAndParents(this.npmContext, parsedModuleName.packageName);
                                if (parents) {
                                    depPkg = parents.package;
                                }
                            }
                        }
                    }
                    if (!depPkg) {
                        if (refPkg.browser && refPkg.browser[name]) {
                            return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                        }
                        var steal = utils.pkg.config(refPkg);
                        if (steal && steal.map && typeof steal.map[name] === 'string') {
                            var mappedName = steal.map[name];
                            var envConfig = steal.envs && steal.envs[loader.env];
                            if (envConfig && envConfig.map && typeof envConfig.map[name] === 'string') {
                                mappedName = envConfig.map[name];
                            }
                            return loader.normalize(mappedName, parentName, parentAddress, pluginNormalize);
                        } else {
                            return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                        }
                    }
                    return crawl.dep(this.npmContext, parentPkg, refPkg, depPkg, isRoot).then(createModuleNameAndNormalize);
                } else {
                    return createModuleNameAndNormalize(depPkg);
                }
                function createModuleNameAndNormalize(depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var p = oldNormalize.call(loader, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                    if (identifierEndsWithSlash) {
                        p.then(function (name) {
                            if (context && context.forwardSlashMap) {
                                context.forwardSlashMap[name] = true;
                            }
                        });
                    }
                    return p;
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                var pmn = load.metadata.parsedModuleName = parsedModuleName;
                load.metadata.npmPackage = utils.pkg.findByNameAndVersion(this, pmn.packageName, pmn.version);
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (locatedAddress) {
                            var address = locatedAddress;
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, utils.pkg.isRoot(loader, pkg));
                            if (parsedModuleName.modulePath) {
                                var npmAddress = utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                                address = typeof steal !== 'undefined' ? utils.path.joinURIs(loader.baseURL, npmAddress) : npmAddress;
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var oldFetch = System.fetch;
            System.fetch = function (load) {
                if (load.metadata.dryRun) {
                    return oldFetch.apply(this, arguments);
                }
                var loader = this;
                var context = loader.npmContext;
                var fetchPromise = Promise.resolve(oldFetch.apply(this, arguments));
                if (utils.moduleName.isNpm(load.name)) {
                    fetchPromise = fetchPromise.then(null, function (err) {
                        if (err.statusCode !== 404) {
                            return Promise.reject(err);
                        }
                        if (!loader.npmContext) {
                            loader.npmContext = { forwardSlashMap: {} };
                        }
                        var types = [].slice.call(retryTypes);
                        return retryAll(types, err).then(null, function (e) {
                            return Promise.reject(err);
                        });
                        function retryAll(types, err) {
                            if (!types.length) {
                                throw err;
                            }
                            var type = types.shift();
                            if (!type.test(load)) {
                                throw err;
                            }
                            return Promise.resolve(retryFetch.call(loader, load, type)).then(null, function (err) {
                                return retryAll(types, err);
                            });
                        }
                    });
                }
                return fetchPromise.catch(function (error) {
                    if (error.statusCode === 404 && utils.moduleName.isBareIdentifier(load.name) && !utils.pkg.isRoot(loader, load.metadata.npmPackage)) {
                        var newError = new Error([
                            'Could not load \'' + load.name + '\'',
                            'Is this an npm module not saved in your package.json?'
                        ].join('\n'));
                        newError.statusCode = error.statusCode;
                        throw newError;
                    } else {
                        throw error;
                    }
                });
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                if (loader.npmContext) {
                    var context = loader.npmContext;
                    var pkg = context.versions.__default;
                    var conv = context.convert.steal(context, pkg, cfg, true);
                    context.convert.updateConfigOnPackageLoad(conv, false, true, context.applyBuildConfig);
                    oldConfig.apply(loader, arguments);
                    return;
                }
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
            steal.addNpmPackages = function (npmPackages) {
                var packages = npmPackages || [];
                var loader = this.loader;
                for (var i = 0; i < packages.length; i += 1) {
                    var pkg = packages[i];
                    var path = pkg && pkg.fileUrl;
                    if (path) {
                        loader.npmContext.paths[path] = pkg;
                    }
                }
            };
            steal.getNpmPackages = function () {
                var context = this.loader.npmContext;
                return context ? context.packages || [] : [];
            };
            function retryFetch(load, type) {
                var loader = this;
                var moduleName = typeof type.name === 'function' ? type.name(loader, load) : load.name + type.name;
                var local = utils.extend({}, load);
                local.name = moduleName;
                local.metadata = { dryRun: true };
                return Promise.resolve(loader.locate(local)).then(function (address) {
                    local.address = address;
                    return loader.fetch(local);
                }).then(function (source) {
                    load.metadata.address = local.address;
                    loader.npmParentMap[load.name] = local.name;
                    var npmLoad = loader.npmContext && loader.npmContext.npmLoad;
                    if (npmLoad) {
                        npmLoad.saveLoadIfNeeded(loader.npmContext);
                        if (!isNode) {
                            utils.warnOnce('Some 404s were encountered ' + 'while loading. Don\'t panic! ' + 'These will only happen in dev ' + 'and are harmless.');
                        }
                    }
                    return source;
                });
            }
            var retryTypes = [
                {
                    name: function (loader, load) {
                        var context = loader.npmContext;
                        if (context.forwardSlashMap[load.name]) {
                            var parts = load.name.split('/');
                            parts.pop();
                            return parts.concat(['index']).join('/');
                        }
                        return load.name + '/index';
                    },
                    test: function () {
                        return true;
                    }
                },
                {
                    name: '.json',
                    test: function (load) {
                        return utils.moduleName.isNpm(load.name) && utils.path.basename(load.address) === 'package.js';
                    }
                }
            ];
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-load*/
define('npm-load', [], function(){ return {}; });
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm-convert*/
define('npm-convert', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'can-dom-mutate@1.3.7#can-dom-mutate';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages, options) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                argv: [],
                cwd: function () {
                    var baseURL = loader.baseURL;
                    return baseURL;
                },
                browser: true,
                env: { NODE_ENV: loader.env },
                version: '',
                platform: navigator && navigator.userAgent && /Windows/.test(navigator.userAgent) ? 'win' : ''
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        if (!loader.npmParentMap) {
            loader.npmParentMap = options.npmParentMap || {};
        }
        var rootPkg = loader.npmPaths.__default = packages[0];
        var rootConfig = rootPkg.steal || rootPkg.system;
        var lib = rootConfig && rootConfig.directories && rootConfig.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                res = fn.call(arr, arr[i], i);
                if (res === false)
                    break;
            }
        };
        var setupLiveReload = function () {
            if (loader.liveReloadInstalled) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        var pkgInfo = loader.npmContext.pkgInfo;
                        delete pkgInfo[rootPkg.name + '@' + rootPkg.version];
                        var idx = -1;
                        forEach(pkgInfo, function (pkg, i) {
                            if (pkg.name === rootPkg.name && pkg.version === rootPkg.version) {
                                idx = i;
                                return false;
                            }
                        });
                        pkgInfo.splice(idx, 1);
                    });
                });
            }
        };
        var ignoredConfig = [
            'bundle',
            'configDependencies',
            'transpiler'
        ];
        packages.reverse();
        forEach(packages, function (pkg) {
            var steal = pkg.steal || pkg.system;
            if (steal) {
                var main = steal.main;
                delete steal.main;
                var configDeps = steal.configDependencies;
                if (pkg !== rootPkg) {
                    forEach(ignoredConfig, function (name) {
                        delete steal[name];
                    });
                }
                loader.config(steal);
                if (pkg === rootPkg) {
                    steal.configDependencies = configDeps;
                }
                steal.main = main;
            }
            if (pkg.globalBrowser) {
                var doNotApplyGlobalBrowser = pkg.name === 'steal' && rootConfig.builtins === false;
                if (!doNotApplyGlobalBrowser) {
                    setGlobalBrowser(pkg.globalBrowser, pkg);
                }
            }
            var systemName = steal && steal.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        setupLiveReload();
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
    }(loader, [
        {
            'name': 'can-dom-mutate',
            'version': '1.3.7',
            'fileUrl': './package.json',
            'main': 'can-dom-mutate',
            'steal': {
                'main': 'can-dom-mutate',
                'npmAlgorithm': 'flat'
            },
            'resolutions': {
                'can-dom-mutate': '1.3.7',
                'can-globals': '1.2.2',
                'can-vdom': '4.4.1',
                'can-dom-events': '1.3.10',
                'steal-qunit': '2.0.0',
                'can-namespace': '1.0.0',
                'can-reflect': '1.17.11'
            }
        },
        {
            'name': 'steal',
            'version': '1.12.6',
            'fileUrl': './node_modules/steal/package.json',
            'main': 'main',
            'steal': {
                'npmDependencies': {
                    'console-browserify': true,
                    'constants-browserify': true,
                    'crypto-browserify': true,
                    'http-browserify': true,
                    'buffer': true,
                    'os-browserify': true,
                    'vm-browserify': true,
                    'zlib-browserify': true,
                    'assert': true,
                    'domain-browser': true,
                    'events': true,
                    'https-browserify': true,
                    'path-browserify': true,
                    'string_decoder': true,
                    'tty-browserify': true,
                    'process': true,
                    'punycode': true
                }
            },
            'globalBrowser': {
                'console': 'console-browserify',
                'constants': 'constants-browserify',
                'crypto': 'crypto-browserify',
                'http': 'http-browserify',
                'buffer': 'buffer',
                'os': 'os-browserify',
                'vm': 'vm-browserify',
                'zlib': 'zlib-browserify',
                'assert': 'assert',
                'child_process': 'steal#ext/builtin/child_process',
                'cluster': 'steal#ext/builtin/cluster',
                'dgram': 'steal#ext/builtin/dgram',
                'dns': 'steal#ext/builtin/dns',
                'domain': 'domain-browser',
                'events': 'events',
                'fs': 'steal#ext/builtin/fs',
                'https': 'https-browserify',
                'module': 'steal#ext/builtin/module',
                'net': 'steal#ext/builtin/net',
                'path': 'path-browserify',
                'process': 'process',
                'querystring': 'steal#ext/builtin/querystring',
                'readline': 'steal#ext/builtin/readline',
                'repl': 'steal#ext/builtin/repl',
                'stream': 'steal#ext/builtin/stream',
                'string_decoder': 'string_decoder',
                'sys': 'steal#ext/builtin/sys',
                'timers': 'steal#ext/builtin/timers',
                'tls': 'steal#ext/builtin/tls',
                'tty': 'tty-browserify',
                'url': 'steal#ext/builtin/url',
                'util': 'steal#ext/builtin/util',
                '_stream_readable': 'steal#ext/builtin/_stream_readable',
                '_stream_writable': 'steal#ext/builtin/_stream_writable',
                '_stream_duplex': 'steal#ext/builtin/_stream_duplex',
                '_stream_transform': 'steal#ext/builtin/_stream_transform',
                '_stream_passthrough': 'steal#ext/builtin/_stream_passthrough'
            },
            'resolutions': {}
        },
        {
            'name': 'buffer',
            'version': '5.0.8',
            'fileUrl': './node_modules/buffer/package.json',
            'main': 'index.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'assert',
            'version': '1.4.1',
            'fileUrl': './node_modules/assert/package.json',
            'main': './assert.js',
            'resolutions': {}
        },
        {
            'name': 'constants-browserify',
            'version': '1.0.0',
            'fileUrl': './node_modules/constants-browserify/package.json',
            'main': 'constants.json',
            'resolutions': {}
        },
        {
            'name': 'domain-browser',
            'version': '1.1.7',
            'fileUrl': './node_modules/domain-browser/package.json',
            'main': './index.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'crypto-browserify',
            'version': '3.11.1',
            'fileUrl': './node_modules/crypto-browserify/package.json',
            'browser': { 'crypto': '@empty' },
            'resolutions': {}
        },
        {
            'name': 'console-browserify',
            'version': '1.1.0',
            'fileUrl': './node_modules/console-browserify/package.json',
            'main': 'index',
            'resolutions': {}
        },
        {
            'name': 'http-browserify',
            'version': '1.7.0',
            'fileUrl': './node_modules/http-browserify/package.json',
            'main': 'index.js',
            'browser': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'events',
            'version': '1.1.1',
            'fileUrl': './node_modules/events/package.json',
            'main': './events.js',
            'resolutions': {}
        },
        {
            'name': 'os-browserify',
            'version': '0.3.0',
            'fileUrl': './node_modules/os-browserify/package.json',
            'main': 'main.js',
            'browser': 'browser.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'https-browserify',
            'version': '1.0.0',
            'fileUrl': './node_modules/https-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'path-browserify',
            'version': '0.0.1',
            'fileUrl': './node_modules/path-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'process',
            'version': '0.11.10',
            'fileUrl': './node_modules/process/package.json',
            'main': './index.js',
            'browser': './browser.js',
            'resolutions': {}
        },
        {
            'name': 'punycode',
            'version': '2.0.1',
            'fileUrl': './node_modules/punycode/package.json',
            'main': 'punycode.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'string_decoder',
            'version': '0.10.31',
            'fileUrl': './node_modules/string_decoder/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'tty-browserify',
            'version': '0.0.1',
            'fileUrl': './node_modules/tty-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'zlib-browserify',
            'version': '0.0.3',
            'fileUrl': './node_modules/zlib-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'vm-browserify',
            'version': '0.0.4',
            'fileUrl': './node_modules/vm-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'string_decoder',
            'version': '1.0.3',
            'fileUrl': './node_modules/steal/node_modules/string_decoder/package.json',
            'main': 'lib/string_decoder.js',
            'resolutions': {}
        },
        {
            'name': 'can-globals',
            'version': '1.2.2',
            'fileUrl': './node_modules/can-globals/package.json',
            'main': 'can-globals.js',
            'resolutions': {
                'can-globals': '1.2.2',
                'can-namespace': '1.0.0',
                'can-reflect': '1.17.11'
            }
        },
        {
            'name': 'steal-qunit',
            'version': '2.0.0',
            'fileUrl': './node_modules/steal-qunit/package.json',
            'main': 'steal-qunit',
            'steal': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunit@2.9.2#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            },
            'resolutions': {
                'qunit': '2.9.2',
                'steal-css': '1.3.2'
            },
            'system': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunit@2.9.2#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            }
        },
        {
            'name': 'can-vdom',
            'version': '4.4.1',
            'fileUrl': './node_modules/can-vdom/package.json',
            'main': 'can-vdom.js',
            'steal': {
                'map': { 'can-vdom@4.4.1#assert': 'chai/chai' },
                'meta': {
                    'chai/chai': {
                        'format': 'global',
                        'exports': 'chai.assert'
                    }
                },
                'plugins': ['chai'],
                'main': 'can-vdom'
            },
            'resolutions': {
                'can-vdom': '4.4.1',
                'can-simple-dom': '1.6.2',
                'can-view-parser': '4.1.3'
            }
        },
        {
            'name': 'can-dom-events',
            'version': '1.3.10',
            'fileUrl': './node_modules/can-dom-events/package.json',
            'main': 'can-dom-events',
            'resolutions': {
                'can-dom-events': '1.3.10',
                'can-namespace': '1.0.0',
                'can-globals': '1.2.2',
                'can-reflect': '1.17.11',
                'can-key-tree': '1.2.1'
            }
        },
        {
            'name': 'steal-css',
            'version': '1.3.2',
            'fileUrl': './node_modules/steal-css/package.json',
            'main': 'css.js',
            'steal': {
                'ext': { 'css': 'steal-css' },
                'map': { '$css': 'steal-css@1.3.2#css' }
            },
            'resolutions': {}
        },
        {
            'name': 'qunit',
            'version': '2.9.2',
            'fileUrl': './node_modules/qunit/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': { 'steal-qunit': '2.0.0' }
        },
        {
            'name': 'can-namespace',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-namespace/package.json',
            'main': 'can-namespace',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {}
        },
        {
            'name': 'can-reflect',
            'version': '1.17.11',
            'fileUrl': './node_modules/can-reflect/package.json',
            'main': 'can-reflect',
            'resolutions': {
                'can-reflect': '1.17.11',
                'can-namespace': '1.0.0',
                'can-symbol': '1.6.5'
            }
        },
        {
            'name': 'can-simple-dom',
            'version': '1.6.2',
            'fileUrl': './node_modules/can-simple-dom/package.json',
            'main': 'can-simple-dom.js',
            'resolutions': {
                'can-simple-dom': '1.6.2',
                'he': '1.1.1',
                'micro-location': '0.1.5'
            }
        },
        {
            'name': 'can-key-tree',
            'version': '1.2.1',
            'fileUrl': './node_modules/can-key-tree/package.json',
            'main': 'dist/cjs/can-key-tree',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-key-tree'
            },
            'resolutions': { 'can-reflect': '1.17.11' }
        },
        {
            'name': 'can-view-parser',
            'version': '4.1.3',
            'fileUrl': './node_modules/can-view-parser/package.json',
            'main': 'can-view-parser',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-log': '1.0.1',
                'can-attribute-encoder': '1.1.4'
            }
        },
        {
            'name': 'can-symbol',
            'version': '1.6.5',
            'fileUrl': './node_modules/can-symbol/package.json',
            'main': 'can-symbol',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-symbol'
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-log',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-log/package.json',
            'main': 'dist/cjs/can-log',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-log'
            },
            'resolutions': {}
        },
        {
            'name': 'can-attribute-encoder',
            'version': '1.1.4',
            'fileUrl': './node_modules/can-attribute-encoder/package.json',
            'main': 'can-attribute-encoder',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-attribute-encoder'
            },
            'resolutions': {}
        },
        {
            'name': 'he',
            'version': '1.1.1',
            'fileUrl': './node_modules/he/package.json',
            'main': 'he.js',
            'resolutions': {}
        },
        {
            'name': 'micro-location',
            'version': '0.1.5',
            'fileUrl': './node_modules/micro-location/package.json',
            'main': 'lib/micro-location.js',
            'resolutions': {}
        }
    ], { 'npmParentMap': {} }));
});
/*steal-qunit@2.0.0#add-dom*/
define('steal-qunit@2.0.0#add-dom', function (require, exports, module) {
    'format cjs';
    if (!document.getElementById('qunit')) {
        var qunit = document.createElement('div');
        qunit.id = 'qunit';
        (document.body || document.documentElement).appendChild(qunit);
    }
});
/*qunit@2.9.2#qunit/qunit*/
define('qunit@2.9.2#qunit/qunit', [
    'module',
    '@loader',
    'require',
    'steal-qunit/add-dom'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: ['steal-qunit/add-dom'],
        exports: 'QUnit'
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/*!\n * QUnit 2.9.2\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2019-02-21T22:49Z\n */\n(function (global$1) {\n  \'use strict\';\n\n  global$1 = global$1 && global$1.hasOwnProperty(\'default\') ? global$1[\'default\'] : global$1;\n\n  var window$1 = global$1.window;\n  var self$1 = global$1.self;\n  var console = global$1.console;\n  var setTimeout$1 = global$1.setTimeout;\n  var clearTimeout = global$1.clearTimeout;\n\n  var document$1 = window$1 && window$1.document;\n  var navigator = window$1 && window$1.navigator;\n\n  var localSessionStorage = function () {\n  \tvar x = "qunit-test-string";\n  \ttry {\n  \t\tglobal$1.sessionStorage.setItem(x, x);\n  \t\tglobal$1.sessionStorage.removeItem(x);\n  \t\treturn global$1.sessionStorage;\n  \t} catch (e) {\n  \t\treturn undefined;\n  \t}\n  }();\n\n  /**\n   * Returns a function that proxies to the given method name on the globals\n   * console object. The proxy will also detect if the console doesn\'t exist and\n   * will appropriately no-op. This allows support for IE9, which doesn\'t have a\n   * console if the developer tools are not open.\n   */\n  function consoleProxy(method) {\n  \treturn function () {\n  \t\tif (console) {\n  \t\t\tconsole[method].apply(console, arguments);\n  \t\t}\n  \t};\n  }\n\n  var Logger = {\n  \twarn: consoleProxy("warn")\n  };\n\n  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n  };\n\n\n\n\n\n\n\n\n\n\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError("Cannot call a class as a function");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if ("value" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  var toString = Object.prototype.toString;\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var now = Date.now || function () {\n  \treturn new Date().getTime();\n  };\n\n  var hasPerformanceApi = detectPerformanceApi();\n  var performance = hasPerformanceApi ? window$1.performance : undefined;\n  var performanceNow = hasPerformanceApi ? performance.now.bind(performance) : now;\n\n  function detectPerformanceApi() {\n  \treturn window$1 && typeof window$1.performance !== "undefined" && typeof window$1.performance.mark === "function" && typeof window$1.performance.measure === "function";\n  }\n\n  function measure(comment, startMark, endMark) {\n\n  \t// `performance.measure` may fail if the mark could not be found.\n  \t// reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`\n  \ttry {\n  \t\tperformance.measure(comment, startMark, endMark);\n  \t} catch (ex) {\n  \t\tLogger.warn("performance.measure could not be executed because of ", ex.message);\n  \t}\n  }\n\n  var defined = {\n  \tdocument: window$1 && window$1.document !== undefined,\n  \tsetTimeout: setTimeout$1 !== undefined\n  };\n\n  // Returns a new Array with the elements that are in a but not in b\n  function diff(a, b) {\n  \tvar i,\n  \t    j,\n  \t    result = a.slice();\n\n  \tfor (i = 0; i < result.length; i++) {\n  \t\tfor (j = 0; j < b.length; j++) {\n  \t\t\tif (result[i] === b[j]) {\n  \t\t\t\tresult.splice(i, 1);\n  \t\t\t\ti--;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t}\n  \treturn result;\n  }\n\n  /**\n   * Determines whether an element exists in a given array or not.\n   *\n   * @method inArray\n   * @param {Any} elem\n   * @param {Array} array\n   * @return {Boolean}\n   */\n  function inArray(elem, array) {\n  \treturn array.indexOf(elem) !== -1;\n  }\n\n  /**\n   * Makes a clone of an object using only Array or Object as base,\n   * and copies over the own enumerable properties.\n   *\n   * @param {Object} obj\n   * @return {Object} New object with only the own properties (recursively).\n   */\n  function objectValues(obj) {\n  \tvar key,\n  \t    val,\n  \t    vals = is("array", obj) ? [] : {};\n  \tfor (key in obj) {\n  \t\tif (hasOwn.call(obj, key)) {\n  \t\t\tval = obj[key];\n  \t\t\tvals[key] = val === Object(val) ? objectValues(val) : val;\n  \t\t}\n  \t}\n  \treturn vals;\n  }\n\n  function extend(a, b, undefOnly) {\n  \tfor (var prop in b) {\n  \t\tif (hasOwn.call(b, prop)) {\n  \t\t\tif (b[prop] === undefined) {\n  \t\t\t\tdelete a[prop];\n  \t\t\t} else if (!(undefOnly && typeof a[prop] !== "undefined")) {\n  \t\t\t\ta[prop] = b[prop];\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn a;\n  }\n\n  function objectType(obj) {\n  \tif (typeof obj === "undefined") {\n  \t\treturn "undefined";\n  \t}\n\n  \t// Consider: typeof null === object\n  \tif (obj === null) {\n  \t\treturn "null";\n  \t}\n\n  \tvar match = toString.call(obj).match(/^\\[object\\s(.*)\\]$/),\n  \t    type = match && match[1];\n\n  \tswitch (type) {\n  \t\tcase "Number":\n  \t\t\tif (isNaN(obj)) {\n  \t\t\t\treturn "nan";\n  \t\t\t}\n  \t\t\treturn "number";\n  \t\tcase "String":\n  \t\tcase "Boolean":\n  \t\tcase "Array":\n  \t\tcase "Set":\n  \t\tcase "Map":\n  \t\tcase "Date":\n  \t\tcase "RegExp":\n  \t\tcase "Function":\n  \t\tcase "Symbol":\n  \t\t\treturn type.toLowerCase();\n  \t\tdefault:\n  \t\t\treturn typeof obj === "undefined" ? "undefined" : _typeof(obj);\n  \t}\n  }\n\n  // Safe object type checking\n  function is(type, obj) {\n  \treturn objectType(obj) === type;\n  }\n\n  // Based on Java\'s String.hashCode, a simple but not\n  // rigorously collision resistant hashing function\n  function generateHash(module, testName) {\n  \tvar str = module + "\\x1C" + testName;\n  \tvar hash = 0;\n\n  \tfor (var i = 0; i < str.length; i++) {\n  \t\thash = (hash << 5) - hash + str.charCodeAt(i);\n  \t\thash |= 0;\n  \t}\n\n  \t// Convert the possibly negative integer hash code into an 8 character hex string, which isn\'t\n  \t// strictly necessary but increases user understanding that the id is a SHA-like hash\n  \tvar hex = (0x100000000 + hash).toString(16);\n  \tif (hex.length < 8) {\n  \t\thex = "0000000" + hex;\n  \t}\n\n  \treturn hex.slice(-8);\n  }\n\n  // Test for equality any JavaScript type.\n  // Authors: Philippe Rathé <prathe@gmail.com>, David Chan <david@troi.org>\n  var equiv = (function () {\n\n  \t// Value pairs queued for comparison. Used for breadth-first processing order, recursion\n  \t// detection and avoiding repeated comparison (see below for details).\n  \t// Elements are { a: val, b: val }.\n  \tvar pairs = [];\n\n  \tvar getProto = Object.getPrototypeOf || function (obj) {\n  \t\treturn obj.__proto__;\n  \t};\n\n  \tfunction useStrictEquality(a, b) {\n\n  \t\t// This only gets called if a and b are not strict equal, and is used to compare on\n  \t\t// the primitive values inside object wrappers. For example:\n  \t\t// `var i = 1;`\n  \t\t// `var j = new Number(1);`\n  \t\t// Neither a nor b can be null, as a !== b and they have the same type.\n  \t\tif ((typeof a === "undefined" ? "undefined" : _typeof(a)) === "object") {\n  \t\t\ta = a.valueOf();\n  \t\t}\n  \t\tif ((typeof b === "undefined" ? "undefined" : _typeof(b)) === "object") {\n  \t\t\tb = b.valueOf();\n  \t\t}\n\n  \t\treturn a === b;\n  \t}\n\n  \tfunction compareConstructors(a, b) {\n  \t\tvar protoA = getProto(a);\n  \t\tvar protoB = getProto(b);\n\n  \t\t// Comparing constructors is more strict than using `instanceof`\n  \t\tif (a.constructor === b.constructor) {\n  \t\t\treturn true;\n  \t\t}\n\n  \t\t// Ref #851\n  \t\t// If the obj prototype descends from a null constructor, treat it\n  \t\t// as a null prototype.\n  \t\tif (protoA && protoA.constructor === null) {\n  \t\t\tprotoA = null;\n  \t\t}\n  \t\tif (protoB && protoB.constructor === null) {\n  \t\t\tprotoB = null;\n  \t\t}\n\n  \t\t// Allow objects with no prototype to be equivalent to\n  \t\t// objects with Object as their constructor.\n  \t\tif (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {\n  \t\t\treturn true;\n  \t\t}\n\n  \t\treturn false;\n  \t}\n\n  \tfunction getRegExpFlags(regexp) {\n  \t\treturn "flags" in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];\n  \t}\n\n  \tfunction isContainer(val) {\n  \t\treturn ["object", "array", "map", "set"].indexOf(objectType(val)) !== -1;\n  \t}\n\n  \tfunction breadthFirstCompareChild(a, b) {\n\n  \t\t// If a is a container not reference-equal to b, postpone the comparison to the\n  \t\t// end of the pairs queue -- unless (a, b) has been seen before, in which case skip\n  \t\t// over the pair.\n  \t\tif (a === b) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tif (!isContainer(a)) {\n  \t\t\treturn typeEquiv(a, b);\n  \t\t}\n  \t\tif (pairs.every(function (pair) {\n  \t\t\treturn pair.a !== a || pair.b !== b;\n  \t\t})) {\n\n  \t\t\t// Not yet started comparing this pair\n  \t\t\tpairs.push({ a: a, b: b });\n  \t\t}\n  \t\treturn true;\n  \t}\n\n  \tvar callbacks = {\n  \t\t"string": useStrictEquality,\n  \t\t"boolean": useStrictEquality,\n  \t\t"number": useStrictEquality,\n  \t\t"null": useStrictEquality,\n  \t\t"undefined": useStrictEquality,\n  \t\t"symbol": useStrictEquality,\n  \t\t"date": useStrictEquality,\n\n  \t\t"nan": function nan() {\n  \t\t\treturn true;\n  \t\t},\n\n  \t\t"regexp": function regexp(a, b) {\n  \t\t\treturn a.source === b.source &&\n\n  \t\t\t// Include flags in the comparison\n  \t\t\tgetRegExpFlags(a) === getRegExpFlags(b);\n  \t\t},\n\n  \t\t// abort (identical references / instance methods were skipped earlier)\n  \t\t"function": function _function() {\n  \t\t\treturn false;\n  \t\t},\n\n  \t\t"array": function array(a, b) {\n  \t\t\tvar i, len;\n\n  \t\t\tlen = a.length;\n  \t\t\tif (len !== b.length) {\n\n  \t\t\t\t// Safe and faster\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\tfor (i = 0; i < len; i++) {\n\n  \t\t\t\t// Compare non-containers; queue non-reference-equal containers\n  \t\t\t\tif (!breadthFirstCompareChild(a[i], b[i])) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn true;\n  \t\t},\n\n  \t\t// Define sets a and b to be equivalent if for each element aVal in a, there\n  \t\t// is some element bVal in b such that aVal and bVal are equivalent. Element\n  \t\t// repetitions are not counted, so these are equivalent:\n  \t\t// a = new Set( [ {}, [], [] ] );\n  \t\t// b = new Set( [ {}, {}, [] ] );\n  \t\t"set": function set$$1(a, b) {\n  \t\t\tvar innerEq,\n  \t\t\t    outerEq = true;\n\n  \t\t\tif (a.size !== b.size) {\n\n  \t\t\t\t// This optimization has certain quirks because of the lack of\n  \t\t\t\t// repetition counting. For instance, adding the same\n  \t\t\t\t// (reference-identical) element to two equivalent sets can\n  \t\t\t\t// make them non-equivalent.\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\ta.forEach(function (aVal) {\n\n  \t\t\t\t// Short-circuit if the result is already known. (Using for...of\n  \t\t\t\t// with a break clause would be cleaner here, but it would cause\n  \t\t\t\t// a syntax error on older Javascript implementations even if\n  \t\t\t\t// Set is unused)\n  \t\t\t\tif (!outerEq) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tinnerEq = false;\n\n  \t\t\t\tb.forEach(function (bVal) {\n  \t\t\t\t\tvar parentPairs;\n\n  \t\t\t\t\t// Likewise, short-circuit if the result is already known\n  \t\t\t\t\tif (innerEq) {\n  \t\t\t\t\t\treturn;\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// Swap out the global pairs list, as the nested call to\n  \t\t\t\t\t// innerEquiv will clobber its contents\n  \t\t\t\t\tparentPairs = pairs;\n  \t\t\t\t\tif (innerEquiv(bVal, aVal)) {\n  \t\t\t\t\t\tinnerEq = true;\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// Replace the global pairs list\n  \t\t\t\t\tpairs = parentPairs;\n  \t\t\t\t});\n\n  \t\t\t\tif (!innerEq) {\n  \t\t\t\t\touterEq = false;\n  \t\t\t\t}\n  \t\t\t});\n\n  \t\t\treturn outerEq;\n  \t\t},\n\n  \t\t// Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)\n  \t\t// in a, there is some key-value pair (bKey, bVal) in b such that\n  \t\t// [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not\n  \t\t// counted, so these are equivalent:\n  \t\t// a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );\n  \t\t// b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );\n  \t\t"map": function map(a, b) {\n  \t\t\tvar innerEq,\n  \t\t\t    outerEq = true;\n\n  \t\t\tif (a.size !== b.size) {\n\n  \t\t\t\t// This optimization has certain quirks because of the lack of\n  \t\t\t\t// repetition counting. For instance, adding the same\n  \t\t\t\t// (reference-identical) key-value pair to two equivalent maps\n  \t\t\t\t// can make them non-equivalent.\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\ta.forEach(function (aVal, aKey) {\n\n  \t\t\t\t// Short-circuit if the result is already known. (Using for...of\n  \t\t\t\t// with a break clause would be cleaner here, but it would cause\n  \t\t\t\t// a syntax error on older Javascript implementations even if\n  \t\t\t\t// Map is unused)\n  \t\t\t\tif (!outerEq) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tinnerEq = false;\n\n  \t\t\t\tb.forEach(function (bVal, bKey) {\n  \t\t\t\t\tvar parentPairs;\n\n  \t\t\t\t\t// Likewise, short-circuit if the result is already known\n  \t\t\t\t\tif (innerEq) {\n  \t\t\t\t\t\treturn;\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// Swap out the global pairs list, as the nested call to\n  \t\t\t\t\t// innerEquiv will clobber its contents\n  \t\t\t\t\tparentPairs = pairs;\n  \t\t\t\t\tif (innerEquiv([bVal, bKey], [aVal, aKey])) {\n  \t\t\t\t\t\tinnerEq = true;\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// Replace the global pairs list\n  \t\t\t\t\tpairs = parentPairs;\n  \t\t\t\t});\n\n  \t\t\t\tif (!innerEq) {\n  \t\t\t\t\touterEq = false;\n  \t\t\t\t}\n  \t\t\t});\n\n  \t\t\treturn outerEq;\n  \t\t},\n\n  \t\t"object": function object(a, b) {\n  \t\t\tvar i,\n  \t\t\t    aProperties = [],\n  \t\t\t    bProperties = [];\n\n  \t\t\tif (compareConstructors(a, b) === false) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\t// Be strict: don\'t ensure hasOwnProperty and go deep\n  \t\t\tfor (i in a) {\n\n  \t\t\t\t// Collect a\'s properties\n  \t\t\t\taProperties.push(i);\n\n  \t\t\t\t// Skip OOP methods that look the same\n  \t\t\t\tif (a.constructor !== Object && typeof a.constructor !== "undefined" && typeof a[i] === "function" && typeof b[i] === "function" && a[i].toString() === b[i].toString()) {\n  \t\t\t\t\tcontinue;\n  \t\t\t\t}\n\n  \t\t\t\t// Compare non-containers; queue non-reference-equal containers\n  \t\t\t\tif (!breadthFirstCompareChild(a[i], b[i])) {\n  \t\t\t\t\treturn false;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tfor (i in b) {\n\n  \t\t\t\t// Collect b\'s properties\n  \t\t\t\tbProperties.push(i);\n  \t\t\t}\n\n  \t\t\t// Ensures identical properties name\n  \t\t\treturn typeEquiv(aProperties.sort(), bProperties.sort());\n  \t\t}\n  \t};\n\n  \tfunction typeEquiv(a, b) {\n  \t\tvar type = objectType(a);\n\n  \t\t// Callbacks for containers will append to the pairs queue to achieve breadth-first\n  \t\t// search order. The pairs queue is also used to avoid reprocessing any pair of\n  \t\t// containers that are reference-equal to a previously visited pair (a special case\n  \t\t// this being recursion detection).\n  \t\t//\n  \t\t// Because of this approach, once typeEquiv returns a false value, it should not be\n  \t\t// called again without clearing the pair queue else it may wrongly report a visited\n  \t\t// pair as being equivalent.\n  \t\treturn objectType(b) === type && callbacks[type](a, b);\n  \t}\n\n  \tfunction innerEquiv(a, b) {\n  \t\tvar i, pair;\n\n  \t\t// We\'re done when there\'s nothing more to compare\n  \t\tif (arguments.length < 2) {\n  \t\t\treturn true;\n  \t\t}\n\n  \t\t// Clear the global pair queue and add the top-level values being compared\n  \t\tpairs = [{ a: a, b: b }];\n\n  \t\tfor (i = 0; i < pairs.length; i++) {\n  \t\t\tpair = pairs[i];\n\n  \t\t\t// Perform type-specific comparison on any pairs that are not strictly\n  \t\t\t// equal. For container types, that comparison will postpone comparison\n  \t\t\t// of any sub-container pair to the end of the pair queue. This gives\n  \t\t\t// breadth-first search order. It also avoids the reprocessing of\n  \t\t\t// reference-equal siblings, cousins etc, which can have a significant speed\n  \t\t\t// impact when comparing a container of small objects each of which has a\n  \t\t\t// reference to the same (singleton) large object.\n  \t\t\tif (pair.a !== pair.b && !typeEquiv(pair.a, pair.b)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n\n  \t\t// ...across all consecutive argument pairs\n  \t\treturn arguments.length === 2 || innerEquiv.apply(this, [].slice.call(arguments, 1));\n  \t}\n\n  \treturn function () {\n  \t\tvar result = innerEquiv.apply(undefined, arguments);\n\n  \t\t// Release any retained objects\n  \t\tpairs.length = 0;\n  \t\treturn result;\n  \t};\n  })();\n\n  /**\n   * Config object: Maintain internal state\n   * Later exposed as QUnit.config\n   * `config` initialized at top of scope\n   */\n  var config = {\n\n  \t// The queue of tests to run\n  \tqueue: [],\n\n  \t// Block until document ready\n  \tblocking: true,\n\n  \t// By default, run previously failed tests first\n  \t// very useful in combination with "Hide passed tests" checked\n  \treorder: true,\n\n  \t// By default, modify document.title when suite is done\n  \taltertitle: true,\n\n  \t// HTML Reporter: collapse every test except the first failing test\n  \t// If false, all failing tests will be expanded\n  \tcollapse: true,\n\n  \t// By default, scroll to top of the page when suite is done\n  \tscrolltop: true,\n\n  \t// Depth up-to which object will be dumped\n  \tmaxDepth: 5,\n\n  \t// When enabled, all tests must call expect()\n  \trequireExpects: false,\n\n  \t// Placeholder for user-configurable form-exposed URL parameters\n  \turlConfig: [],\n\n  \t// Set of all modules.\n  \tmodules: [],\n\n  \t// The first unnamed module\n  \tcurrentModule: {\n  \t\tname: "",\n  \t\ttests: [],\n  \t\tchildModules: [],\n  \t\ttestsRun: 0,\n  \t\tunskippedTestsRun: 0,\n  \t\thooks: {\n  \t\t\tbefore: [],\n  \t\t\tbeforeEach: [],\n  \t\t\tafterEach: [],\n  \t\t\tafter: []\n  \t\t}\n  \t},\n\n  \tcallbacks: {},\n\n  \t// The storage module to use for reordering tests\n  \tstorage: localSessionStorage\n  };\n\n  // take a predefined QUnit.config and extend the defaults\n  var globalConfig = window$1 && window$1.QUnit && window$1.QUnit.config;\n\n  // only extend the global config if there is no QUnit overload\n  if (window$1 && window$1.QUnit && !window$1.QUnit.version) {\n  \textend(config, globalConfig);\n  }\n\n  // Push a loose unnamed module to the modules collection\n  config.modules.push(config.currentModule);\n\n  // Based on jsDump by Ariel Flesler\n  // http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\n  var dump = (function () {\n  \tfunction quote(str) {\n  \t\treturn "\\"" + str.toString().replace(/\\\\/g, "\\\\\\\\").replace(/"/g, "\\\\\\"") + "\\"";\n  \t}\n  \tfunction literal(o) {\n  \t\treturn o + "";\n  \t}\n  \tfunction join(pre, arr, post) {\n  \t\tvar s = dump.separator(),\n  \t\t    base = dump.indent(),\n  \t\t    inner = dump.indent(1);\n  \t\tif (arr.join) {\n  \t\t\tarr = arr.join("," + s + inner);\n  \t\t}\n  \t\tif (!arr) {\n  \t\t\treturn pre + post;\n  \t\t}\n  \t\treturn [pre, inner + arr, base + post].join(s);\n  \t}\n  \tfunction array(arr, stack) {\n  \t\tvar i = arr.length,\n  \t\t    ret = new Array(i);\n\n  \t\tif (dump.maxDepth && dump.depth > dump.maxDepth) {\n  \t\t\treturn "[object Array]";\n  \t\t}\n\n  \t\tthis.up();\n  \t\twhile (i--) {\n  \t\t\tret[i] = this.parse(arr[i], undefined, stack);\n  \t\t}\n  \t\tthis.down();\n  \t\treturn join("[", ret, "]");\n  \t}\n\n  \tfunction isArray(obj) {\n  \t\treturn (\n\n  \t\t\t//Native Arrays\n  \t\t\ttoString.call(obj) === "[object Array]" ||\n\n  \t\t\t// NodeList objects\n  \t\t\ttypeof obj.length === "number" && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined)\n  \t\t);\n  \t}\n\n  \tvar reName = /^function (\\w+)/,\n  \t    dump = {\n\n  \t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n  \t\tparse: function parse(obj, objType, stack) {\n  \t\t\tstack = stack || [];\n  \t\t\tvar res,\n  \t\t\t    parser,\n  \t\t\t    parserType,\n  \t\t\t    objIndex = stack.indexOf(obj);\n\n  \t\t\tif (objIndex !== -1) {\n  \t\t\t\treturn "recursion(" + (objIndex - stack.length) + ")";\n  \t\t\t}\n\n  \t\t\tobjType = objType || this.typeOf(obj);\n  \t\t\tparser = this.parsers[objType];\n  \t\t\tparserType = typeof parser === "undefined" ? "undefined" : _typeof(parser);\n\n  \t\t\tif (parserType === "function") {\n  \t\t\t\tstack.push(obj);\n  \t\t\t\tres = parser.call(this, obj, stack);\n  \t\t\t\tstack.pop();\n  \t\t\t\treturn res;\n  \t\t\t}\n  \t\t\treturn parserType === "string" ? parser : this.parsers.error;\n  \t\t},\n  \t\ttypeOf: function typeOf(obj) {\n  \t\t\tvar type;\n\n  \t\t\tif (obj === null) {\n  \t\t\t\ttype = "null";\n  \t\t\t} else if (typeof obj === "undefined") {\n  \t\t\t\ttype = "undefined";\n  \t\t\t} else if (is("regexp", obj)) {\n  \t\t\t\ttype = "regexp";\n  \t\t\t} else if (is("date", obj)) {\n  \t\t\t\ttype = "date";\n  \t\t\t} else if (is("function", obj)) {\n  \t\t\t\ttype = "function";\n  \t\t\t} else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {\n  \t\t\t\ttype = "window";\n  \t\t\t} else if (obj.nodeType === 9) {\n  \t\t\t\ttype = "document";\n  \t\t\t} else if (obj.nodeType) {\n  \t\t\t\ttype = "node";\n  \t\t\t} else if (isArray(obj)) {\n  \t\t\t\ttype = "array";\n  \t\t\t} else if (obj.constructor === Error.prototype.constructor) {\n  \t\t\t\ttype = "error";\n  \t\t\t} else {\n  \t\t\t\ttype = typeof obj === "undefined" ? "undefined" : _typeof(obj);\n  \t\t\t}\n  \t\t\treturn type;\n  \t\t},\n\n  \t\tseparator: function separator() {\n  \t\t\tif (this.multiline) {\n  \t\t\t\treturn this.HTML ? "<br />" : "\\n";\n  \t\t\t} else {\n  \t\t\t\treturn this.HTML ? "&#160;" : " ";\n  \t\t\t}\n  \t\t},\n\n  \t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n  \t\tindent: function indent(extra) {\n  \t\t\tif (!this.multiline) {\n  \t\t\t\treturn "";\n  \t\t\t}\n  \t\t\tvar chr = this.indentChar;\n  \t\t\tif (this.HTML) {\n  \t\t\t\tchr = chr.replace(/\\t/g, "   ").replace(/ /g, "&#160;");\n  \t\t\t}\n  \t\t\treturn new Array(this.depth + (extra || 0)).join(chr);\n  \t\t},\n  \t\tup: function up(a) {\n  \t\t\tthis.depth += a || 1;\n  \t\t},\n  \t\tdown: function down(a) {\n  \t\t\tthis.depth -= a || 1;\n  \t\t},\n  \t\tsetParser: function setParser(name, parser) {\n  \t\t\tthis.parsers[name] = parser;\n  \t\t},\n\n  \t\t// The next 3 are exposed so you can use them\n  \t\tquote: quote,\n  \t\tliteral: literal,\n  \t\tjoin: join,\n  \t\tdepth: 1,\n  \t\tmaxDepth: config.maxDepth,\n\n  \t\t// This is the list of parsers, to modify them, use dump.setParser\n  \t\tparsers: {\n  \t\t\twindow: "[Window]",\n  \t\t\tdocument: "[Document]",\n  \t\t\terror: function error(_error) {\n  \t\t\t\treturn "Error(\\"" + _error.message + "\\")";\n  \t\t\t},\n  \t\t\tunknown: "[Unknown]",\n  \t\t\t"null": "null",\n  \t\t\t"undefined": "undefined",\n  \t\t\t"function": function _function(fn) {\n  \t\t\t\tvar ret = "function",\n\n\n  \t\t\t\t// Functions never have name in IE\n  \t\t\t\tname = "name" in fn ? fn.name : (reName.exec(fn) || [])[1];\n\n  \t\t\t\tif (name) {\n  \t\t\t\t\tret += " " + name;\n  \t\t\t\t}\n  \t\t\t\tret += "(";\n\n  \t\t\t\tret = [ret, dump.parse(fn, "functionArgs"), "){"].join("");\n  \t\t\t\treturn join(ret, dump.parse(fn, "functionCode"), "}");\n  \t\t\t},\n  \t\t\tarray: array,\n  \t\t\tnodelist: array,\n  \t\t\t"arguments": array,\n  \t\t\tobject: function object(map, stack) {\n  \t\t\t\tvar keys,\n  \t\t\t\t    key,\n  \t\t\t\t    val,\n  \t\t\t\t    i,\n  \t\t\t\t    nonEnumerableProperties,\n  \t\t\t\t    ret = [];\n\n  \t\t\t\tif (dump.maxDepth && dump.depth > dump.maxDepth) {\n  \t\t\t\t\treturn "[object Object]";\n  \t\t\t\t}\n\n  \t\t\t\tdump.up();\n  \t\t\t\tkeys = [];\n  \t\t\t\tfor (key in map) {\n  \t\t\t\t\tkeys.push(key);\n  \t\t\t\t}\n\n  \t\t\t\t// Some properties are not always enumerable on Error objects.\n  \t\t\t\tnonEnumerableProperties = ["message", "name"];\n  \t\t\t\tfor (i in nonEnumerableProperties) {\n  \t\t\t\t\tkey = nonEnumerableProperties[i];\n  \t\t\t\t\tif (key in map && !inArray(key, keys)) {\n  \t\t\t\t\t\tkeys.push(key);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tkeys.sort();\n  \t\t\t\tfor (i = 0; i < keys.length; i++) {\n  \t\t\t\t\tkey = keys[i];\n  \t\t\t\t\tval = map[key];\n  \t\t\t\t\tret.push(dump.parse(key, "key") + ": " + dump.parse(val, undefined, stack));\n  \t\t\t\t}\n  \t\t\t\tdump.down();\n  \t\t\t\treturn join("{", ret, "}");\n  \t\t\t},\n  \t\t\tnode: function node(_node) {\n  \t\t\t\tvar len,\n  \t\t\t\t    i,\n  \t\t\t\t    val,\n  \t\t\t\t    open = dump.HTML ? "&lt;" : "<",\n  \t\t\t\t    close = dump.HTML ? "&gt;" : ">",\n  \t\t\t\t    tag = _node.nodeName.toLowerCase(),\n  \t\t\t\t    ret = open + tag,\n  \t\t\t\t    attrs = _node.attributes;\n\n  \t\t\t\tif (attrs) {\n  \t\t\t\t\tfor (i = 0, len = attrs.length; i < len; i++) {\n  \t\t\t\t\t\tval = attrs[i].nodeValue;\n\n  \t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n  \t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, "" or\n  \t\t\t\t\t\t// "inherit".\n  \t\t\t\t\t\tif (val && val !== "inherit") {\n  \t\t\t\t\t\t\tret += " " + attrs[i].nodeName + "=" + dump.parse(val, "attribute");\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tret += close;\n\n  \t\t\t\t// Show content of TextNode or CDATASection\n  \t\t\t\tif (_node.nodeType === 3 || _node.nodeType === 4) {\n  \t\t\t\t\tret += _node.nodeValue;\n  \t\t\t\t}\n\n  \t\t\t\treturn ret + open + "/" + tag + close;\n  \t\t\t},\n\n  \t\t\t// Function calls it internally, it\'s the arguments part of the function\n  \t\t\tfunctionArgs: function functionArgs(fn) {\n  \t\t\t\tvar args,\n  \t\t\t\t    l = fn.length;\n\n  \t\t\t\tif (!l) {\n  \t\t\t\t\treturn "";\n  \t\t\t\t}\n\n  \t\t\t\targs = new Array(l);\n  \t\t\t\twhile (l--) {\n\n  \t\t\t\t\t// 97 is \'a\'\n  \t\t\t\t\targs[l] = String.fromCharCode(97 + l);\n  \t\t\t\t}\n  \t\t\t\treturn " " + args.join(", ") + " ";\n  \t\t\t},\n\n  \t\t\t// Object calls it internally, the key part of an item in a map\n  \t\t\tkey: quote,\n\n  \t\t\t// Function calls it internally, it\'s the content of the function\n  \t\t\tfunctionCode: "[code]",\n\n  \t\t\t// Node calls it internally, it\'s a html attribute value\n  \t\t\tattribute: quote,\n  \t\t\tstring: quote,\n  \t\t\tdate: quote,\n  \t\t\tregexp: literal,\n  \t\t\tnumber: literal,\n  \t\t\t"boolean": literal,\n  \t\t\tsymbol: function symbol(sym) {\n  \t\t\t\treturn sym.toString();\n  \t\t\t}\n  \t\t},\n\n  \t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n  \t\tHTML: false,\n\n  \t\t// Indentation unit\n  \t\tindentChar: "  ",\n\n  \t\t// If true, items in a collection, are separated by a \\n, else just a space.\n  \t\tmultiline: true\n  \t};\n\n  \treturn dump;\n  })();\n\n  var SuiteReport = function () {\n  \tfunction SuiteReport(name, parentSuite) {\n  \t\tclassCallCheck(this, SuiteReport);\n\n  \t\tthis.name = name;\n  \t\tthis.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];\n\n  \t\tthis.tests = [];\n  \t\tthis.childSuites = [];\n\n  \t\tif (parentSuite) {\n  \t\t\tparentSuite.pushChildSuite(this);\n  \t\t}\n  \t}\n\n  \tcreateClass(SuiteReport, [{\n  \t\tkey: "start",\n  \t\tvalue: function start(recordTime) {\n  \t\t\tif (recordTime) {\n  \t\t\t\tthis._startTime = performanceNow();\n\n  \t\t\t\tif (performance) {\n  \t\t\t\t\tvar suiteLevel = this.fullName.length;\n  \t\t\t\t\tperformance.mark("qunit_suite_" + suiteLevel + "_start");\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn {\n  \t\t\t\tname: this.name,\n  \t\t\t\tfullName: this.fullName.slice(),\n  \t\t\t\ttests: this.tests.map(function (test) {\n  \t\t\t\t\treturn test.start();\n  \t\t\t\t}),\n  \t\t\t\tchildSuites: this.childSuites.map(function (suite) {\n  \t\t\t\t\treturn suite.start();\n  \t\t\t\t}),\n  \t\t\t\ttestCounts: {\n  \t\t\t\t\ttotal: this.getTestCounts().total\n  \t\t\t\t}\n  \t\t\t};\n  \t\t}\n  \t}, {\n  \t\tkey: "end",\n  \t\tvalue: function end(recordTime) {\n  \t\t\tif (recordTime) {\n  \t\t\t\tthis._endTime = performanceNow();\n\n  \t\t\t\tif (performance) {\n  \t\t\t\t\tvar suiteLevel = this.fullName.length;\n  \t\t\t\t\tperformance.mark("qunit_suite_" + suiteLevel + "_end");\n\n  \t\t\t\t\tvar suiteName = this.fullName.join(" \u2013 ");\n\n  \t\t\t\t\tmeasure(suiteLevel === 0 ? "QUnit Test Run" : "QUnit Test Suite: " + suiteName, "qunit_suite_" + suiteLevel + "_start", "qunit_suite_" + suiteLevel + "_end");\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn {\n  \t\t\t\tname: this.name,\n  \t\t\t\tfullName: this.fullName.slice(),\n  \t\t\t\ttests: this.tests.map(function (test) {\n  \t\t\t\t\treturn test.end();\n  \t\t\t\t}),\n  \t\t\t\tchildSuites: this.childSuites.map(function (suite) {\n  \t\t\t\t\treturn suite.end();\n  \t\t\t\t}),\n  \t\t\t\ttestCounts: this.getTestCounts(),\n  \t\t\t\truntime: this.getRuntime(),\n  \t\t\t\tstatus: this.getStatus()\n  \t\t\t};\n  \t\t}\n  \t}, {\n  \t\tkey: "pushChildSuite",\n  \t\tvalue: function pushChildSuite(suite) {\n  \t\t\tthis.childSuites.push(suite);\n  \t\t}\n  \t}, {\n  \t\tkey: "pushTest",\n  \t\tvalue: function pushTest(test) {\n  \t\t\tthis.tests.push(test);\n  \t\t}\n  \t}, {\n  \t\tkey: "getRuntime",\n  \t\tvalue: function getRuntime() {\n  \t\t\treturn this._endTime - this._startTime;\n  \t\t}\n  \t}, {\n  \t\tkey: "getTestCounts",\n  \t\tvalue: function getTestCounts() {\n  \t\t\tvar counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { passed: 0, failed: 0, skipped: 0, todo: 0, total: 0 };\n\n  \t\t\tcounts = this.tests.reduce(function (counts, test) {\n  \t\t\t\tif (test.valid) {\n  \t\t\t\t\tcounts[test.getStatus()]++;\n  \t\t\t\t\tcounts.total++;\n  \t\t\t\t}\n\n  \t\t\t\treturn counts;\n  \t\t\t}, counts);\n\n  \t\t\treturn this.childSuites.reduce(function (counts, suite) {\n  \t\t\t\treturn suite.getTestCounts(counts);\n  \t\t\t}, counts);\n  \t\t}\n  \t}, {\n  \t\tkey: "getStatus",\n  \t\tvalue: function getStatus() {\n  \t\t\tvar _getTestCounts = this.getTestCounts(),\n  \t\t\t    total = _getTestCounts.total,\n  \t\t\t    failed = _getTestCounts.failed,\n  \t\t\t    skipped = _getTestCounts.skipped,\n  \t\t\t    todo = _getTestCounts.todo;\n\n  \t\t\tif (failed) {\n  \t\t\t\treturn "failed";\n  \t\t\t} else {\n  \t\t\t\tif (skipped === total) {\n  \t\t\t\t\treturn "skipped";\n  \t\t\t\t} else if (todo === total) {\n  \t\t\t\t\treturn "todo";\n  \t\t\t\t} else {\n  \t\t\t\t\treturn "passed";\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}]);\n  \treturn SuiteReport;\n  }();\n\n  var focused = false;\n\n  var moduleStack = [];\n\n  function createModule(name, testEnvironment, modifiers) {\n  \tvar parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;\n  \tvar moduleName = parentModule !== null ? [parentModule.name, name].join(" > ") : name;\n  \tvar parentSuite = parentModule ? parentModule.suiteReport : globalSuite;\n\n  \tvar skip = parentModule !== null && parentModule.skip || modifiers.skip;\n  \tvar todo = parentModule !== null && parentModule.todo || modifiers.todo;\n\n  \tvar module = {\n  \t\tname: moduleName,\n  \t\tparentModule: parentModule,\n  \t\ttests: [],\n  \t\tmoduleId: generateHash(moduleName),\n  \t\ttestsRun: 0,\n  \t\tunskippedTestsRun: 0,\n  \t\tchildModules: [],\n  \t\tsuiteReport: new SuiteReport(name, parentSuite),\n\n  \t\t// Pass along `skip` and `todo` properties from parent module, in case\n  \t\t// there is one, to childs. And use own otherwise.\n  \t\t// This property will be used to mark own tests and tests of child suites\n  \t\t// as either `skipped` or `todo`.\n  \t\tskip: skip,\n  \t\ttodo: skip ? false : todo\n  \t};\n\n  \tvar env = {};\n  \tif (parentModule) {\n  \t\tparentModule.childModules.push(module);\n  \t\textend(env, parentModule.testEnvironment);\n  \t}\n  \textend(env, testEnvironment);\n  \tmodule.testEnvironment = env;\n\n  \tconfig.modules.push(module);\n  \treturn module;\n  }\n\n  function processModule(name, options, executeNow) {\n  \tvar modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  \tif (objectType(options) === "function") {\n  \t\texecuteNow = options;\n  \t\toptions = undefined;\n  \t}\n\n  \tvar module = createModule(name, options, modifiers);\n\n  \t// Move any hooks to a \'hooks\' object\n  \tvar testEnvironment = module.testEnvironment;\n  \tvar hooks = module.hooks = {};\n\n  \tsetHookFromEnvironment(hooks, testEnvironment, "before");\n  \tsetHookFromEnvironment(hooks, testEnvironment, "beforeEach");\n  \tsetHookFromEnvironment(hooks, testEnvironment, "afterEach");\n  \tsetHookFromEnvironment(hooks, testEnvironment, "after");\n\n  \tvar moduleFns = {\n  \t\tbefore: setHookFunction(module, "before"),\n  \t\tbeforeEach: setHookFunction(module, "beforeEach"),\n  \t\tafterEach: setHookFunction(module, "afterEach"),\n  \t\tafter: setHookFunction(module, "after")\n  \t};\n\n  \tvar currentModule = config.currentModule;\n  \tif (objectType(executeNow) === "function") {\n  \t\tmoduleStack.push(module);\n  \t\tconfig.currentModule = module;\n  \t\texecuteNow.call(module.testEnvironment, moduleFns);\n  \t\tmoduleStack.pop();\n  \t\tmodule = module.parentModule || currentModule;\n  \t}\n\n  \tconfig.currentModule = module;\n\n  \tfunction setHookFromEnvironment(hooks, environment, name) {\n  \t\tvar potentialHook = environment[name];\n  \t\thooks[name] = typeof potentialHook === "function" ? [potentialHook] : [];\n  \t\tdelete environment[name];\n  \t}\n\n  \tfunction setHookFunction(module, hookName) {\n  \t\treturn function setHook(callback) {\n  \t\t\tmodule.hooks[hookName].push(callback);\n  \t\t};\n  \t}\n  }\n\n  function module$1(name, options, executeNow) {\n  \tif (focused) {\n  \t\treturn;\n  \t}\n\n  \tprocessModule(name, options, executeNow);\n  }\n\n  module$1.only = function () {\n  \tif (focused) {\n  \t\treturn;\n  \t}\n\n  \tconfig.modules.length = 0;\n  \tconfig.queue.length = 0;\n\n  \tmodule$1.apply(undefined, arguments);\n\n  \tfocused = true;\n  };\n\n  module$1.skip = function (name, options, executeNow) {\n  \tif (focused) {\n  \t\treturn;\n  \t}\n\n  \tprocessModule(name, options, executeNow, { skip: true });\n  };\n\n  module$1.todo = function (name, options, executeNow) {\n  \tif (focused) {\n  \t\treturn;\n  \t}\n\n  \tprocessModule(name, options, executeNow, { todo: true });\n  };\n\n  var LISTENERS = Object.create(null);\n  var SUPPORTED_EVENTS = ["runStart", "suiteStart", "testStart", "assertion", "testEnd", "suiteEnd", "runEnd"];\n\n  /**\n   * Emits an event with the specified data to all currently registered listeners.\n   * Callbacks will fire in the order in which they are registered (FIFO). This\n   * function is not exposed publicly; it is used by QUnit internals to emit\n   * logging events.\n   *\n   * @private\n   * @method emit\n   * @param {String} eventName\n   * @param {Object} data\n   * @return {Void}\n   */\n  function emit(eventName, data) {\n  \tif (objectType(eventName) !== "string") {\n  \t\tthrow new TypeError("eventName must be a string when emitting an event");\n  \t}\n\n  \t// Clone the callbacks in case one of them registers a new callback\n  \tvar originalCallbacks = LISTENERS[eventName];\n  \tvar callbacks = originalCallbacks ? [].concat(toConsumableArray(originalCallbacks)) : [];\n\n  \tfor (var i = 0; i < callbacks.length; i++) {\n  \t\tcallbacks[i](data);\n  \t}\n  }\n\n  /**\n   * Registers a callback as a listener to the specified event.\n   *\n   * @public\n   * @method on\n   * @param {String} eventName\n   * @param {Function} callback\n   * @return {Void}\n   */\n  function on(eventName, callback) {\n  \tif (objectType(eventName) !== "string") {\n  \t\tthrow new TypeError("eventName must be a string when registering a listener");\n  \t} else if (!inArray(eventName, SUPPORTED_EVENTS)) {\n  \t\tvar events = SUPPORTED_EVENTS.join(", ");\n  \t\tthrow new Error("\\"" + eventName + "\\" is not a valid event; must be one of: " + events + ".");\n  \t} else if (objectType(callback) !== "function") {\n  \t\tthrow new TypeError("callback must be a function when registering a listener");\n  \t}\n\n  \tif (!LISTENERS[eventName]) {\n  \t\tLISTENERS[eventName] = [];\n  \t}\n\n  \t// Don\'t register the same callback more than once\n  \tif (!inArray(callback, LISTENERS[eventName])) {\n  \t\tLISTENERS[eventName].push(callback);\n  \t}\n  }\n\n  function objectOrFunction(x) {\n    var type = typeof x === \'undefined\' ? \'undefined\' : _typeof(x);\n    return x !== null && (type === \'object\' || type === \'function\');\n  }\n\n  function isFunction(x) {\n    return typeof x === \'function\';\n  }\n\n\n\n  var _isArray = void 0;\n  if (Array.isArray) {\n    _isArray = Array.isArray;\n  } else {\n    _isArray = function _isArray(x) {\n      return Object.prototype.toString.call(x) === \'[object Array]\';\n    };\n  }\n\n  var isArray = _isArray;\n\n  var len = 0;\n  var vertxNext = void 0;\n  var customSchedulerFn = void 0;\n\n  var asap = function asap(callback, arg) {\n    queue[len] = callback;\n    queue[len + 1] = arg;\n    len += 2;\n    if (len === 2) {\n      // If len is 2, that means that we need to schedule an async flush.\n      // If additional callbacks are queued before the queue is flushed, they\n      // will be processed by this flush that we are scheduling.\n      if (customSchedulerFn) {\n        customSchedulerFn(flush);\n      } else {\n        scheduleFlush();\n      }\n    }\n  };\n\n  function setScheduler(scheduleFn) {\n    customSchedulerFn = scheduleFn;\n  }\n\n  function setAsap(asapFn) {\n    asap = asapFn;\n  }\n\n  var browserWindow = typeof window !== \'undefined\' ? window : undefined;\n  var browserGlobal = browserWindow || {};\n  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n  var isNode = typeof self === \'undefined\' && typeof process !== \'undefined\' && {}.toString.call(process) === \'[object process]\';\n\n  // test for web worker but not in IE10\n  var isWorker = typeof Uint8ClampedArray !== \'undefined\' && typeof importScripts !== \'undefined\' && typeof MessageChannel !== \'undefined\';\n\n  // node\n  function useNextTick() {\n    // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n    // see https://github.com/cujojs/when/issues/410 for details\n    return function () {\n      return process.nextTick(flush);\n    };\n  }\n\n  // vertx\n  function useVertxTimer() {\n    if (typeof vertxNext !== \'undefined\') {\n      return function () {\n        vertxNext(flush);\n      };\n    }\n\n    return useSetTimeout();\n  }\n\n  function useMutationObserver() {\n    var iterations = 0;\n    var observer = new BrowserMutationObserver(flush);\n    var node = document.createTextNode(\'\');\n    observer.observe(node, { characterData: true });\n\n    return function () {\n      node.data = iterations = ++iterations % 2;\n    };\n  }\n\n  // web worker\n  function useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    return function () {\n      return channel.port2.postMessage(0);\n    };\n  }\n\n  function useSetTimeout() {\n    // Store setTimeout reference so es6-promise will be unaffected by\n    // other code modifying setTimeout (like sinon.useFakeTimers())\n    var globalSetTimeout = setTimeout;\n    return function () {\n      return globalSetTimeout(flush, 1);\n    };\n  }\n\n  var queue = new Array(1000);\n  function flush() {\n    for (var i = 0; i < len; i += 2) {\n      var callback = queue[i];\n      var arg = queue[i + 1];\n\n      callback(arg);\n\n      queue[i] = undefined;\n      queue[i + 1] = undefined;\n    }\n\n    len = 0;\n  }\n\n  function attemptVertx() {\n    try {\n      var vertx = Function(\'return this\')().require(\'vertx\');\n      vertxNext = vertx.runOnLoop || vertx.runOnContext;\n      return useVertxTimer();\n    } catch (e) {\n      return useSetTimeout();\n    }\n  }\n\n  var scheduleFlush = void 0;\n  // Decide what async method to use to triggering processing of queued callbacks:\n  if (isNode) {\n    scheduleFlush = useNextTick();\n  } else if (BrowserMutationObserver) {\n    scheduleFlush = useMutationObserver();\n  } else if (isWorker) {\n    scheduleFlush = useMessageChannel();\n  } else if (browserWindow === undefined && typeof require === \'function\') {\n    scheduleFlush = attemptVertx();\n  } else {\n    scheduleFlush = useSetTimeout();\n  }\n\n  function then(onFulfillment, onRejection) {\n    var parent = this;\n\n    var child = new this.constructor(noop);\n\n    if (child[PROMISE_ID] === undefined) {\n      makePromise(child);\n    }\n\n    var _state = parent._state;\n\n\n    if (_state) {\n      var callback = arguments[_state - 1];\n      asap(function () {\n        return invokeCallback(_state, child, callback, parent._result);\n      });\n    } else {\n      subscribe(parent, child, onFulfillment, onRejection);\n    }\n\n    return child;\n  }\n\n  /**\n    `Promise.resolve` returns a promise that will become resolved with the\n    passed `value`. It is shorthand for the following:\n\n    ```javascript\n    let promise = new Promise(function(resolve, reject){\n      resolve(1);\n    });\n\n    promise.then(function(value){\n      // value === 1\n    });\n    ```\n\n    Instead of writing the above, your code now simply becomes the following:\n\n    ```javascript\n    let promise = Promise.resolve(1);\n\n    promise.then(function(value){\n      // value === 1\n    });\n    ```\n\n    @method resolve\n    @static\n    @param {Any} value value that the returned promise will be resolved with\n    Useful for tooling.\n    @return {Promise} a promise that will become fulfilled with the given\n    `value`\n  */\n  function resolve$1(object) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    if (object && (typeof object === \'undefined\' ? \'undefined\' : _typeof(object)) === \'object\' && object.constructor === Constructor) {\n      return object;\n    }\n\n    var promise = new Constructor(noop);\n    resolve(promise, object);\n    return promise;\n  }\n\n  var PROMISE_ID = Math.random().toString(36).substring(2);\n\n  function noop() {}\n\n  var PENDING = void 0;\n  var FULFILLED = 1;\n  var REJECTED = 2;\n\n  var TRY_CATCH_ERROR = { error: null };\n\n  function selfFulfillment() {\n    return new TypeError("You cannot resolve a promise with itself");\n  }\n\n  function cannotReturnOwn() {\n    return new TypeError(\'A promises callback cannot return that same promise.\');\n  }\n\n  function getThen(promise) {\n    try {\n      return promise.then;\n    } catch (error) {\n      TRY_CATCH_ERROR.error = error;\n      return TRY_CATCH_ERROR;\n    }\n  }\n\n  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n    try {\n      then$$1.call(value, fulfillmentHandler, rejectionHandler);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function handleForeignThenable(promise, thenable, then$$1) {\n    asap(function (promise) {\n      var sealed = false;\n      var error = tryThen(then$$1, thenable, function (value) {\n        if (sealed) {\n          return;\n        }\n        sealed = true;\n        if (thenable !== value) {\n          resolve(promise, value);\n        } else {\n          fulfill(promise, value);\n        }\n      }, function (reason) {\n        if (sealed) {\n          return;\n        }\n        sealed = true;\n\n        reject(promise, reason);\n      }, \'Settle: \' + (promise._label || \' unknown promise\'));\n\n      if (!sealed && error) {\n        sealed = true;\n        reject(promise, error);\n      }\n    }, promise);\n  }\n\n  function handleOwnThenable(promise, thenable) {\n    if (thenable._state === FULFILLED) {\n      fulfill(promise, thenable._result);\n    } else if (thenable._state === REJECTED) {\n      reject(promise, thenable._result);\n    } else {\n      subscribe(thenable, undefined, function (value) {\n        return resolve(promise, value);\n      }, function (reason) {\n        return reject(promise, reason);\n      });\n    }\n  }\n\n  function handleMaybeThenable(promise, maybeThenable, then$$1) {\n    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n      handleOwnThenable(promise, maybeThenable);\n    } else {\n      if (then$$1 === TRY_CATCH_ERROR) {\n        reject(promise, TRY_CATCH_ERROR.error);\n        TRY_CATCH_ERROR.error = null;\n      } else if (then$$1 === undefined) {\n        fulfill(promise, maybeThenable);\n      } else if (isFunction(then$$1)) {\n        handleForeignThenable(promise, maybeThenable, then$$1);\n      } else {\n        fulfill(promise, maybeThenable);\n      }\n    }\n  }\n\n  function resolve(promise, value) {\n    if (promise === value) {\n      reject(promise, selfFulfillment());\n    } else if (objectOrFunction(value)) {\n      handleMaybeThenable(promise, value, getThen(value));\n    } else {\n      fulfill(promise, value);\n    }\n  }\n\n  function publishRejection(promise) {\n    if (promise._onerror) {\n      promise._onerror(promise._result);\n    }\n\n    publish(promise);\n  }\n\n  function fulfill(promise, value) {\n    if (promise._state !== PENDING) {\n      return;\n    }\n\n    promise._result = value;\n    promise._state = FULFILLED;\n\n    if (promise._subscribers.length !== 0) {\n      asap(publish, promise);\n    }\n  }\n\n  function reject(promise, reason) {\n    if (promise._state !== PENDING) {\n      return;\n    }\n    promise._state = REJECTED;\n    promise._result = reason;\n\n    asap(publishRejection, promise);\n  }\n\n  function subscribe(parent, child, onFulfillment, onRejection) {\n    var _subscribers = parent._subscribers;\n    var length = _subscribers.length;\n\n\n    parent._onerror = null;\n\n    _subscribers[length] = child;\n    _subscribers[length + FULFILLED] = onFulfillment;\n    _subscribers[length + REJECTED] = onRejection;\n\n    if (length === 0 && parent._state) {\n      asap(publish, parent);\n    }\n  }\n\n  function publish(promise) {\n    var subscribers = promise._subscribers;\n    var settled = promise._state;\n\n    if (subscribers.length === 0) {\n      return;\n    }\n\n    var child = void 0,\n        callback = void 0,\n        detail = promise._result;\n\n    for (var i = 0; i < subscribers.length; i += 3) {\n      child = subscribers[i];\n      callback = subscribers[i + settled];\n\n      if (child) {\n        invokeCallback(settled, child, callback, detail);\n      } else {\n        callback(detail);\n      }\n    }\n\n    promise._subscribers.length = 0;\n  }\n\n  function tryCatch(callback, detail) {\n    try {\n      return callback(detail);\n    } catch (e) {\n      TRY_CATCH_ERROR.error = e;\n      return TRY_CATCH_ERROR;\n    }\n  }\n\n  function invokeCallback(settled, promise, callback, detail) {\n    var hasCallback = isFunction(callback),\n        value = void 0,\n        error = void 0,\n        succeeded = void 0,\n        failed = void 0;\n\n    if (hasCallback) {\n      value = tryCatch(callback, detail);\n\n      if (value === TRY_CATCH_ERROR) {\n        failed = true;\n        error = value.error;\n        value.error = null;\n      } else {\n        succeeded = true;\n      }\n\n      if (promise === value) {\n        reject(promise, cannotReturnOwn());\n        return;\n      }\n    } else {\n      value = detail;\n      succeeded = true;\n    }\n\n    if (promise._state !== PENDING) {\n      // noop\n    } else if (hasCallback && succeeded) {\n      resolve(promise, value);\n    } else if (failed) {\n      reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      reject(promise, value);\n    }\n  }\n\n  function initializePromise(promise, resolver) {\n    try {\n      resolver(function resolvePromise(value) {\n        resolve(promise, value);\n      }, function rejectPromise(reason) {\n        reject(promise, reason);\n      });\n    } catch (e) {\n      reject(promise, e);\n    }\n  }\n\n  var id = 0;\n  function nextId() {\n    return id++;\n  }\n\n  function makePromise(promise) {\n    promise[PROMISE_ID] = id++;\n    promise._state = undefined;\n    promise._result = undefined;\n    promise._subscribers = [];\n  }\n\n  function validationError() {\n    return new Error(\'Array Methods must be provided an Array\');\n  }\n\n  var Enumerator = function () {\n    function Enumerator(Constructor, input) {\n      classCallCheck(this, Enumerator);\n\n      this._instanceConstructor = Constructor;\n      this.promise = new Constructor(noop);\n\n      if (!this.promise[PROMISE_ID]) {\n        makePromise(this.promise);\n      }\n\n      if (isArray(input)) {\n        this.length = input.length;\n        this._remaining = input.length;\n\n        this._result = new Array(this.length);\n\n        if (this.length === 0) {\n          fulfill(this.promise, this._result);\n        } else {\n          this.length = this.length || 0;\n          this._enumerate(input);\n          if (this._remaining === 0) {\n            fulfill(this.promise, this._result);\n          }\n        }\n      } else {\n        reject(this.promise, validationError());\n      }\n    }\n\n    createClass(Enumerator, [{\n      key: \'_enumerate\',\n      value: function _enumerate(input) {\n        for (var i = 0; this._state === PENDING && i < input.length; i++) {\n          this._eachEntry(input[i], i);\n        }\n      }\n    }, {\n      key: \'_eachEntry\',\n      value: function _eachEntry(entry, i) {\n        var c = this._instanceConstructor;\n        var resolve$$1 = c.resolve;\n\n\n        if (resolve$$1 === resolve$1) {\n          var _then = getThen(entry);\n\n          if (_then === then && entry._state !== PENDING) {\n            this._settledAt(entry._state, i, entry._result);\n          } else if (typeof _then !== \'function\') {\n            this._remaining--;\n            this._result[i] = entry;\n          } else if (c === Promise$2) {\n            var promise = new c(noop);\n            handleMaybeThenable(promise, entry, _then);\n            this._willSettleAt(promise, i);\n          } else {\n            this._willSettleAt(new c(function (resolve$$1) {\n              return resolve$$1(entry);\n            }), i);\n          }\n        } else {\n          this._willSettleAt(resolve$$1(entry), i);\n        }\n      }\n    }, {\n      key: \'_settledAt\',\n      value: function _settledAt(state, i, value) {\n        var promise = this.promise;\n\n\n        if (promise._state === PENDING) {\n          this._remaining--;\n\n          if (state === REJECTED) {\n            reject(promise, value);\n          } else {\n            this._result[i] = value;\n          }\n        }\n\n        if (this._remaining === 0) {\n          fulfill(promise, this._result);\n        }\n      }\n    }, {\n      key: \'_willSettleAt\',\n      value: function _willSettleAt(promise, i) {\n        var enumerator = this;\n\n        subscribe(promise, undefined, function (value) {\n          return enumerator._settledAt(FULFILLED, i, value);\n        }, function (reason) {\n          return enumerator._settledAt(REJECTED, i, reason);\n        });\n      }\n    }]);\n    return Enumerator;\n  }();\n\n  /**\n    `Promise.all` accepts an array of promises, and returns a new promise which\n    is fulfilled with an array of fulfillment values for the passed promises, or\n    rejected with the reason of the first passed promise to be rejected. It casts all\n    elements of the passed iterable to promises as it runs this algorithm.\n\n    Example:\n\n    ```javascript\n    let promise1 = resolve(1);\n    let promise2 = resolve(2);\n    let promise3 = resolve(3);\n    let promises = [ promise1, promise2, promise3 ];\n\n    Promise.all(promises).then(function(array){\n      // The array here would be [ 1, 2, 3 ];\n    });\n    ```\n\n    If any of the `promises` given to `all` are rejected, the first promise\n    that is rejected will be given as an argument to the returned promises\'s\n    rejection handler. For example:\n\n    Example:\n\n    ```javascript\n    let promise1 = resolve(1);\n    let promise2 = reject(new Error("2"));\n    let promise3 = reject(new Error("3"));\n    let promises = [ promise1, promise2, promise3 ];\n\n    Promise.all(promises).then(function(array){\n      // Code here never runs because there are rejected promises!\n    }, function(error) {\n      // error.message === "2"\n    });\n    ```\n\n    @method all\n    @static\n    @param {Array} entries array of promises\n    @param {String} label optional string for labeling the promise.\n    Useful for tooling.\n    @return {Promise} promise that is fulfilled when all `promises` have been\n    fulfilled, or rejected if any of them become rejected.\n    @static\n  */\n  function all(entries) {\n    return new Enumerator(this, entries).promise;\n  }\n\n  /**\n    `Promise.race` returns a new promise which is settled in the same way as the\n    first passed promise to settle.\n\n    Example:\n\n    ```javascript\n    let promise1 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        resolve(\'promise 1\');\n      }, 200);\n    });\n\n    let promise2 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        resolve(\'promise 2\');\n      }, 100);\n    });\n\n    Promise.race([promise1, promise2]).then(function(result){\n      // result === \'promise 2\' because it was resolved before promise1\n      // was resolved.\n    });\n    ```\n\n    `Promise.race` is deterministic in that only the state of the first\n    settled promise matters. For example, even if other promises given to the\n    `promises` array argument are resolved, but the first settled promise has\n    become rejected before the other promises became fulfilled, the returned\n    promise will become rejected:\n\n    ```javascript\n    let promise1 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        resolve(\'promise 1\');\n      }, 200);\n    });\n\n    let promise2 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        reject(new Error(\'promise 2\'));\n      }, 100);\n    });\n\n    Promise.race([promise1, promise2]).then(function(result){\n      // Code here never runs\n    }, function(reason){\n      // reason.message === \'promise 2\' because promise 2 became rejected before\n      // promise 1 became fulfilled\n    });\n    ```\n\n    An example real-world use case is implementing timeouts:\n\n    ```javascript\n    Promise.race([ajax(\'foo.json\'), timeout(5000)])\n    ```\n\n    @method race\n    @static\n    @param {Array} promises array of promises to observe\n    Useful for tooling.\n    @return {Promise} a promise which settles in the same way as the first passed\n    promise to settle.\n  */\n  function race(entries) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    if (!isArray(entries)) {\n      return new Constructor(function (_, reject) {\n        return reject(new TypeError(\'You must pass an array to race.\'));\n      });\n    } else {\n      return new Constructor(function (resolve, reject) {\n        var length = entries.length;\n        for (var i = 0; i < length; i++) {\n          Constructor.resolve(entries[i]).then(resolve, reject);\n        }\n      });\n    }\n  }\n\n  /**\n    `Promise.reject` returns a promise rejected with the passed `reason`.\n    It is shorthand for the following:\n\n    ```javascript\n    let promise = new Promise(function(resolve, reject){\n      reject(new Error(\'WHOOPS\'));\n    });\n\n    promise.then(function(value){\n      // Code here doesn\'t run because the promise is rejected!\n    }, function(reason){\n      // reason.message === \'WHOOPS\'\n    });\n    ```\n\n    Instead of writing the above, your code now simply becomes the following:\n\n    ```javascript\n    let promise = Promise.reject(new Error(\'WHOOPS\'));\n\n    promise.then(function(value){\n      // Code here doesn\'t run because the promise is rejected!\n    }, function(reason){\n      // reason.message === \'WHOOPS\'\n    });\n    ```\n\n    @method reject\n    @static\n    @param {Any} reason value that the returned promise will be rejected with.\n    Useful for tooling.\n    @return {Promise} a promise rejected with the given `reason`.\n  */\n  function reject$1(reason) {\n    /*jshint validthis:true */\n    var Constructor = this;\n    var promise = new Constructor(noop);\n    reject(promise, reason);\n    return promise;\n  }\n\n  function needsResolver() {\n    throw new TypeError(\'You must pass a resolver function as the first argument to the promise constructor\');\n  }\n\n  function needsNew() {\n    throw new TypeError("Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.");\n  }\n\n  /**\n    Promise objects represent the eventual result of an asynchronous operation. The\n    primary way of interacting with a promise is through its `then` method, which\n    registers callbacks to receive either a promise\'s eventual value or the reason\n    why the promise cannot be fulfilled.\n\n    Terminology\n    -----------\n\n    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n    - `thenable` is an object or function that defines a `then` method.\n    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n    - `exception` is a value that is thrown using the throw statement.\n    - `reason` is a value that indicates why a promise was rejected.\n    - `settled` the final resting state of a promise, fulfilled or rejected.\n\n    A promise can be in one of three states: pending, fulfilled, or rejected.\n\n    Promises that are fulfilled have a fulfillment value and are in the fulfilled\n    state.  Promises that are rejected have a rejection reason and are in the\n    rejected state.  A fulfillment value is never a thenable.\n\n    Promises can also be said to *resolve* a value.  If this value is also a\n    promise, then the original promise\'s settled state will match the value\'s\n    settled state.  So a promise that *resolves* a promise that rejects will\n    itself reject, and a promise that *resolves* a promise that fulfills will\n    itself fulfill.\n\n\n    Basic Usage:\n    ------------\n\n    ```js\n    let promise = new Promise(function(resolve, reject) {\n      // on success\n      resolve(value);\n\n      // on failure\n      reject(reason);\n    });\n\n    promise.then(function(value) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n\n    Advanced Usage:\n    ---------------\n\n    Promises shine when abstracting away asynchronous interactions such as\n    `XMLHttpRequest`s.\n\n    ```js\n    function getJSON(url) {\n      return new Promise(function(resolve, reject){\n        let xhr = new XMLHttpRequest();\n\n        xhr.open(\'GET\', url);\n        xhr.onreadystatechange = handler;\n        xhr.responseType = \'json\';\n        xhr.setRequestHeader(\'Accept\', \'application/json\');\n        xhr.send();\n\n        function handler() {\n          if (this.readyState === this.DONE) {\n            if (this.status === 200) {\n              resolve(this.response);\n            } else {\n              reject(new Error(\'getJSON: `\' + url + \'` failed with status: [\' + this.status + \']\'));\n            }\n          }\n        };\n      });\n    }\n\n    getJSON(\'/posts.json\').then(function(json) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n\n    Unlike callbacks, promises are great composable primitives.\n\n    ```js\n    Promise.all([\n      getJSON(\'/posts\'),\n      getJSON(\'/comments\')\n    ]).then(function(values){\n      values[0] // => postsJSON\n      values[1] // => commentsJSON\n\n      return values;\n    });\n    ```\n\n    @class Promise\n    @param {Function} resolver\n    Useful for tooling.\n    @constructor\n  */\n\n  var Promise$2 = function () {\n    function Promise(resolver) {\n      classCallCheck(this, Promise);\n\n      this[PROMISE_ID] = nextId();\n      this._result = this._state = undefined;\n      this._subscribers = [];\n\n      if (noop !== resolver) {\n        typeof resolver !== \'function\' && needsResolver();\n        this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n      }\n    }\n\n    /**\n    The primary way of interacting with a promise is through its `then` method,\n    which registers callbacks to receive either a promise\'s eventual value or the\n    reason why the promise cannot be fulfilled.\n     ```js\n    findUser().then(function(user){\n      // user is available\n    }, function(reason){\n      // user is unavailable, and you are given the reason why\n    });\n    ```\n     Chaining\n    --------\n     The return value of `then` is itself a promise.  This second, \'downstream\'\n    promise is resolved with the return value of the first promise\'s fulfillment\n    or rejection handler, or rejected if the handler throws an exception.\n     ```js\n    findUser().then(function (user) {\n      return user.name;\n    }, function (reason) {\n      return \'default name\';\n    }).then(function (userName) {\n      // If `findUser` fulfilled, `userName` will be the user\'s name, otherwise it\n      // will be `\'default name\'`\n    });\n     findUser().then(function (user) {\n      throw new Error(\'Found user, but still unhappy\');\n    }, function (reason) {\n      throw new Error(\'`findUser` rejected and we\'re unhappy\');\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // if `findUser` fulfilled, `reason` will be \'Found user, but still unhappy\'.\n      // If `findUser` rejected, `reason` will be \'`findUser` rejected and we\'re unhappy\'.\n    });\n    ```\n    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n     ```js\n    findUser().then(function (user) {\n      throw new PedagogicalException(\'Upstream error\');\n    }).then(function (value) {\n      // never reached\n    }).then(function (value) {\n      // never reached\n    }, function (reason) {\n      // The `PedgagocialException` is propagated all the way down to here\n    });\n    ```\n     Assimilation\n    ------------\n     Sometimes the value you want to propagate to a downstream promise can only be\n    retrieved asynchronously. This can be achieved by returning a promise in the\n    fulfillment or rejection handler. The downstream promise will then be pending\n    until the returned promise is settled. This is called *assimilation*.\n     ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // The user\'s comments are now available\n    });\n    ```\n     If the assimliated promise rejects, then the downstream promise will also reject.\n     ```js\n    findUser().then(function (user) {\n      return findCommentsByAuthor(user);\n    }).then(function (comments) {\n      // If `findCommentsByAuthor` fulfills, we\'ll have the value here\n    }, function (reason) {\n      // If `findCommentsByAuthor` rejects, we\'ll have the reason here\n    });\n    ```\n     Simple Example\n    --------------\n     Synchronous Example\n     ```javascript\n    let result;\n     try {\n      result = findResult();\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n     Errback Example\n     ```js\n    findResult(function(result, err){\n      if (err) {\n        // failure\n      } else {\n        // success\n      }\n    });\n    ```\n     Promise Example;\n     ```javascript\n    findResult().then(function(result){\n      // success\n    }, function(reason){\n      // failure\n    });\n    ```\n     Advanced Example\n    --------------\n     Synchronous Example\n     ```javascript\n    let author, books;\n     try {\n      author = findAuthor();\n      books  = findBooksByAuthor(author);\n      // success\n    } catch(reason) {\n      // failure\n    }\n    ```\n     Errback Example\n     ```js\n     function foundBooks(books) {\n     }\n     function failure(reason) {\n     }\n     findAuthor(function(author, err){\n      if (err) {\n        failure(err);\n        // failure\n      } else {\n        try {\n          findBoooksByAuthor(author, function(books, err) {\n            if (err) {\n              failure(err);\n            } else {\n              try {\n                foundBooks(books);\n              } catch(reason) {\n                failure(reason);\n              }\n            }\n          });\n        } catch(error) {\n          failure(err);\n        }\n        // success\n      }\n    });\n    ```\n     Promise Example;\n     ```javascript\n    findAuthor().\n      then(findBooksByAuthor).\n      then(function(books){\n        // found books\n    }).catch(function(reason){\n      // something went wrong\n    });\n    ```\n     @method then\n    @param {Function} onFulfilled\n    @param {Function} onRejected\n    Useful for tooling.\n    @return {Promise}\n    */\n\n    /**\n    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n    as the catch block of a try/catch statement.\n    ```js\n    function findAuthor(){\n    throw new Error(\'couldn\'t find that author\');\n    }\n    // synchronous\n    try {\n    findAuthor();\n    } catch(reason) {\n    // something went wrong\n    }\n    // async with promises\n    findAuthor().catch(function(reason){\n    // something went wrong\n    });\n    ```\n    @method catch\n    @param {Function} onRejection\n    Useful for tooling.\n    @return {Promise}\n    */\n\n\n    createClass(Promise, [{\n      key: \'catch\',\n      value: function _catch(onRejection) {\n        return this.then(null, onRejection);\n      }\n\n      /**\n        `finally` will be invoked regardless of the promise\'s fate just as native\n        try/catch/finally behaves\n      \n        Synchronous example:\n      \n        ```js\n        findAuthor() {\n          if (Math.random() > 0.5) {\n            throw new Error();\n          }\n          return new Author();\n        }\n      \n        try {\n          return findAuthor(); // succeed or fail\n        } catch(error) {\n          return findOtherAuther();\n        } finally {\n          // always runs\n          // doesn\'t affect the return value\n        }\n        ```\n      \n        Asynchronous example:\n      \n        ```js\n        findAuthor().catch(function(reason){\n          return findOtherAuther();\n        }).finally(function(){\n          // author was either found, or not\n        });\n        ```\n      \n        @method finally\n        @param {Function} callback\n        @return {Promise}\n      */\n\n    }, {\n      key: \'finally\',\n      value: function _finally(callback) {\n        var promise = this;\n        var constructor = promise.constructor;\n\n        if (isFunction(callback)) {\n          return promise.then(function (value) {\n            return constructor.resolve(callback()).then(function () {\n              return value;\n            });\n          }, function (reason) {\n            return constructor.resolve(callback()).then(function () {\n              throw reason;\n            });\n          });\n        }\n\n        return promise.then(callback, callback);\n      }\n    }]);\n    return Promise;\n  }();\n\n  Promise$2.prototype.then = then;\n  Promise$2.all = all;\n  Promise$2.race = race;\n  Promise$2.resolve = resolve$1;\n  Promise$2.reject = reject$1;\n  Promise$2._setScheduler = setScheduler;\n  Promise$2._setAsap = setAsap;\n  Promise$2._asap = asap;\n\n  /*global self*/\n  function polyfill() {\n    var local = void 0;\n\n    if (typeof global !== \'undefined\') {\n      local = global;\n    } else if (typeof self !== \'undefined\') {\n      local = self;\n    } else {\n      try {\n        local = Function(\'return this\')();\n      } catch (e) {\n        throw new Error(\'polyfill failed because global object is unavailable in this environment\');\n      }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n      var promiseToString = null;\n      try {\n        promiseToString = Object.prototype.toString.call(P.resolve());\n      } catch (e) {\n        // silently ignored\n      }\n\n      if (promiseToString === \'[object Promise]\' && !P.cast) {\n        return;\n      }\n    }\n\n    local.Promise = Promise$2;\n  }\n\n  // Strange compat..\n  Promise$2.polyfill = polyfill;\n  Promise$2.Promise = Promise$2;\n\n  var Promise$1 = typeof Promise !== "undefined" ? Promise : Promise$2;\n\n  // Register logging callbacks\n  function registerLoggingCallbacks(obj) {\n  \tvar i,\n  \t    l,\n  \t    key,\n  \t    callbackNames = ["begin", "done", "log", "testStart", "testDone", "moduleStart", "moduleDone"];\n\n  \tfunction registerLoggingCallback(key) {\n  \t\tvar loggingCallback = function loggingCallback(callback) {\n  \t\t\tif (objectType(callback) !== "function") {\n  \t\t\t\tthrow new Error("QUnit logging methods require a callback function as their first parameters.");\n  \t\t\t}\n\n  \t\t\tconfig.callbacks[key].push(callback);\n  \t\t};\n\n  \t\treturn loggingCallback;\n  \t}\n\n  \tfor (i = 0, l = callbackNames.length; i < l; i++) {\n  \t\tkey = callbackNames[i];\n\n  \t\t// Initialize key collection of logging callback\n  \t\tif (objectType(config.callbacks[key]) === "undefined") {\n  \t\t\tconfig.callbacks[key] = [];\n  \t\t}\n\n  \t\tobj[key] = registerLoggingCallback(key);\n  \t}\n  }\n\n  function runLoggingCallbacks(key, args) {\n  \tvar callbacks = config.callbacks[key];\n\n  \t// Handling \'log\' callbacks separately. Unlike the other callbacks,\n  \t// the log callback is not controlled by the processing queue,\n  \t// but rather used by asserts. Hence to promisfy the \'log\' callback\n  \t// would mean promisfying each step of a test\n  \tif (key === "log") {\n  \t\tcallbacks.map(function (callback) {\n  \t\t\treturn callback(args);\n  \t\t});\n  \t\treturn;\n  \t}\n\n  \t// ensure that each callback is executed serially\n  \treturn callbacks.reduce(function (promiseChain, callback) {\n  \t\treturn promiseChain.then(function () {\n  \t\t\treturn Promise$1.resolve(callback(args));\n  \t\t});\n  \t}, Promise$1.resolve([]));\n  }\n\n  // Doesn\'t support IE9, it will return undefined on these browsers\n  // See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n  var fileName = (sourceFromStacktrace(0) || "").replace(/(:\\d+)+\\)?/, "").replace(/.+\\//, "");\n\n  function extractStacktrace(e, offset) {\n  \toffset = offset === undefined ? 4 : offset;\n\n  \tvar stack, include, i;\n\n  \tif (e && e.stack) {\n  \t\tstack = e.stack.split("\\n");\n  \t\tif (/^error$/i.test(stack[0])) {\n  \t\t\tstack.shift();\n  \t\t}\n  \t\tif (fileName) {\n  \t\t\tinclude = [];\n  \t\t\tfor (i = offset; i < stack.length; i++) {\n  \t\t\t\tif (stack[i].indexOf(fileName) !== -1) {\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tinclude.push(stack[i]);\n  \t\t\t}\n  \t\t\tif (include.length) {\n  \t\t\t\treturn include.join("\\n");\n  \t\t\t}\n  \t\t}\n  \t\treturn stack[offset];\n  \t}\n  }\n\n  function sourceFromStacktrace(offset) {\n  \tvar error = new Error();\n\n  \t// Support: Safari <=7 only, IE <=10 - 11 only\n  \t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n  \tif (!error.stack) {\n  \t\ttry {\n  \t\t\tthrow error;\n  \t\t} catch (err) {\n  \t\t\terror = err;\n  \t\t}\n  \t}\n\n  \treturn extractStacktrace(error, offset);\n  }\n\n  var priorityCount = 0;\n  var unitSampler = void 0;\n\n  // This is a queue of functions that are tasks within a single test.\n  // After tests are dequeued from config.queue they are expanded into\n  // a set of tasks in this queue.\n  var taskQueue = [];\n\n  /**\n   * Advances the taskQueue to the next task. If the taskQueue is empty,\n   * process the testQueue\n   */\n  function advance() {\n  \tadvanceTaskQueue();\n\n  \tif (!taskQueue.length && !config.blocking && !config.current) {\n  \t\tadvanceTestQueue();\n  \t}\n  }\n\n  /**\n   * Advances the taskQueue with an increased depth\n   */\n  function advanceTaskQueue() {\n  \tvar start = now();\n  \tconfig.depth = (config.depth || 0) + 1;\n\n  \tprocessTaskQueue(start);\n\n  \tconfig.depth--;\n  }\n\n  /**\n   * Process the first task on the taskQueue as a promise.\n   * Each task is a function returned by https://github.com/qunitjs/qunit/blob/master/src/test.js#L381\n   */\n  function processTaskQueue(start) {\n  \tif (taskQueue.length && !config.blocking) {\n  \t\tvar elapsedTime = now() - start;\n\n  \t\tif (!defined.setTimeout || config.updateRate <= 0 || elapsedTime < config.updateRate) {\n  \t\t\tvar task = taskQueue.shift();\n  \t\t\tPromise$1.resolve(task()).then(function () {\n  \t\t\t\tif (!taskQueue.length) {\n  \t\t\t\t\tadvance();\n  \t\t\t\t} else {\n  \t\t\t\t\tprocessTaskQueue(start);\n  \t\t\t\t}\n  \t\t\t});\n  \t\t} else {\n  \t\t\tsetTimeout$1(advance);\n  \t\t}\n  \t}\n  }\n\n  /**\n   * Advance the testQueue to the next test to process. Call done() if testQueue completes.\n   */\n  function advanceTestQueue() {\n  \tif (!config.blocking && !config.queue.length && config.depth === 0) {\n  \t\tdone();\n  \t\treturn;\n  \t}\n\n  \tvar testTasks = config.queue.shift();\n  \taddToTaskQueue(testTasks());\n\n  \tif (priorityCount > 0) {\n  \t\tpriorityCount--;\n  \t}\n\n  \tadvance();\n  }\n\n  /**\n   * Enqueue the tasks for a test into the task queue.\n   * @param {Array} tasksArray\n   */\n  function addToTaskQueue(tasksArray) {\n  \ttaskQueue.push.apply(taskQueue, toConsumableArray(tasksArray));\n  }\n\n  /**\n   * Return the number of tasks remaining in the task queue to be processed.\n   * @return {Number}\n   */\n  function taskQueueLength() {\n  \treturn taskQueue.length;\n  }\n\n  /**\n   * Adds a test to the TestQueue for execution.\n   * @param {Function} testTasksFunc\n   * @param {Boolean} prioritize\n   * @param {String} seed\n   */\n  function addToTestQueue(testTasksFunc, prioritize, seed) {\n  \tif (prioritize) {\n  \t\tconfig.queue.splice(priorityCount++, 0, testTasksFunc);\n  \t} else if (seed) {\n  \t\tif (!unitSampler) {\n  \t\t\tunitSampler = unitSamplerGenerator(seed);\n  \t\t}\n\n  \t\t// Insert into a random position after all prioritized items\n  \t\tvar index = Math.floor(unitSampler() * (config.queue.length - priorityCount + 1));\n  \t\tconfig.queue.splice(priorityCount + index, 0, testTasksFunc);\n  \t} else {\n  \t\tconfig.queue.push(testTasksFunc);\n  \t}\n  }\n\n  /**\n   * Creates a seeded "sample" generator which is used for randomizing tests.\n   */\n  function unitSamplerGenerator(seed) {\n\n  \t// 32-bit xorshift, requires only a nonzero seed\n  \t// http://excamera.com/sphinx/article-xorshift.html\n  \tvar sample = parseInt(generateHash(seed), 16) || -1;\n  \treturn function () {\n  \t\tsample ^= sample << 13;\n  \t\tsample ^= sample >>> 17;\n  \t\tsample ^= sample << 5;\n\n  \t\t// ECMAScript has no unsigned number type\n  \t\tif (sample < 0) {\n  \t\t\tsample += 0x100000000;\n  \t\t}\n\n  \t\treturn sample / 0x100000000;\n  \t};\n  }\n\n  /**\n   * This function is called when the ProcessingQueue is done processing all\n   * items. It handles emitting the final run events.\n   */\n  function done() {\n  \tvar storage = config.storage;\n\n  \tProcessingQueue.finished = true;\n\n  \tvar runtime = now() - config.started;\n  \tvar passed = config.stats.all - config.stats.bad;\n\n  \tif (config.stats.all === 0) {\n\n  \t\tif (config.filter && config.filter.length) {\n  \t\t\tthrow new Error("No tests matched the filter \\"" + config.filter + "\\".");\n  \t\t}\n\n  \t\tif (config.module && config.module.length) {\n  \t\t\tthrow new Error("No tests matched the module \\"" + config.module + "\\".");\n  \t\t}\n\n  \t\tif (config.moduleId && config.moduleId.length) {\n  \t\t\tthrow new Error("No tests matched the moduleId \\"" + config.moduleId + "\\".");\n  \t\t}\n\n  \t\tif (config.testId && config.testId.length) {\n  \t\t\tthrow new Error("No tests matched the testId \\"" + config.testId + "\\".");\n  \t\t}\n\n  \t\tthrow new Error("No tests were run.");\n  \t}\n\n  \temit("runEnd", globalSuite.end(true));\n  \trunLoggingCallbacks("done", {\n  \t\tpassed: passed,\n  \t\tfailed: config.stats.bad,\n  \t\ttotal: config.stats.all,\n  \t\truntime: runtime\n  \t}).then(function () {\n\n  \t\t// Clear own storage items if all tests passed\n  \t\tif (storage && config.stats.bad === 0) {\n  \t\t\tfor (var i = storage.length - 1; i >= 0; i--) {\n  \t\t\t\tvar key = storage.key(i);\n\n  \t\t\t\tif (key.indexOf("qunit-test-") === 0) {\n  \t\t\t\t\tstorage.removeItem(key);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t});\n  }\n\n  var ProcessingQueue = {\n  \tfinished: false,\n  \tadd: addToTestQueue,\n  \tadvance: advance,\n  \ttaskCount: taskQueueLength\n  };\n\n  var TestReport = function () {\n  \tfunction TestReport(name, suite, options) {\n  \t\tclassCallCheck(this, TestReport);\n\n  \t\tthis.name = name;\n  \t\tthis.suiteName = suite.name;\n  \t\tthis.fullName = suite.fullName.concat(name);\n  \t\tthis.runtime = 0;\n  \t\tthis.assertions = [];\n\n  \t\tthis.skipped = !!options.skip;\n  \t\tthis.todo = !!options.todo;\n\n  \t\tthis.valid = options.valid;\n\n  \t\tthis._startTime = 0;\n  \t\tthis._endTime = 0;\n\n  \t\tsuite.pushTest(this);\n  \t}\n\n  \tcreateClass(TestReport, [{\n  \t\tkey: "start",\n  \t\tvalue: function start(recordTime) {\n  \t\t\tif (recordTime) {\n  \t\t\t\tthis._startTime = performanceNow();\n  \t\t\t\tif (performance) {\n  \t\t\t\t\tperformance.mark("qunit_test_start");\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn {\n  \t\t\t\tname: this.name,\n  \t\t\t\tsuiteName: this.suiteName,\n  \t\t\t\tfullName: this.fullName.slice()\n  \t\t\t};\n  \t\t}\n  \t}, {\n  \t\tkey: "end",\n  \t\tvalue: function end(recordTime) {\n  \t\t\tif (recordTime) {\n  \t\t\t\tthis._endTime = performanceNow();\n  \t\t\t\tif (performance) {\n  \t\t\t\t\tperformance.mark("qunit_test_end");\n\n  \t\t\t\t\tvar testName = this.fullName.join(" \u2013 ");\n\n  \t\t\t\t\tmeasure("QUnit Test: " + testName, "qunit_test_start", "qunit_test_end");\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn extend(this.start(), {\n  \t\t\t\truntime: this.getRuntime(),\n  \t\t\t\tstatus: this.getStatus(),\n  \t\t\t\terrors: this.getFailedAssertions(),\n  \t\t\t\tassertions: this.getAssertions()\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "pushAssertion",\n  \t\tvalue: function pushAssertion(assertion) {\n  \t\t\tthis.assertions.push(assertion);\n  \t\t}\n  \t}, {\n  \t\tkey: "getRuntime",\n  \t\tvalue: function getRuntime() {\n  \t\t\treturn this._endTime - this._startTime;\n  \t\t}\n  \t}, {\n  \t\tkey: "getStatus",\n  \t\tvalue: function getStatus() {\n  \t\t\tif (this.skipped) {\n  \t\t\t\treturn "skipped";\n  \t\t\t}\n\n  \t\t\tvar testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;\n\n  \t\t\tif (!testPassed) {\n  \t\t\t\treturn "failed";\n  \t\t\t} else if (this.todo) {\n  \t\t\t\treturn "todo";\n  \t\t\t} else {\n  \t\t\t\treturn "passed";\n  \t\t\t}\n  \t\t}\n  \t}, {\n  \t\tkey: "getFailedAssertions",\n  \t\tvalue: function getFailedAssertions() {\n  \t\t\treturn this.assertions.filter(function (assertion) {\n  \t\t\t\treturn !assertion.passed;\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "getAssertions",\n  \t\tvalue: function getAssertions() {\n  \t\t\treturn this.assertions.slice();\n  \t\t}\n\n  \t\t// Remove actual and expected values from assertions. This is to prevent\n  \t\t// leaking memory throughout a test suite.\n\n  \t}, {\n  \t\tkey: "slimAssertions",\n  \t\tvalue: function slimAssertions() {\n  \t\t\tthis.assertions = this.assertions.map(function (assertion) {\n  \t\t\t\tdelete assertion.actual;\n  \t\t\t\tdelete assertion.expected;\n  \t\t\t\treturn assertion;\n  \t\t\t});\n  \t\t}\n  \t}]);\n  \treturn TestReport;\n  }();\n\n  var focused$1 = false;\n\n  function Test(settings) {\n  \tvar i, l;\n\n  \t++Test.count;\n\n  \tthis.expected = null;\n  \tthis.assertions = [];\n  \tthis.semaphore = 0;\n  \tthis.module = config.currentModule;\n  \tthis.stack = sourceFromStacktrace(3);\n  \tthis.steps = [];\n  \tthis.timeout = undefined;\n\n  \t// If a module is skipped, all its tests and the tests of the child suites\n  \t// should be treated as skipped even if they are defined as `only` or `todo`.\n  \t// As for `todo` module, all its tests will be treated as `todo` except for\n  \t// tests defined as `skip` which will be left intact.\n  \t//\n  \t// So, if a test is defined as `todo` and is inside a skipped module, we should\n  \t// then treat that test as if was defined as `skip`.\n  \tif (this.module.skip) {\n  \t\tsettings.skip = true;\n  \t\tsettings.todo = false;\n\n  \t\t// Skipped tests should be left intact\n  \t} else if (this.module.todo && !settings.skip) {\n  \t\tsettings.todo = true;\n  \t}\n\n  \textend(this, settings);\n\n  \tthis.testReport = new TestReport(settings.testName, this.module.suiteReport, {\n  \t\ttodo: settings.todo,\n  \t\tskip: settings.skip,\n  \t\tvalid: this.valid()\n  \t});\n\n  \t// Register unique strings\n  \tfor (i = 0, l = this.module.tests; i < l.length; i++) {\n  \t\tif (this.module.tests[i].name === this.testName) {\n  \t\t\tthis.testName += " ";\n  \t\t}\n  \t}\n\n  \tthis.testId = generateHash(this.module.name, this.testName);\n\n  \tthis.module.tests.push({\n  \t\tname: this.testName,\n  \t\ttestId: this.testId,\n  \t\tskip: !!settings.skip\n  \t});\n\n  \tif (settings.skip) {\n\n  \t\t// Skipped tests will fully ignore any sent callback\n  \t\tthis.callback = function () {};\n  \t\tthis.async = false;\n  \t\tthis.expected = 0;\n  \t} else {\n  \t\tif (typeof this.callback !== "function") {\n  \t\t\tvar method = this.todo ? "todo" : "test";\n\n  \t\t\t// eslint-disable-next-line max-len\n  \t\t\tthrow new TypeError("You must provide a function as a test callback to QUnit." + method + "(\\"" + settings.testName + "\\")");\n  \t\t}\n\n  \t\tthis.assert = new Assert(this);\n  \t}\n  }\n\n  Test.count = 0;\n\n  function getNotStartedModules(startModule) {\n  \tvar module = startModule,\n  \t    modules = [];\n\n  \twhile (module && module.testsRun === 0) {\n  \t\tmodules.push(module);\n  \t\tmodule = module.parentModule;\n  \t}\n\n  \t// The above push modules from the child to the parent\n  \t// return a reversed order with the top being the top most parent module\n  \treturn modules.reverse();\n  }\n\n  Test.prototype = {\n  \tbefore: function before() {\n  \t\tvar _this = this;\n\n  \t\tvar module = this.module,\n  \t\t    notStartedModules = getNotStartedModules(module);\n\n  \t\t// ensure the callbacks are executed serially for each module\n  \t\tvar callbackPromises = notStartedModules.reduce(function (promiseChain, startModule) {\n  \t\t\treturn promiseChain.then(function () {\n  \t\t\t\tstartModule.stats = { all: 0, bad: 0, started: now() };\n  \t\t\t\temit("suiteStart", startModule.suiteReport.start(true));\n  \t\t\t\treturn runLoggingCallbacks("moduleStart", {\n  \t\t\t\t\tname: startModule.name,\n  \t\t\t\t\ttests: startModule.tests\n  \t\t\t\t});\n  \t\t\t});\n  \t\t}, Promise$1.resolve([]));\n\n  \t\treturn callbackPromises.then(function () {\n  \t\t\tconfig.current = _this;\n\n  \t\t\t_this.testEnvironment = extend({}, module.testEnvironment);\n\n  \t\t\t_this.started = now();\n  \t\t\temit("testStart", _this.testReport.start(true));\n  \t\t\treturn runLoggingCallbacks("testStart", {\n  \t\t\t\tname: _this.testName,\n  \t\t\t\tmodule: module.name,\n  \t\t\t\ttestId: _this.testId,\n  \t\t\t\tpreviousFailure: _this.previousFailure\n  \t\t\t}).then(function () {\n  \t\t\t\tif (!config.pollution) {\n  \t\t\t\t\tsaveGlobal();\n  \t\t\t\t}\n  \t\t\t});\n  \t\t});\n  \t},\n\n  \trun: function run() {\n  \t\tvar promise;\n\n  \t\tconfig.current = this;\n\n  \t\tthis.callbackStarted = now();\n\n  \t\tif (config.notrycatch) {\n  \t\t\trunTest(this);\n  \t\t\treturn;\n  \t\t}\n\n  \t\ttry {\n  \t\t\trunTest(this);\n  \t\t} catch (e) {\n  \t\t\tthis.pushFailure("Died on test #" + (this.assertions.length + 1) + " " + this.stack + ": " + (e.message || e), extractStacktrace(e, 0));\n\n  \t\t\t// Else next test will carry the responsibility\n  \t\t\tsaveGlobal();\n\n  \t\t\t// Restart the tests if they\'re blocking\n  \t\t\tif (config.blocking) {\n  \t\t\t\tinternalRecover(this);\n  \t\t\t}\n  \t\t}\n\n  \t\tfunction runTest(test) {\n  \t\t\tpromise = test.callback.call(test.testEnvironment, test.assert);\n  \t\t\ttest.resolvePromise(promise);\n\n  \t\t\t// If the test has a "lock" on it, but the timeout is 0, then we push a\n  \t\t\t// failure as the test should be synchronous.\n  \t\t\tif (test.timeout === 0 && test.semaphore !== 0) {\n  \t\t\t\tpushFailure("Test did not finish synchronously even though assert.timeout( 0 ) was used.", sourceFromStacktrace(2));\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tafter: function after() {\n  \t\tcheckPollution();\n  \t},\n\n  \tqueueHook: function queueHook(hook, hookName, hookOwner) {\n  \t\tvar _this2 = this;\n\n  \t\tvar callHook = function callHook() {\n  \t\t\tvar promise = hook.call(_this2.testEnvironment, _this2.assert);\n  \t\t\t_this2.resolvePromise(promise, hookName);\n  \t\t};\n\n  \t\tvar runHook = function runHook() {\n  \t\t\tif (hookName === "before") {\n  \t\t\t\tif (hookOwner.unskippedTestsRun !== 0) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\t_this2.preserveEnvironment = true;\n  \t\t\t}\n\n  \t\t\t// The \'after\' hook should only execute when there are not tests left and\n  \t\t\t// when the \'after\' and \'finish\' tasks are the only tasks left to process\n  \t\t\tif (hookName === "after" && hookOwner.unskippedTestsRun !== numberOfUnskippedTests(hookOwner) - 1 && (config.queue.length > 0 || ProcessingQueue.taskCount() > 2)) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tconfig.current = _this2;\n  \t\t\tif (config.notrycatch) {\n  \t\t\t\tcallHook();\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t\ttry {\n  \t\t\t\tcallHook();\n  \t\t\t} catch (error) {\n  \t\t\t\t_this2.pushFailure(hookName + " failed on " + _this2.testName + ": " + (error.message || error), extractStacktrace(error, 0));\n  \t\t\t}\n  \t\t};\n\n  \t\treturn runHook;\n  \t},\n\n\n  \t// Currently only used for module level hooks, can be used to add global level ones\n  \thooks: function hooks(handler) {\n  \t\tvar hooks = [];\n\n  \t\tfunction processHooks(test, module) {\n  \t\t\tif (module.parentModule) {\n  \t\t\t\tprocessHooks(test, module.parentModule);\n  \t\t\t}\n\n  \t\t\tif (module.hooks[handler].length) {\n  \t\t\t\tfor (var i = 0; i < module.hooks[handler].length; i++) {\n  \t\t\t\t\thooks.push(test.queueHook(module.hooks[handler][i], handler, module));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// Hooks are ignored on skipped tests\n  \t\tif (!this.skip) {\n  \t\t\tprocessHooks(this, this.module);\n  \t\t}\n\n  \t\treturn hooks;\n  \t},\n\n\n  \tfinish: function finish() {\n  \t\tconfig.current = this;\n\n  \t\t// Release the test callback to ensure that anything referenced has been\n  \t\t// released to be garbage collected.\n  \t\tthis.callback = undefined;\n\n  \t\tif (this.steps.length) {\n  \t\t\tvar stepsList = this.steps.join(", ");\n  \t\t\tthis.pushFailure("Expected assert.verifySteps() to be called before end of test " + ("after using assert.step(). Unverified steps: " + stepsList), this.stack);\n  \t\t}\n\n  \t\tif (config.requireExpects && this.expected === null) {\n  \t\t\tthis.pushFailure("Expected number of assertions to be defined, but expect() was " + "not called.", this.stack);\n  \t\t} else if (this.expected !== null && this.expected !== this.assertions.length) {\n  \t\t\tthis.pushFailure("Expected " + this.expected + " assertions, but " + this.assertions.length + " were run", this.stack);\n  \t\t} else if (this.expected === null && !this.assertions.length) {\n  \t\t\tthis.pushFailure("Expected at least one assertion, but none were run - call " + "expect(0) to accept zero assertions.", this.stack);\n  \t\t}\n\n  \t\tvar i,\n  \t\t    module = this.module,\n  \t\t    moduleName = module.name,\n  \t\t    testName = this.testName,\n  \t\t    skipped = !!this.skip,\n  \t\t    todo = !!this.todo,\n  \t\t    bad = 0,\n  \t\t    storage = config.storage;\n\n  \t\tthis.runtime = now() - this.started;\n\n  \t\tconfig.stats.all += this.assertions.length;\n  \t\tmodule.stats.all += this.assertions.length;\n\n  \t\tfor (i = 0; i < this.assertions.length; i++) {\n  \t\t\tif (!this.assertions[i].result) {\n  \t\t\t\tbad++;\n  \t\t\t\tconfig.stats.bad++;\n  \t\t\t\tmodule.stats.bad++;\n  \t\t\t}\n  \t\t}\n\n  \t\tnotifyTestsRan(module, skipped);\n\n  \t\t// Store result when possible\n  \t\tif (storage) {\n  \t\t\tif (bad) {\n  \t\t\t\tstorage.setItem("qunit-test-" + moduleName + "-" + testName, bad);\n  \t\t\t} else {\n  \t\t\t\tstorage.removeItem("qunit-test-" + moduleName + "-" + testName);\n  \t\t\t}\n  \t\t}\n\n  \t\t// After emitting the js-reporters event we cleanup the assertion data to\n  \t\t// avoid leaking it. It is not used by the legacy testDone callbacks.\n  \t\temit("testEnd", this.testReport.end(true));\n  \t\tthis.testReport.slimAssertions();\n\n  \t\treturn runLoggingCallbacks("testDone", {\n  \t\t\tname: testName,\n  \t\t\tmodule: moduleName,\n  \t\t\tskipped: skipped,\n  \t\t\ttodo: todo,\n  \t\t\tfailed: bad,\n  \t\t\tpassed: this.assertions.length - bad,\n  \t\t\ttotal: this.assertions.length,\n  \t\t\truntime: skipped ? 0 : this.runtime,\n\n  \t\t\t// HTML Reporter use\n  \t\t\tassertions: this.assertions,\n  \t\t\ttestId: this.testId,\n\n  \t\t\t// Source of Test\n  \t\t\tsource: this.stack\n  \t\t}).then(function () {\n  \t\t\tif (module.testsRun === numberOfTests(module)) {\n  \t\t\t\tvar completedModules = [module];\n\n  \t\t\t\t// Check if the parent modules, iteratively, are done. If that the case,\n  \t\t\t\t// we emit the `suiteEnd` event and trigger `moduleDone` callback.\n  \t\t\t\tvar parent = module.parentModule;\n  \t\t\t\twhile (parent && parent.testsRun === numberOfTests(parent)) {\n  \t\t\t\t\tcompletedModules.push(parent);\n  \t\t\t\t\tparent = parent.parentModule;\n  \t\t\t\t}\n\n  \t\t\t\treturn completedModules.reduce(function (promiseChain, completedModule) {\n  \t\t\t\t\treturn promiseChain.then(function () {\n  \t\t\t\t\t\treturn logSuiteEnd(completedModule);\n  \t\t\t\t\t});\n  \t\t\t\t}, Promise$1.resolve([]));\n  \t\t\t}\n  \t\t}).then(function () {\n  \t\t\tconfig.current = undefined;\n  \t\t});\n\n  \t\tfunction logSuiteEnd(module) {\n\n  \t\t\t// Reset `module.hooks` to ensure that anything referenced in these hooks\n  \t\t\t// has been released to be garbage collected.\n  \t\t\tmodule.hooks = {};\n\n  \t\t\temit("suiteEnd", module.suiteReport.end(true));\n  \t\t\treturn runLoggingCallbacks("moduleDone", {\n  \t\t\t\tname: module.name,\n  \t\t\t\ttests: module.tests,\n  \t\t\t\tfailed: module.stats.bad,\n  \t\t\t\tpassed: module.stats.all - module.stats.bad,\n  \t\t\t\ttotal: module.stats.all,\n  \t\t\t\truntime: now() - module.stats.started\n  \t\t\t});\n  \t\t}\n  \t},\n\n  \tpreserveTestEnvironment: function preserveTestEnvironment() {\n  \t\tif (this.preserveEnvironment) {\n  \t\t\tthis.module.testEnvironment = this.testEnvironment;\n  \t\t\tthis.testEnvironment = extend({}, this.module.testEnvironment);\n  \t\t}\n  \t},\n\n  \tqueue: function queue() {\n  \t\tvar test = this;\n\n  \t\tif (!this.valid()) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfunction runTest() {\n  \t\t\treturn [function () {\n  \t\t\t\treturn test.before();\n  \t\t\t}].concat(toConsumableArray(test.hooks("before")), [function () {\n  \t\t\t\ttest.preserveTestEnvironment();\n  \t\t\t}], toConsumableArray(test.hooks("beforeEach")), [function () {\n  \t\t\t\ttest.run();\n  \t\t\t}], toConsumableArray(test.hooks("afterEach").reverse()), toConsumableArray(test.hooks("after").reverse()), [function () {\n  \t\t\t\ttest.after();\n  \t\t\t}, function () {\n  \t\t\t\treturn test.finish();\n  \t\t\t}]);\n  \t\t}\n\n  \t\tvar previousFailCount = config.storage && +config.storage.getItem("qunit-test-" + this.module.name + "-" + this.testName);\n\n  \t\t// Prioritize previously failed tests, detected from storage\n  \t\tvar prioritize = config.reorder && !!previousFailCount;\n\n  \t\tthis.previousFailure = !!previousFailCount;\n\n  \t\tProcessingQueue.add(runTest, prioritize, config.seed);\n\n  \t\t// If the queue has already finished, we manually process the new test\n  \t\tif (ProcessingQueue.finished) {\n  \t\t\tProcessingQueue.advance();\n  \t\t}\n  \t},\n\n\n  \tpushResult: function pushResult(resultInfo) {\n  \t\tif (this !== config.current) {\n  \t\t\tthrow new Error("Assertion occurred after test had finished.");\n  \t\t}\n\n  \t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n  \t\tvar source,\n  \t\t    details = {\n  \t\t\tmodule: this.module.name,\n  \t\t\tname: this.testName,\n  \t\t\tresult: resultInfo.result,\n  \t\t\tmessage: resultInfo.message,\n  \t\t\tactual: resultInfo.actual,\n  \t\t\ttestId: this.testId,\n  \t\t\tnegative: resultInfo.negative || false,\n  \t\t\truntime: now() - this.started,\n  \t\t\ttodo: !!this.todo\n  \t\t};\n\n  \t\tif (hasOwn.call(resultInfo, "expected")) {\n  \t\t\tdetails.expected = resultInfo.expected;\n  \t\t}\n\n  \t\tif (!resultInfo.result) {\n  \t\t\tsource = resultInfo.source || sourceFromStacktrace();\n\n  \t\t\tif (source) {\n  \t\t\t\tdetails.source = source;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.logAssertion(details);\n\n  \t\tthis.assertions.push({\n  \t\t\tresult: !!resultInfo.result,\n  \t\t\tmessage: resultInfo.message\n  \t\t});\n  \t},\n\n  \tpushFailure: function pushFailure(message, source, actual) {\n  \t\tif (!(this instanceof Test)) {\n  \t\t\tthrow new Error("pushFailure() assertion outside test context, was " + sourceFromStacktrace(2));\n  \t\t}\n\n  \t\tthis.pushResult({\n  \t\t\tresult: false,\n  \t\t\tmessage: message || "error",\n  \t\t\tactual: actual || null,\n  \t\t\tsource: source\n  \t\t});\n  \t},\n\n  \t/**\n    * Log assertion details using both the old QUnit.log interface and\n    * QUnit.on( "assertion" ) interface.\n    *\n    * @private\n    */\n  \tlogAssertion: function logAssertion(details) {\n  \t\trunLoggingCallbacks("log", details);\n\n  \t\tvar assertion = {\n  \t\t\tpassed: details.result,\n  \t\t\tactual: details.actual,\n  \t\t\texpected: details.expected,\n  \t\t\tmessage: details.message,\n  \t\t\tstack: details.source,\n  \t\t\ttodo: details.todo\n  \t\t};\n  \t\tthis.testReport.pushAssertion(assertion);\n  \t\temit("assertion", assertion);\n  \t},\n\n\n  \tresolvePromise: function resolvePromise(promise, phase) {\n  \t\tvar then,\n  \t\t    resume,\n  \t\t    message,\n  \t\t    test = this;\n  \t\tif (promise != null) {\n  \t\t\tthen = promise.then;\n  \t\t\tif (objectType(then) === "function") {\n  \t\t\t\tresume = internalStop(test);\n  \t\t\t\tif (config.notrycatch) {\n  \t\t\t\t\tthen.call(promise, function () {\n  \t\t\t\t\t\tresume();\n  \t\t\t\t\t});\n  \t\t\t\t} else {\n  \t\t\t\t\tthen.call(promise, function () {\n  \t\t\t\t\t\tresume();\n  \t\t\t\t\t}, function (error) {\n  \t\t\t\t\t\tmessage = "Promise rejected " + (!phase ? "during" : phase.replace(/Each$/, "")) + " \\"" + test.testName + "\\": " + (error && error.message || error);\n  \t\t\t\t\t\ttest.pushFailure(message, extractStacktrace(error, 0));\n\n  \t\t\t\t\t\t// Else next test will carry the responsibility\n  \t\t\t\t\t\tsaveGlobal();\n\n  \t\t\t\t\t\t// Unblock\n  \t\t\t\t\t\tinternalRecover(test);\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tvalid: function valid() {\n  \t\tvar filter = config.filter,\n  \t\t    regexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec(filter),\n  \t\t    module = config.module && config.module.toLowerCase(),\n  \t\t    fullName = this.module.name + ": " + this.testName;\n\n  \t\tfunction moduleChainNameMatch(testModule) {\n  \t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n  \t\t\tif (testModuleName === module) {\n  \t\t\t\treturn true;\n  \t\t\t} else if (testModule.parentModule) {\n  \t\t\t\treturn moduleChainNameMatch(testModule.parentModule);\n  \t\t\t} else {\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n\n  \t\tfunction moduleChainIdMatch(testModule) {\n  \t\t\treturn inArray(testModule.moduleId, config.moduleId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule);\n  \t\t}\n\n  \t\t// Internally-generated tests are always valid\n  \t\tif (this.callback && this.callback.validTest) {\n  \t\t\treturn true;\n  \t\t}\n\n  \t\tif (config.moduleId && config.moduleId.length > 0 && !moduleChainIdMatch(this.module)) {\n\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (config.testId && config.testId.length > 0 && !inArray(this.testId, config.testId)) {\n\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (module && !moduleChainNameMatch(this.module)) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (!filter) {\n  \t\t\treturn true;\n  \t\t}\n\n  \t\treturn regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);\n  \t},\n\n  \tregexFilter: function regexFilter(exclude, pattern, flags, fullName) {\n  \t\tvar regex = new RegExp(pattern, flags);\n  \t\tvar match = regex.test(fullName);\n\n  \t\treturn match !== exclude;\n  \t},\n\n  \tstringFilter: function stringFilter(filter, fullName) {\n  \t\tfilter = filter.toLowerCase();\n  \t\tfullName = fullName.toLowerCase();\n\n  \t\tvar include = filter.charAt(0) !== "!";\n  \t\tif (!include) {\n  \t\t\tfilter = filter.slice(1);\n  \t\t}\n\n  \t\t// If the filter matches, we need to honour include\n  \t\tif (fullName.indexOf(filter) !== -1) {\n  \t\t\treturn include;\n  \t\t}\n\n  \t\t// Otherwise, do the opposite\n  \t\treturn !include;\n  \t}\n  };\n\n  function pushFailure() {\n  \tif (!config.current) {\n  \t\tthrow new Error("pushFailure() assertion outside test context, in " + sourceFromStacktrace(2));\n  \t}\n\n  \t// Gets current test obj\n  \tvar currentTest = config.current;\n\n  \treturn currentTest.pushFailure.apply(currentTest, arguments);\n  }\n\n  function saveGlobal() {\n  \tconfig.pollution = [];\n\n  \tif (config.noglobals) {\n  \t\tfor (var key in global$1) {\n  \t\t\tif (hasOwn.call(global$1, key)) {\n\n  \t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n  \t\t\t\tif (/^qunit-test-output/.test(key)) {\n  \t\t\t\t\tcontinue;\n  \t\t\t\t}\n  \t\t\t\tconfig.pollution.push(key);\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  function checkPollution() {\n  \tvar newGlobals,\n  \t    deletedGlobals,\n  \t    old = config.pollution;\n\n  \tsaveGlobal();\n\n  \tnewGlobals = diff(config.pollution, old);\n  \tif (newGlobals.length > 0) {\n  \t\tpushFailure("Introduced global variable(s): " + newGlobals.join(", "));\n  \t}\n\n  \tdeletedGlobals = diff(old, config.pollution);\n  \tif (deletedGlobals.length > 0) {\n  \t\tpushFailure("Deleted global variable(s): " + deletedGlobals.join(", "));\n  \t}\n  }\n\n  // Will be exposed as QUnit.test\n  function test(testName, callback) {\n  \tif (focused$1) {\n  \t\treturn;\n  \t}\n\n  \tvar newTest = new Test({\n  \t\ttestName: testName,\n  \t\tcallback: callback\n  \t});\n\n  \tnewTest.queue();\n  }\n\n  function todo(testName, callback) {\n  \tif (focused$1) {\n  \t\treturn;\n  \t}\n\n  \tvar newTest = new Test({\n  \t\ttestName: testName,\n  \t\tcallback: callback,\n  \t\ttodo: true\n  \t});\n\n  \tnewTest.queue();\n  }\n\n  // Will be exposed as QUnit.skip\n  function skip(testName) {\n  \tif (focused$1) {\n  \t\treturn;\n  \t}\n\n  \tvar test = new Test({\n  \t\ttestName: testName,\n  \t\tskip: true\n  \t});\n\n  \ttest.queue();\n  }\n\n  // Will be exposed as QUnit.only\n  function only(testName, callback) {\n  \tif (focused$1) {\n  \t\treturn;\n  \t}\n\n  \tconfig.queue.length = 0;\n  \tfocused$1 = true;\n\n  \tvar newTest = new Test({\n  \t\ttestName: testName,\n  \t\tcallback: callback\n  \t});\n\n  \tnewTest.queue();\n  }\n\n  // Put a hold on processing and return a function that will release it.\n  function internalStop(test) {\n  \tvar released = false;\n  \ttest.semaphore += 1;\n  \tconfig.blocking = true;\n\n  \t// Set a recovery timeout, if so configured.\n  \tif (defined.setTimeout) {\n  \t\tvar timeoutDuration = void 0;\n\n  \t\tif (typeof test.timeout === "number") {\n  \t\t\ttimeoutDuration = test.timeout;\n  \t\t} else if (typeof config.testTimeout === "number") {\n  \t\t\ttimeoutDuration = config.testTimeout;\n  \t\t}\n\n  \t\tif (typeof timeoutDuration === "number" && timeoutDuration > 0) {\n  \t\t\tclearTimeout(config.timeout);\n  \t\t\tconfig.timeout = setTimeout$1(function () {\n  \t\t\t\tpushFailure("Test took longer than " + timeoutDuration + "ms; test timed out.", sourceFromStacktrace(2));\n  \t\t\t\treleased = true;\n  \t\t\t\tinternalRecover(test);\n  \t\t\t}, timeoutDuration);\n  \t\t}\n  \t}\n\n  \treturn function resume() {\n  \t\tif (released) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\treleased = true;\n  \t\ttest.semaphore -= 1;\n  \t\tinternalStart(test);\n  \t};\n  }\n\n  // Forcefully release all processing holds.\n  function internalRecover(test) {\n  \ttest.semaphore = 0;\n  \tinternalStart(test);\n  }\n\n  // Release a processing hold, scheduling a resumption attempt if no holds remain.\n  function internalStart(test) {\n\n  \t// If semaphore is non-numeric, throw error\n  \tif (isNaN(test.semaphore)) {\n  \t\ttest.semaphore = 0;\n\n  \t\tpushFailure("Invalid value on test.semaphore", sourceFromStacktrace(2));\n  \t\treturn;\n  \t}\n\n  \t// Don\'t start until equal number of stop-calls\n  \tif (test.semaphore > 0) {\n  \t\treturn;\n  \t}\n\n  \t// Throw an Error if start is called more often than stop\n  \tif (test.semaphore < 0) {\n  \t\ttest.semaphore = 0;\n\n  \t\tpushFailure("Tried to restart test while already started (test\'s semaphore was 0 already)", sourceFromStacktrace(2));\n  \t\treturn;\n  \t}\n\n  \t// Add a slight delay to allow more assertions etc.\n  \tif (defined.setTimeout) {\n  \t\tif (config.timeout) {\n  \t\t\tclearTimeout(config.timeout);\n  \t\t}\n  \t\tconfig.timeout = setTimeout$1(function () {\n  \t\t\tif (test.semaphore > 0) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (config.timeout) {\n  \t\t\t\tclearTimeout(config.timeout);\n  \t\t\t}\n\n  \t\t\tbegin();\n  \t\t});\n  \t} else {\n  \t\tbegin();\n  \t}\n  }\n\n  function collectTests(module) {\n  \tvar tests = [].concat(module.tests);\n  \tvar modules = [].concat(toConsumableArray(module.childModules));\n\n  \t// Do a breadth-first traversal of the child modules\n  \twhile (modules.length) {\n  \t\tvar nextModule = modules.shift();\n  \t\ttests.push.apply(tests, nextModule.tests);\n  \t\tmodules.push.apply(modules, toConsumableArray(nextModule.childModules));\n  \t}\n\n  \treturn tests;\n  }\n\n  function numberOfTests(module) {\n  \treturn collectTests(module).length;\n  }\n\n  function numberOfUnskippedTests(module) {\n  \treturn collectTests(module).filter(function (test) {\n  \t\treturn !test.skip;\n  \t}).length;\n  }\n\n  function notifyTestsRan(module, skipped) {\n  \tmodule.testsRun++;\n  \tif (!skipped) {\n  \t\tmodule.unskippedTestsRun++;\n  \t}\n  \twhile (module = module.parentModule) {\n  \t\tmodule.testsRun++;\n  \t\tif (!skipped) {\n  \t\t\tmodule.unskippedTestsRun++;\n  \t\t}\n  \t}\n  }\n\n  var Assert = function () {\n  \tfunction Assert(testContext) {\n  \t\tclassCallCheck(this, Assert);\n\n  \t\tthis.test = testContext;\n  \t}\n\n  \t// Assert helpers\n\n  \tcreateClass(Assert, [{\n  \t\tkey: "timeout",\n  \t\tvalue: function timeout(duration) {\n  \t\t\tif (typeof duration !== "number") {\n  \t\t\t\tthrow new Error("You must pass a number as the duration to assert.timeout");\n  \t\t\t}\n\n  \t\t\tthis.test.timeout = duration;\n  \t\t}\n\n  \t\t// Documents a "step", which is a string value, in a test as a passing assertion\n\n  \t}, {\n  \t\tkey: "step",\n  \t\tvalue: function step(message) {\n  \t\t\tvar assertionMessage = message;\n  \t\t\tvar result = !!message;\n\n  \t\t\tthis.test.steps.push(message);\n\n  \t\t\tif (objectType(message) === "undefined" || message === "") {\n  \t\t\t\tassertionMessage = "You must provide a message to assert.step";\n  \t\t\t} else if (objectType(message) !== "string") {\n  \t\t\t\tassertionMessage = "You must provide a string value to assert.step";\n  \t\t\t\tresult = false;\n  \t\t\t}\n\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: result,\n  \t\t\t\tmessage: assertionMessage\n  \t\t\t});\n  \t\t}\n\n  \t\t// Verifies the steps in a test match a given array of string values\n\n  \t}, {\n  \t\tkey: "verifySteps",\n  \t\tvalue: function verifySteps(steps, message) {\n\n  \t\t\t// Since the steps array is just string values, we can clone with slice\n  \t\t\tvar actualStepsClone = this.test.steps.slice();\n  \t\t\tthis.deepEqual(actualStepsClone, steps, message);\n  \t\t\tthis.test.steps.length = 0;\n  \t\t}\n\n  \t\t// Specify the number of expected assertions to guarantee that failed test\n  \t\t// (no assertions are run at all) don\'t slip through.\n\n  \t}, {\n  \t\tkey: "expect",\n  \t\tvalue: function expect(asserts) {\n  \t\t\tif (arguments.length === 1) {\n  \t\t\t\tthis.test.expected = asserts;\n  \t\t\t} else {\n  \t\t\t\treturn this.test.expected;\n  \t\t\t}\n  \t\t}\n\n  \t\t// Put a hold on processing and return a function that will release it a maximum of once.\n\n  \t}, {\n  \t\tkey: "async",\n  \t\tvalue: function async(count) {\n  \t\t\tvar test$$1 = this.test;\n\n  \t\t\tvar popped = false,\n  \t\t\t    acceptCallCount = count;\n\n  \t\t\tif (typeof acceptCallCount === "undefined") {\n  \t\t\t\tacceptCallCount = 1;\n  \t\t\t}\n\n  \t\t\tvar resume = internalStop(test$$1);\n\n  \t\t\treturn function done() {\n  \t\t\t\tif (config.current !== test$$1) {\n  \t\t\t\t\tthrow Error("assert.async callback called after test finished.");\n  \t\t\t\t}\n\n  \t\t\t\tif (popped) {\n  \t\t\t\t\ttest$$1.pushFailure("Too many calls to the `assert.async` callback", sourceFromStacktrace(2));\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tacceptCallCount -= 1;\n  \t\t\t\tif (acceptCallCount > 0) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tpopped = true;\n  \t\t\t\tresume();\n  \t\t\t};\n  \t\t}\n\n  \t\t// Exports test.push() to the user API\n  \t\t// Alias of pushResult.\n\n  \t}, {\n  \t\tkey: "push",\n  \t\tvalue: function push(result, actual, expected, message, negative) {\n  \t\t\tLogger.warn("assert.push is deprecated and will be removed in QUnit 3.0." + " Please use assert.pushResult instead (https://api.qunitjs.com/assert/pushResult).");\n\n  \t\t\tvar currentAssert = this instanceof Assert ? this : config.current.assert;\n  \t\t\treturn currentAssert.pushResult({\n  \t\t\t\tresult: result,\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message,\n  \t\t\t\tnegative: negative\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "pushResult",\n  \t\tvalue: function pushResult(resultInfo) {\n\n  \t\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n  \t\t\tvar assert = this;\n  \t\t\tvar currentTest = assert instanceof Assert && assert.test || config.current;\n\n  \t\t\t// Backwards compatibility fix.\n  \t\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n  \t\t\t// Although, it\'s use is not recommended as it can leak assertions\n  \t\t\t// to other tests from async tests, because we only get a reference to the current test,\n  \t\t\t// not exactly the test where assertion were intended to be called.\n  \t\t\tif (!currentTest) {\n  \t\t\t\tthrow new Error("assertion outside test context, in " + sourceFromStacktrace(2));\n  \t\t\t}\n\n  \t\t\tif (!(assert instanceof Assert)) {\n  \t\t\t\tassert = currentTest.assert;\n  \t\t\t}\n\n  \t\t\treturn assert.test.pushResult(resultInfo);\n  \t\t}\n  \t}, {\n  \t\tkey: "ok",\n  \t\tvalue: function ok(result, message) {\n  \t\t\tif (!message) {\n  \t\t\t\tmessage = result ? "okay" : "failed, expected argument to be truthy, was: " + dump.parse(result);\n  \t\t\t}\n\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: !!result,\n  \t\t\t\tactual: result,\n  \t\t\t\texpected: true,\n  \t\t\t\tmessage: message\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "notOk",\n  \t\tvalue: function notOk(result, message) {\n  \t\t\tif (!message) {\n  \t\t\t\tmessage = !result ? "okay" : "failed, expected argument to be falsy, was: " + dump.parse(result);\n  \t\t\t}\n\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: !result,\n  \t\t\t\tactual: result,\n  \t\t\t\texpected: false,\n  \t\t\t\tmessage: message\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "equal",\n  \t\tvalue: function equal(actual, expected, message) {\n\n  \t\t\t// eslint-disable-next-line eqeqeq\n  \t\t\tvar result = expected == actual;\n\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: result,\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "notEqual",\n  \t\tvalue: function notEqual(actual, expected, message) {\n\n  \t\t\t// eslint-disable-next-line eqeqeq\n  \t\t\tvar result = expected != actual;\n\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: result,\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message,\n  \t\t\t\tnegative: true\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "propEqual",\n  \t\tvalue: function propEqual(actual, expected, message) {\n  \t\t\tactual = objectValues(actual);\n  \t\t\texpected = objectValues(expected);\n\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: equiv(actual, expected),\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "notPropEqual",\n  \t\tvalue: function notPropEqual(actual, expected, message) {\n  \t\t\tactual = objectValues(actual);\n  \t\t\texpected = objectValues(expected);\n\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: !equiv(actual, expected),\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message,\n  \t\t\t\tnegative: true\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "deepEqual",\n  \t\tvalue: function deepEqual(actual, expected, message) {\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: equiv(actual, expected),\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "notDeepEqual",\n  \t\tvalue: function notDeepEqual(actual, expected, message) {\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: !equiv(actual, expected),\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message,\n  \t\t\t\tnegative: true\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "strictEqual",\n  \t\tvalue: function strictEqual(actual, expected, message) {\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: expected === actual,\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "notStrictEqual",\n  \t\tvalue: function notStrictEqual(actual, expected, message) {\n  \t\t\tthis.pushResult({\n  \t\t\t\tresult: expected !== actual,\n  \t\t\t\tactual: actual,\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message,\n  \t\t\t\tnegative: true\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "throws",\n  \t\tvalue: function throws(block, expected, message) {\n  \t\t\tvar actual = void 0,\n  \t\t\t    result = false;\n\n  \t\t\tvar currentTest = this instanceof Assert && this.test || config.current;\n\n  \t\t\t// \'expected\' is optional unless doing string comparison\n  \t\t\tif (objectType(expected) === "string") {\n  \t\t\t\tif (message == null) {\n  \t\t\t\t\tmessage = expected;\n  \t\t\t\t\texpected = null;\n  \t\t\t\t} else {\n  \t\t\t\t\tthrow new Error("throws/raises does not accept a string value for the expected argument.\\n" + "Use a non-string object value (e.g. regExp) instead if it\'s necessary.");\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tcurrentTest.ignoreGlobalErrors = true;\n  \t\t\ttry {\n  \t\t\t\tblock.call(currentTest.testEnvironment);\n  \t\t\t} catch (e) {\n  \t\t\t\tactual = e;\n  \t\t\t}\n  \t\t\tcurrentTest.ignoreGlobalErrors = false;\n\n  \t\t\tif (actual) {\n  \t\t\t\tvar expectedType = objectType(expected);\n\n  \t\t\t\t// We don\'t want to validate thrown error\n  \t\t\t\tif (!expected) {\n  \t\t\t\t\tresult = true;\n\n  \t\t\t\t\t// Expected is a regexp\n  \t\t\t\t} else if (expectedType === "regexp") {\n  \t\t\t\t\tresult = expected.test(errorString(actual));\n\n  \t\t\t\t\t// Log the string form of the regexp\n  \t\t\t\t\texpected = String(expected);\n\n  \t\t\t\t\t// Expected is a constructor, maybe an Error constructor\n  \t\t\t\t} else if (expectedType === "function" && actual instanceof expected) {\n  \t\t\t\t\tresult = true;\n\n  \t\t\t\t\t// Expected is an Error object\n  \t\t\t\t} else if (expectedType === "object") {\n  \t\t\t\t\tresult = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n\n  \t\t\t\t\t// Log the string form of the Error object\n  \t\t\t\t\texpected = errorString(expected);\n\n  \t\t\t\t\t// Expected is a validation function which returns true if validation passed\n  \t\t\t\t} else if (expectedType === "function" && expected.call({}, actual) === true) {\n  \t\t\t\t\texpected = null;\n  \t\t\t\t\tresult = true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tcurrentTest.assert.pushResult({\n  \t\t\t\tresult: result,\n\n  \t\t\t\t// undefined if it didn\'t throw\n  \t\t\t\tactual: actual && errorString(actual),\n  \t\t\t\texpected: expected,\n  \t\t\t\tmessage: message\n  \t\t\t});\n  \t\t}\n  \t}, {\n  \t\tkey: "rejects",\n  \t\tvalue: function rejects(promise, expected, message) {\n  \t\t\tvar result = false;\n\n  \t\t\tvar currentTest = this instanceof Assert && this.test || config.current;\n\n  \t\t\t// \'expected\' is optional unless doing string comparison\n  \t\t\tif (objectType(expected) === "string") {\n  \t\t\t\tif (message === undefined) {\n  \t\t\t\t\tmessage = expected;\n  \t\t\t\t\texpected = undefined;\n  \t\t\t\t} else {\n  \t\t\t\t\tmessage = "assert.rejects does not accept a string value for the expected " + "argument.\\nUse a non-string object value (e.g. validator function) instead " + "if necessary.";\n\n  \t\t\t\t\tcurrentTest.assert.pushResult({\n  \t\t\t\t\t\tresult: false,\n  \t\t\t\t\t\tmessage: message\n  \t\t\t\t\t});\n\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tvar then = promise && promise.then;\n  \t\t\tif (objectType(then) !== "function") {\n  \t\t\t\tvar _message = "The value provided to `assert.rejects` in " + "\\"" + currentTest.testName + "\\" was not a promise.";\n\n  \t\t\t\tcurrentTest.assert.pushResult({\n  \t\t\t\t\tresult: false,\n  \t\t\t\t\tmessage: _message,\n  \t\t\t\t\tactual: promise\n  \t\t\t\t});\n\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tvar done = this.async();\n\n  \t\t\treturn then.call(promise, function handleFulfillment() {\n  \t\t\t\tvar message = "The promise returned by the `assert.rejects` callback in " + "\\"" + currentTest.testName + "\\" did not reject.";\n\n  \t\t\t\tcurrentTest.assert.pushResult({\n  \t\t\t\t\tresult: false,\n  \t\t\t\t\tmessage: message,\n  \t\t\t\t\tactual: promise\n  \t\t\t\t});\n\n  \t\t\t\tdone();\n  \t\t\t}, function handleRejection(actual) {\n  \t\t\t\tvar expectedType = objectType(expected);\n\n  \t\t\t\t// We don\'t want to validate\n  \t\t\t\tif (expected === undefined) {\n  \t\t\t\t\tresult = true;\n\n  \t\t\t\t\t// Expected is a regexp\n  \t\t\t\t} else if (expectedType === "regexp") {\n  \t\t\t\t\tresult = expected.test(errorString(actual));\n\n  \t\t\t\t\t// Log the string form of the regexp\n  \t\t\t\t\texpected = String(expected);\n\n  \t\t\t\t\t// Expected is a constructor, maybe an Error constructor\n  \t\t\t\t} else if (expectedType === "function" && actual instanceof expected) {\n  \t\t\t\t\tresult = true;\n\n  \t\t\t\t\t// Expected is an Error object\n  \t\t\t\t} else if (expectedType === "object") {\n  \t\t\t\t\tresult = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n\n  \t\t\t\t\t// Log the string form of the Error object\n  \t\t\t\t\texpected = errorString(expected);\n\n  \t\t\t\t\t// Expected is a validation function which returns true if validation passed\n  \t\t\t\t} else {\n  \t\t\t\t\tif (expectedType === "function") {\n  \t\t\t\t\t\tresult = expected.call({}, actual) === true;\n  \t\t\t\t\t\texpected = null;\n\n  \t\t\t\t\t\t// Expected is some other invalid type\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tresult = false;\n  \t\t\t\t\t\tmessage = "invalid expected value provided to `assert.rejects` " + "callback in \\"" + currentTest.testName + "\\": " + expectedType + ".";\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\tcurrentTest.assert.pushResult({\n  \t\t\t\t\tresult: result,\n\n  \t\t\t\t\t// leave rejection value of undefined as-is\n  \t\t\t\t\tactual: actual && errorString(actual),\n  \t\t\t\t\texpected: expected,\n  \t\t\t\t\tmessage: message\n  \t\t\t\t});\n\n  \t\t\t\tdone();\n  \t\t\t});\n  \t\t}\n  \t}]);\n  \treturn Assert;\n  }();\n\n  // Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n  // Known to us are: Closure Compiler, Narwhal\n  // eslint-disable-next-line dot-notation\n\n\n  Assert.prototype.raises = Assert.prototype["throws"];\n\n  /**\n   * Converts an error into a simple string for comparisons.\n   *\n   * @param {Error|Object} error\n   * @return {String}\n   */\n  function errorString(error) {\n  \tvar resultErrorString = error.toString();\n\n  \t// If the error wasn\'t a subclass of Error but something like\n  \t// an object literal with name and message properties...\n  \tif (resultErrorString.substring(0, 7) === "[object") {\n  \t\tvar name = error.name ? error.name.toString() : "Error";\n  \t\tvar message = error.message ? error.message.toString() : "";\n\n  \t\tif (name && message) {\n  \t\t\treturn name + ": " + message;\n  \t\t} else if (name) {\n  \t\t\treturn name;\n  \t\t} else if (message) {\n  \t\t\treturn message;\n  \t\t} else {\n  \t\t\treturn "Error";\n  \t\t}\n  \t} else {\n  \t\treturn resultErrorString;\n  \t}\n  }\n\n  /* global module, exports, define */\n  function exportQUnit(QUnit) {\n\n  \tif (defined.document) {\n\n  \t\t// QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.\n  \t\tif (window$1.QUnit && window$1.QUnit.version) {\n  \t\t\tthrow new Error("QUnit has already been defined.");\n  \t\t}\n\n  \t\twindow$1.QUnit = QUnit;\n  \t}\n\n  \t// For nodejs\n  \tif (typeof module !== "undefined" && module && module.exports) {\n  \t\tmodule.exports = QUnit;\n\n  \t\t// For consistency with CommonJS environments\' exports\n  \t\tmodule.exports.QUnit = QUnit;\n  \t}\n\n  \t// For CommonJS with exports, but without module.exports, like Rhino\n  \tif (typeof exports !== "undefined" && exports) {\n  \t\texports.QUnit = QUnit;\n  \t}\n\n  \tif (typeof define === "function" && define.amd) {\n  \t\tdefine(function () {\n  \t\t\treturn QUnit;\n  \t\t});\n  \t\tQUnit.config.autostart = false;\n  \t}\n\n  \t// For Web/Service Workers\n  \tif (self$1 && self$1.WorkerGlobalScope && self$1 instanceof self$1.WorkerGlobalScope) {\n  \t\tself$1.QUnit = QUnit;\n  \t}\n  }\n\n  // Handle an unhandled exception. By convention, returns true if further\n  // error handling should be suppressed and false otherwise.\n  // In this case, we will only suppress further error handling if the\n  // "ignoreGlobalErrors" configuration option is enabled.\n  function onError(error) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tif (config.current) {\n  \t\tif (config.current.ignoreGlobalErrors) {\n  \t\t\treturn true;\n  \t\t}\n  \t\tpushFailure.apply(undefined, [error.message, error.stacktrace || error.fileName + ":" + error.lineNumber].concat(args));\n  \t} else {\n  \t\ttest("global failure", extend(function () {\n  \t\t\tpushFailure.apply(undefined, [error.message, error.stacktrace || error.fileName + ":" + error.lineNumber].concat(args));\n  \t\t}, { validTest: true }));\n  \t}\n\n  \treturn false;\n  }\n\n  // Handle an unhandled rejection\n  function onUnhandledRejection(reason) {\n  \tvar resultInfo = {\n  \t\tresult: false,\n  \t\tmessage: reason.message || "error",\n  \t\tactual: reason,\n  \t\tsource: reason.stack || sourceFromStacktrace(3)\n  \t};\n\n  \tvar currentTest = config.current;\n  \tif (currentTest) {\n  \t\tcurrentTest.assert.pushResult(resultInfo);\n  \t} else {\n  \t\ttest("global failure", extend(function (assert) {\n  \t\t\tassert.pushResult(resultInfo);\n  \t\t}, { validTest: true }));\n  \t}\n  }\n\n  var QUnit = {};\n  var globalSuite = new SuiteReport();\n\n  // The initial "currentModule" represents the global (or top-level) module that\n  // is not explicitly defined by the user, therefore we add the "globalSuite" to\n  // it since each module has a suiteReport associated with it.\n  config.currentModule.suiteReport = globalSuite;\n\n  var globalStartCalled = false;\n  var runStarted = false;\n\n  // Figure out if we\'re running the tests from a server or not\n  QUnit.isLocal = !(defined.document && window$1.location.protocol !== "file:");\n\n  // Expose the current QUnit version\n  QUnit.version = "2.9.2";\n\n  extend(QUnit, {\n  \ton: on,\n\n  \tmodule: module$1,\n\n  \ttest: test,\n\n  \ttodo: todo,\n\n  \tskip: skip,\n\n  \tonly: only,\n\n  \tstart: function start(count) {\n  \t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n  \t\tif (!config.current) {\n  \t\t\tglobalStartCalled = true;\n\n  \t\t\tif (runStarted) {\n  \t\t\t\tthrow new Error("Called start() while test already started running");\n  \t\t\t} else if (globalStartAlreadyCalled || count > 1) {\n  \t\t\t\tthrow new Error("Called start() outside of a test context too many times");\n  \t\t\t} else if (config.autostart) {\n  \t\t\t\tthrow new Error("Called start() outside of a test context when " + "QUnit.config.autostart was true");\n  \t\t\t} else if (!config.pageLoaded) {\n\n  \t\t\t\t// The page isn\'t completely loaded yet, so we set autostart and then\n  \t\t\t\t// load if we\'re in Node or wait for the browser\'s load event.\n  \t\t\t\tconfig.autostart = true;\n\n  \t\t\t\t// Starts from Node even if .load was not previously called. We still return\n  \t\t\t\t// early otherwise we\'ll wind up "beginning" twice.\n  \t\t\t\tif (!defined.document) {\n  \t\t\t\t\tQUnit.load();\n  \t\t\t\t}\n\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthrow new Error("QUnit.start cannot be called inside a test context.");\n  \t\t}\n\n  \t\tscheduleBegin();\n  \t},\n\n  \tconfig: config,\n\n  \tis: is,\n\n  \tobjectType: objectType,\n\n  \textend: extend,\n\n  \tload: function load() {\n  \t\tconfig.pageLoaded = true;\n\n  \t\t// Initialize the configuration options\n  \t\textend(config, {\n  \t\t\tstats: { all: 0, bad: 0 },\n  \t\t\tstarted: 0,\n  \t\t\tupdateRate: 1000,\n  \t\t\tautostart: true,\n  \t\t\tfilter: ""\n  \t\t}, true);\n\n  \t\tif (!runStarted) {\n  \t\t\tconfig.blocking = false;\n\n  \t\t\tif (config.autostart) {\n  \t\t\t\tscheduleBegin();\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tstack: function stack(offset) {\n  \t\toffset = (offset || 0) + 2;\n  \t\treturn sourceFromStacktrace(offset);\n  \t},\n\n  \tonError: onError,\n\n  \tonUnhandledRejection: onUnhandledRejection\n  });\n\n  QUnit.pushFailure = pushFailure;\n  QUnit.assert = Assert.prototype;\n  QUnit.equiv = equiv;\n  QUnit.dump = dump;\n\n  registerLoggingCallbacks(QUnit);\n\n  function scheduleBegin() {\n\n  \trunStarted = true;\n\n  \t// Add a slight delay to allow definition of more modules and tests.\n  \tif (defined.setTimeout) {\n  \t\tsetTimeout$1(function () {\n  \t\t\tbegin();\n  \t\t});\n  \t} else {\n  \t\tbegin();\n  \t}\n  }\n\n  function unblockAndAdvanceQueue() {\n  \tconfig.blocking = false;\n  \tProcessingQueue.advance();\n  }\n\n  function begin() {\n  \tvar i,\n  \t    l,\n  \t    modulesLog = [];\n\n  \t// If the test run hasn\'t officially begun yet\n  \tif (!config.started) {\n\n  \t\t// Record the time of the test run\'s beginning\n  \t\tconfig.started = now();\n\n  \t\t// Delete the loose unnamed module if unused.\n  \t\tif (config.modules[0].name === "" && config.modules[0].tests.length === 0) {\n  \t\t\tconfig.modules.shift();\n  \t\t}\n\n  \t\t// Avoid unnecessary information by not logging modules\' test environments\n  \t\tfor (i = 0, l = config.modules.length; i < l; i++) {\n  \t\t\tmodulesLog.push({\n  \t\t\t\tname: config.modules[i].name,\n  \t\t\t\ttests: config.modules[i].tests\n  \t\t\t});\n  \t\t}\n\n  \t\t// The test run is officially beginning now\n  \t\temit("runStart", globalSuite.start(true));\n  \t\trunLoggingCallbacks("begin", {\n  \t\t\ttotalTests: Test.count,\n  \t\t\tmodules: modulesLog\n  \t\t}).then(unblockAndAdvanceQueue);\n  \t} else {\n  \t\tunblockAndAdvanceQueue();\n  \t}\n  }\n\n  exportQUnit(QUnit);\n\n  (function () {\n\n  \tif (typeof window$1 === "undefined" || typeof document$1 === "undefined") {\n  \t\treturn;\n  \t}\n\n  \tvar config = QUnit.config,\n  \t    hasOwn = Object.prototype.hasOwnProperty;\n\n  \t// Stores fixture HTML for resetting later\n  \tfunction storeFixture() {\n\n  \t\t// Avoid overwriting user-defined values\n  \t\tif (hasOwn.call(config, "fixture")) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar fixture = document$1.getElementById("qunit-fixture");\n  \t\tif (fixture) {\n  \t\t\tconfig.fixture = fixture.cloneNode(true);\n  \t\t}\n  \t}\n\n  \tQUnit.begin(storeFixture);\n\n  \t// Resets the fixture DOM element if available.\n  \tfunction resetFixture() {\n  \t\tif (config.fixture == null) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar fixture = document$1.getElementById("qunit-fixture");\n  \t\tvar resetFixtureType = _typeof(config.fixture);\n  \t\tif (resetFixtureType === "string") {\n\n  \t\t\t// support user defined values for `config.fixture`\n  \t\t\tvar newFixture = document$1.createElement("div");\n  \t\t\tnewFixture.setAttribute("id", "qunit-fixture");\n  \t\t\tnewFixture.innerHTML = config.fixture;\n  \t\t\tfixture.parentNode.replaceChild(newFixture, fixture);\n  \t\t} else {\n  \t\t\tvar clonedFixture = config.fixture.cloneNode(true);\n  \t\t\tfixture.parentNode.replaceChild(clonedFixture, fixture);\n  \t\t}\n  \t}\n\n  \tQUnit.testStart(resetFixture);\n  })();\n\n  (function () {\n\n  \t// Only interact with URLs via window.location\n  \tvar location = typeof window$1 !== "undefined" && window$1.location;\n  \tif (!location) {\n  \t\treturn;\n  \t}\n\n  \tvar urlParams = getUrlParams();\n\n  \tQUnit.urlParams = urlParams;\n\n  \t// Match module/test by inclusion in an array\n  \tQUnit.config.moduleId = [].concat(urlParams.moduleId || []);\n  \tQUnit.config.testId = [].concat(urlParams.testId || []);\n\n  \t// Exact case-insensitive match of the module name\n  \tQUnit.config.module = urlParams.module;\n\n  \t// Regular expression or case-insenstive substring match against "moduleName: testName"\n  \tQUnit.config.filter = urlParams.filter;\n\n  \t// Test order randomization\n  \tif (urlParams.seed === true) {\n\n  \t\t// Generate a random seed if the option is specified without a value\n  \t\tQUnit.config.seed = Math.random().toString(36).slice(2);\n  \t} else if (urlParams.seed) {\n  \t\tQUnit.config.seed = urlParams.seed;\n  \t}\n\n  \t// Add URL-parameter-mapped config values with UI form rendering data\n  \tQUnit.config.urlConfig.push({\n  \t\tid: "hidepassed",\n  \t\tlabel: "Hide passed tests",\n  \t\ttooltip: "Only show tests and assertions that fail. Stored as query-strings."\n  \t}, {\n  \t\tid: "noglobals",\n  \t\tlabel: "Check for Globals",\n  \t\ttooltip: "Enabling this will test if any test introduces new properties on the " + "global object (`window` in Browsers). Stored as query-strings."\n  \t}, {\n  \t\tid: "notrycatch",\n  \t\tlabel: "No try-catch",\n  \t\ttooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " + "exceptions in IE reasonable. Stored as query-strings."\n  \t});\n\n  \tQUnit.begin(function () {\n  \t\tvar i,\n  \t\t    option,\n  \t\t    urlConfig = QUnit.config.urlConfig;\n\n  \t\tfor (i = 0; i < urlConfig.length; i++) {\n\n  \t\t\t// Options can be either strings or objects with nonempty "id" properties\n  \t\t\toption = QUnit.config.urlConfig[i];\n  \t\t\tif (typeof option !== "string") {\n  \t\t\t\toption = option.id;\n  \t\t\t}\n\n  \t\t\tif (QUnit.config[option] === undefined) {\n  \t\t\t\tQUnit.config[option] = urlParams[option];\n  \t\t\t}\n  \t\t}\n  \t});\n\n  \tfunction getUrlParams() {\n  \t\tvar i, param, name, value;\n  \t\tvar urlParams = Object.create(null);\n  \t\tvar params = location.search.slice(1).split("&");\n  \t\tvar length = params.length;\n\n  \t\tfor (i = 0; i < length; i++) {\n  \t\t\tif (params[i]) {\n  \t\t\t\tparam = params[i].split("=");\n  \t\t\t\tname = decodeQueryParam(param[0]);\n\n  \t\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n  \t\t\t\tvalue = param.length === 1 || decodeQueryParam(param.slice(1).join("="));\n  \t\t\t\tif (name in urlParams) {\n  \t\t\t\t\turlParams[name] = [].concat(urlParams[name], value);\n  \t\t\t\t} else {\n  \t\t\t\t\turlParams[name] = value;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\treturn urlParams;\n  \t}\n\n  \tfunction decodeQueryParam(param) {\n  \t\treturn decodeURIComponent(param.replace(/\\+/g, "%20"));\n  \t}\n  })();\n\n  var stats = {\n  \tpassedTests: 0,\n  \tfailedTests: 0,\n  \tskippedTests: 0,\n  \ttodoTests: 0\n  };\n\n  // Escape text for attribute or text content.\n  function escapeText(s) {\n  \tif (!s) {\n  \t\treturn "";\n  \t}\n  \ts = s + "";\n\n  \t// Both single quotes and double quotes (for attributes)\n  \treturn s.replace(/[\'"<>&]/g, function (s) {\n  \t\tswitch (s) {\n  \t\t\tcase "\'":\n  \t\t\t\treturn "&#039;";\n  \t\t\tcase "\\"":\n  \t\t\t\treturn "&quot;";\n  \t\t\tcase "<":\n  \t\t\t\treturn "&lt;";\n  \t\t\tcase ">":\n  \t\t\t\treturn "&gt;";\n  \t\t\tcase "&":\n  \t\t\t\treturn "&amp;";\n  \t\t}\n  \t});\n  }\n\n  (function () {\n\n  \t// Don\'t load the HTML Reporter on non-browser environments\n  \tif (typeof window$1 === "undefined" || !window$1.document) {\n  \t\treturn;\n  \t}\n\n  \tvar config = QUnit.config,\n  \t    hiddenTests = [],\n  \t    document = window$1.document,\n  \t    collapseNext = false,\n  \t    hasOwn = Object.prototype.hasOwnProperty,\n  \t    unfilteredUrl = setUrl({ filter: undefined, module: undefined,\n  \t\tmoduleId: undefined, testId: undefined }),\n  \t    modulesList = [];\n\n  \tfunction addEvent(elem, type, fn) {\n  \t\telem.addEventListener(type, fn, false);\n  \t}\n\n  \tfunction removeEvent(elem, type, fn) {\n  \t\telem.removeEventListener(type, fn, false);\n  \t}\n\n  \tfunction addEvents(elems, type, fn) {\n  \t\tvar i = elems.length;\n  \t\twhile (i--) {\n  \t\t\taddEvent(elems[i], type, fn);\n  \t\t}\n  \t}\n\n  \tfunction hasClass(elem, name) {\n  \t\treturn (" " + elem.className + " ").indexOf(" " + name + " ") >= 0;\n  \t}\n\n  \tfunction addClass(elem, name) {\n  \t\tif (!hasClass(elem, name)) {\n  \t\t\telem.className += (elem.className ? " " : "") + name;\n  \t\t}\n  \t}\n\n  \tfunction toggleClass(elem, name, force) {\n  \t\tif (force || typeof force === "undefined" && !hasClass(elem, name)) {\n  \t\t\taddClass(elem, name);\n  \t\t} else {\n  \t\t\tremoveClass(elem, name);\n  \t\t}\n  \t}\n\n  \tfunction removeClass(elem, name) {\n  \t\tvar set = " " + elem.className + " ";\n\n  \t\t// Class name may appear multiple times\n  \t\twhile (set.indexOf(" " + name + " ") >= 0) {\n  \t\t\tset = set.replace(" " + name + " ", " ");\n  \t\t}\n\n  \t\t// Trim for prettiness\n  \t\telem.className = typeof set.trim === "function" ? set.trim() : set.replace(/^\\s+|\\s+$/g, "");\n  \t}\n\n  \tfunction id(name) {\n  \t\treturn document.getElementById && document.getElementById(name);\n  \t}\n\n  \tfunction abortTests() {\n  \t\tvar abortButton = id("qunit-abort-tests-button");\n  \t\tif (abortButton) {\n  \t\t\tabortButton.disabled = true;\n  \t\t\tabortButton.innerHTML = "Aborting...";\n  \t\t}\n  \t\tQUnit.config.queue.length = 0;\n  \t\treturn false;\n  \t}\n\n  \tfunction interceptNavigation(ev) {\n  \t\tapplyUrlParams();\n\n  \t\tif (ev && ev.preventDefault) {\n  \t\t\tev.preventDefault();\n  \t\t}\n\n  \t\treturn false;\n  \t}\n\n  \tfunction getUrlConfigHtml() {\n  \t\tvar i,\n  \t\t    j,\n  \t\t    val,\n  \t\t    escaped,\n  \t\t    escapedTooltip,\n  \t\t    selection = false,\n  \t\t    urlConfig = config.urlConfig,\n  \t\t    urlConfigHtml = "";\n\n  \t\tfor (i = 0; i < urlConfig.length; i++) {\n\n  \t\t\t// Options can be either strings or objects with nonempty "id" properties\n  \t\t\tval = config.urlConfig[i];\n  \t\t\tif (typeof val === "string") {\n  \t\t\t\tval = {\n  \t\t\t\t\tid: val,\n  \t\t\t\t\tlabel: val\n  \t\t\t\t};\n  \t\t\t}\n\n  \t\t\tescaped = escapeText(val.id);\n  \t\t\tescapedTooltip = escapeText(val.tooltip);\n\n  \t\t\tif (!val.value || typeof val.value === "string") {\n  \t\t\t\turlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped + "\' title=\'" + escapedTooltip + "\'><input id=\'qunit-urlconfig-" + escaped + "\' name=\'" + escaped + "\' type=\'checkbox\'" + (val.value ? " value=\'" + escapeText(val.value) + "\'" : "") + (config[val.id] ? " checked=\'checked\'" : "") + " title=\'" + escapedTooltip + "\' />" + escapeText(val.label) + "</label>";\n  \t\t\t} else {\n  \t\t\t\turlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped + "\' title=\'" + escapedTooltip + "\'>" + val.label + ": </label><select id=\'qunit-urlconfig-" + escaped + "\' name=\'" + escaped + "\' title=\'" + escapedTooltip + "\'><option></option>";\n\n  \t\t\t\tif (QUnit.is("array", val.value)) {\n  \t\t\t\t\tfor (j = 0; j < val.value.length; j++) {\n  \t\t\t\t\t\tescaped = escapeText(val.value[j]);\n  \t\t\t\t\t\turlConfigHtml += "<option value=\'" + escaped + "\'" + (config[val.id] === val.value[j] ? (selection = true) && " selected=\'selected\'" : "") + ">" + escaped + "</option>";\n  \t\t\t\t\t}\n  \t\t\t\t} else {\n  \t\t\t\t\tfor (j in val.value) {\n  \t\t\t\t\t\tif (hasOwn.call(val.value, j)) {\n  \t\t\t\t\t\t\turlConfigHtml += "<option value=\'" + escapeText(j) + "\'" + (config[val.id] === j ? (selection = true) && " selected=\'selected\'" : "") + ">" + escapeText(val.value[j]) + "</option>";\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tif (config[val.id] && !selection) {\n  \t\t\t\t\tescaped = escapeText(config[val.id]);\n  \t\t\t\t\turlConfigHtml += "<option value=\'" + escaped + "\' selected=\'selected\' disabled=\'disabled\'>" + escaped + "</option>";\n  \t\t\t\t}\n  \t\t\t\turlConfigHtml += "</select>";\n  \t\t\t}\n  \t\t}\n\n  \t\treturn urlConfigHtml;\n  \t}\n\n  \t// Handle "click" events on toolbar checkboxes and "change" for select menus.\n  \t// Updates the URL with the new state of `config.urlConfig` values.\n  \tfunction toolbarChanged() {\n  \t\tvar updatedUrl,\n  \t\t    value,\n  \t\t    tests,\n  \t\t    field = this,\n  \t\t    params = {};\n\n  \t\t// Detect if field is a select menu or a checkbox\n  \t\tif ("selectedIndex" in field) {\n  \t\t\tvalue = field.options[field.selectedIndex].value || undefined;\n  \t\t} else {\n  \t\t\tvalue = field.checked ? field.defaultValue || true : undefined;\n  \t\t}\n\n  \t\tparams[field.name] = value;\n  \t\tupdatedUrl = setUrl(params);\n\n  \t\t// Check if we can apply the change without a page refresh\n  \t\tif ("hidepassed" === field.name && "replaceState" in window$1.history) {\n  \t\t\tQUnit.urlParams[field.name] = value;\n  \t\t\tconfig[field.name] = value || false;\n  \t\t\ttests = id("qunit-tests");\n  \t\t\tif (tests) {\n  \t\t\t\tvar length = tests.children.length;\n  \t\t\t\tvar children = tests.children;\n\n  \t\t\t\tif (field.checked) {\n  \t\t\t\t\tfor (var i = 0; i < length; i++) {\n  \t\t\t\t\t\tvar test = children[i];\n\n  \t\t\t\t\t\tif (test && test.className.indexOf("pass") > -1) {\n  \t\t\t\t\t\t\thiddenTests.push(test);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n\n  \t\t\t\t\tvar _iteratorNormalCompletion = true;\n  \t\t\t\t\tvar _didIteratorError = false;\n  \t\t\t\t\tvar _iteratorError = undefined;\n\n  \t\t\t\t\ttry {\n  \t\t\t\t\t\tfor (var _iterator = hiddenTests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n  \t\t\t\t\t\t\tvar hiddenTest = _step.value;\n\n  \t\t\t\t\t\t\ttests.removeChild(hiddenTest);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t} catch (err) {\n  \t\t\t\t\t\t_didIteratorError = true;\n  \t\t\t\t\t\t_iteratorError = err;\n  \t\t\t\t\t} finally {\n  \t\t\t\t\t\ttry {\n  \t\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n  \t\t\t\t\t\t\t\t_iterator.return();\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t} finally {\n  \t\t\t\t\t\t\tif (_didIteratorError) {\n  \t\t\t\t\t\t\t\tthrow _iteratorError;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t} else {\n  \t\t\t\t\twhile ((test = hiddenTests.pop()) != null) {\n  \t\t\t\t\t\ttests.appendChild(test);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\twindow$1.history.replaceState(null, "", updatedUrl);\n  \t\t} else {\n  \t\t\twindow$1.location = updatedUrl;\n  \t\t}\n  \t}\n\n  \tfunction setUrl(params) {\n  \t\tvar key,\n  \t\t    arrValue,\n  \t\t    i,\n  \t\t    querystring = "?",\n  \t\t    location = window$1.location;\n\n  \t\tparams = QUnit.extend(QUnit.extend({}, QUnit.urlParams), params);\n\n  \t\tfor (key in params) {\n\n  \t\t\t// Skip inherited or undefined properties\n  \t\t\tif (hasOwn.call(params, key) && params[key] !== undefined) {\n\n  \t\t\t\t// Output a parameter for each value of this key\n  \t\t\t\t// (but usually just one)\n  \t\t\t\tarrValue = [].concat(params[key]);\n  \t\t\t\tfor (i = 0; i < arrValue.length; i++) {\n  \t\t\t\t\tquerystring += encodeURIComponent(key);\n  \t\t\t\t\tif (arrValue[i] !== true) {\n  \t\t\t\t\t\tquerystring += "=" + encodeURIComponent(arrValue[i]);\n  \t\t\t\t\t}\n  \t\t\t\t\tquerystring += "&";\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn location.protocol + "//" + location.host + location.pathname + querystring.slice(0, -1);\n  \t}\n\n  \tfunction applyUrlParams() {\n  \t\tvar i,\n  \t\t    selectedModules = [],\n  \t\t    modulesList = id("qunit-modulefilter-dropdown-list").getElementsByTagName("input"),\n  \t\t    filter = id("qunit-filter-input").value;\n\n  \t\tfor (i = 0; i < modulesList.length; i++) {\n  \t\t\tif (modulesList[i].checked) {\n  \t\t\t\tselectedModules.push(modulesList[i].value);\n  \t\t\t}\n  \t\t}\n\n  \t\twindow$1.location = setUrl({\n  \t\t\tfilter: filter === "" ? undefined : filter,\n  \t\t\tmoduleId: selectedModules.length === 0 ? undefined : selectedModules,\n\n  \t\t\t// Remove module and testId filter\n  \t\t\tmodule: undefined,\n  \t\t\ttestId: undefined\n  \t\t});\n  \t}\n\n  \tfunction toolbarUrlConfigContainer() {\n  \t\tvar urlConfigContainer = document.createElement("span");\n\n  \t\turlConfigContainer.innerHTML = getUrlConfigHtml();\n  \t\taddClass(urlConfigContainer, "qunit-url-config");\n\n  \t\taddEvents(urlConfigContainer.getElementsByTagName("input"), "change", toolbarChanged);\n  \t\taddEvents(urlConfigContainer.getElementsByTagName("select"), "change", toolbarChanged);\n\n  \t\treturn urlConfigContainer;\n  \t}\n\n  \tfunction abortTestsButton() {\n  \t\tvar button = document.createElement("button");\n  \t\tbutton.id = "qunit-abort-tests-button";\n  \t\tbutton.innerHTML = "Abort";\n  \t\taddEvent(button, "click", abortTests);\n  \t\treturn button;\n  \t}\n\n  \tfunction toolbarLooseFilter() {\n  \t\tvar filter = document.createElement("form"),\n  \t\t    label = document.createElement("label"),\n  \t\t    input = document.createElement("input"),\n  \t\t    button = document.createElement("button");\n\n  \t\taddClass(filter, "qunit-filter");\n\n  \t\tlabel.innerHTML = "Filter: ";\n\n  \t\tinput.type = "text";\n  \t\tinput.value = config.filter || "";\n  \t\tinput.name = "filter";\n  \t\tinput.id = "qunit-filter-input";\n\n  \t\tbutton.innerHTML = "Go";\n\n  \t\tlabel.appendChild(input);\n\n  \t\tfilter.appendChild(label);\n  \t\tfilter.appendChild(document.createTextNode(" "));\n  \t\tfilter.appendChild(button);\n  \t\taddEvent(filter, "submit", interceptNavigation);\n\n  \t\treturn filter;\n  \t}\n\n  \tfunction moduleListHtml() {\n  \t\tvar i,\n  \t\t    checked,\n  \t\t    html = "";\n\n  \t\tfor (i = 0; i < config.modules.length; i++) {\n  \t\t\tif (config.modules[i].name !== "") {\n  \t\t\t\tchecked = config.moduleId.indexOf(config.modules[i].moduleId) > -1;\n  \t\t\t\thtml += "<li><label class=\'clickable" + (checked ? " checked" : "") + "\'><input type=\'checkbox\' " + "value=\'" + config.modules[i].moduleId + "\'" + (checked ? " checked=\'checked\'" : "") + " />" + escapeText(config.modules[i].name) + "</label></li>";\n  \t\t\t}\n  \t\t}\n\n  \t\treturn html;\n  \t}\n\n  \tfunction toolbarModuleFilter() {\n  \t\tvar commit,\n  \t\t    reset,\n  \t\t    moduleFilter = document.createElement("form"),\n  \t\t    label = document.createElement("label"),\n  \t\t    moduleSearch = document.createElement("input"),\n  \t\t    dropDown = document.createElement("div"),\n  \t\t    actions = document.createElement("span"),\n  \t\t    applyButton = document.createElement("button"),\n  \t\t    resetButton = document.createElement("button"),\n  \t\t    allModulesLabel = document.createElement("label"),\n  \t\t    allCheckbox = document.createElement("input"),\n  \t\t    dropDownList = document.createElement("ul"),\n  \t\t    dirty = false;\n\n  \t\tmoduleSearch.id = "qunit-modulefilter-search";\n  \t\tmoduleSearch.autocomplete = "off";\n  \t\taddEvent(moduleSearch, "input", searchInput);\n  \t\taddEvent(moduleSearch, "input", searchFocus);\n  \t\taddEvent(moduleSearch, "focus", searchFocus);\n  \t\taddEvent(moduleSearch, "click", searchFocus);\n\n  \t\tlabel.id = "qunit-modulefilter-search-container";\n  \t\tlabel.innerHTML = "Module: ";\n  \t\tlabel.appendChild(moduleSearch);\n\n  \t\tapplyButton.textContent = "Apply";\n  \t\tapplyButton.style.display = "none";\n\n  \t\tresetButton.textContent = "Reset";\n  \t\tresetButton.type = "reset";\n  \t\tresetButton.style.display = "none";\n\n  \t\tallCheckbox.type = "checkbox";\n  \t\tallCheckbox.checked = config.moduleId.length === 0;\n\n  \t\tallModulesLabel.className = "clickable";\n  \t\tif (config.moduleId.length) {\n  \t\t\tallModulesLabel.className = "checked";\n  \t\t}\n  \t\tallModulesLabel.appendChild(allCheckbox);\n  \t\tallModulesLabel.appendChild(document.createTextNode("All modules"));\n\n  \t\tactions.id = "qunit-modulefilter-actions";\n  \t\tactions.appendChild(applyButton);\n  \t\tactions.appendChild(resetButton);\n  \t\tactions.appendChild(allModulesLabel);\n  \t\tcommit = actions.firstChild;\n  \t\treset = commit.nextSibling;\n  \t\taddEvent(commit, "click", applyUrlParams);\n\n  \t\tdropDownList.id = "qunit-modulefilter-dropdown-list";\n  \t\tdropDownList.innerHTML = moduleListHtml();\n\n  \t\tdropDown.id = "qunit-modulefilter-dropdown";\n  \t\tdropDown.style.display = "none";\n  \t\tdropDown.appendChild(actions);\n  \t\tdropDown.appendChild(dropDownList);\n  \t\taddEvent(dropDown, "change", selectionChange);\n  \t\tselectionChange();\n\n  \t\tmoduleFilter.id = "qunit-modulefilter";\n  \t\tmoduleFilter.appendChild(label);\n  \t\tmoduleFilter.appendChild(dropDown);\n  \t\taddEvent(moduleFilter, "submit", interceptNavigation);\n  \t\taddEvent(moduleFilter, "reset", function () {\n\n  \t\t\t// Let the reset happen, then update styles\n  \t\t\twindow$1.setTimeout(selectionChange);\n  \t\t});\n\n  \t\t// Enables show/hide for the dropdown\n  \t\tfunction searchFocus() {\n  \t\t\tif (dropDown.style.display !== "none") {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tdropDown.style.display = "block";\n  \t\t\taddEvent(document, "click", hideHandler);\n  \t\t\taddEvent(document, "keydown", hideHandler);\n\n  \t\t\t// Hide on Escape keydown or outside-container click\n  \t\t\tfunction hideHandler(e) {\n  \t\t\t\tvar inContainer = moduleFilter.contains(e.target);\n\n  \t\t\t\tif (e.keyCode === 27 || !inContainer) {\n  \t\t\t\t\tif (e.keyCode === 27 && inContainer) {\n  \t\t\t\t\t\tmoduleSearch.focus();\n  \t\t\t\t\t}\n  \t\t\t\t\tdropDown.style.display = "none";\n  \t\t\t\t\tremoveEvent(document, "click", hideHandler);\n  \t\t\t\t\tremoveEvent(document, "keydown", hideHandler);\n  \t\t\t\t\tmoduleSearch.value = "";\n  \t\t\t\t\tsearchInput();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// Processes module search box input\n  \t\tfunction searchInput() {\n  \t\t\tvar i,\n  \t\t\t    item,\n  \t\t\t    searchText = moduleSearch.value.toLowerCase(),\n  \t\t\t    listItems = dropDownList.children;\n\n  \t\t\tfor (i = 0; i < listItems.length; i++) {\n  \t\t\t\titem = listItems[i];\n  \t\t\t\tif (!searchText || item.textContent.toLowerCase().indexOf(searchText) > -1) {\n  \t\t\t\t\titem.style.display = "";\n  \t\t\t\t} else {\n  \t\t\t\t\titem.style.display = "none";\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// Processes selection changes\n  \t\tfunction selectionChange(evt) {\n  \t\t\tvar i,\n  \t\t\t    item,\n  \t\t\t    checkbox = evt && evt.target || allCheckbox,\n  \t\t\t    modulesList = dropDownList.getElementsByTagName("input"),\n  \t\t\t    selectedNames = [];\n\n  \t\t\ttoggleClass(checkbox.parentNode, "checked", checkbox.checked);\n\n  \t\t\tdirty = false;\n  \t\t\tif (checkbox.checked && checkbox !== allCheckbox) {\n  \t\t\t\tallCheckbox.checked = false;\n  \t\t\t\tremoveClass(allCheckbox.parentNode, "checked");\n  \t\t\t}\n  \t\t\tfor (i = 0; i < modulesList.length; i++) {\n  \t\t\t\titem = modulesList[i];\n  \t\t\t\tif (!evt) {\n  \t\t\t\t\ttoggleClass(item.parentNode, "checked", item.checked);\n  \t\t\t\t} else if (checkbox === allCheckbox && checkbox.checked) {\n  \t\t\t\t\titem.checked = false;\n  \t\t\t\t\tremoveClass(item.parentNode, "checked");\n  \t\t\t\t}\n  \t\t\t\tdirty = dirty || item.checked !== item.defaultChecked;\n  \t\t\t\tif (item.checked) {\n  \t\t\t\t\tselectedNames.push(item.parentNode.textContent);\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tcommit.style.display = reset.style.display = dirty ? "" : "none";\n  \t\t\tmoduleSearch.placeholder = selectedNames.join(", ") || allCheckbox.parentNode.textContent;\n  \t\t\tmoduleSearch.title = "Type to filter list. Current selection:\\n" + (selectedNames.join("\\n") || allCheckbox.parentNode.textContent);\n  \t\t}\n\n  \t\treturn moduleFilter;\n  \t}\n\n  \tfunction appendToolbar() {\n  \t\tvar toolbar = id("qunit-testrunner-toolbar");\n\n  \t\tif (toolbar) {\n  \t\t\ttoolbar.appendChild(toolbarUrlConfigContainer());\n  \t\t\ttoolbar.appendChild(toolbarModuleFilter());\n  \t\t\ttoolbar.appendChild(toolbarLooseFilter());\n  \t\t\ttoolbar.appendChild(document.createElement("div")).className = "clearfix";\n  \t\t}\n  \t}\n\n  \tfunction appendHeader() {\n  \t\tvar header = id("qunit-header");\n\n  \t\tif (header) {\n  \t\t\theader.innerHTML = "<a href=\'" + escapeText(unfilteredUrl) + "\'>" + header.innerHTML + "</a> ";\n  \t\t}\n  \t}\n\n  \tfunction appendBanner() {\n  \t\tvar banner = id("qunit-banner");\n\n  \t\tif (banner) {\n  \t\t\tbanner.className = "";\n  \t\t}\n  \t}\n\n  \tfunction appendTestResults() {\n  \t\tvar tests = id("qunit-tests"),\n  \t\t    result = id("qunit-testresult"),\n  \t\t    controls;\n\n  \t\tif (result) {\n  \t\t\tresult.parentNode.removeChild(result);\n  \t\t}\n\n  \t\tif (tests) {\n  \t\t\ttests.innerHTML = "";\n  \t\t\tresult = document.createElement("p");\n  \t\t\tresult.id = "qunit-testresult";\n  \t\t\tresult.className = "result";\n  \t\t\ttests.parentNode.insertBefore(result, tests);\n  \t\t\tresult.innerHTML = "<div id=\\"qunit-testresult-display\\">Running...<br />&#160;</div>" + "<div id=\\"qunit-testresult-controls\\"></div>" + "<div class=\\"clearfix\\"></div>";\n  \t\t\tcontrols = id("qunit-testresult-controls");\n  \t\t}\n\n  \t\tif (controls) {\n  \t\t\tcontrols.appendChild(abortTestsButton());\n  \t\t}\n  \t}\n\n  \tfunction appendFilteredTest() {\n  \t\tvar testId = QUnit.config.testId;\n  \t\tif (!testId || testId.length <= 0) {\n  \t\t\treturn "";\n  \t\t}\n  \t\treturn "<div id=\'qunit-filteredTest\'>Rerunning selected tests: " + escapeText(testId.join(", ")) + " <a id=\'qunit-clearFilter\' href=\'" + escapeText(unfilteredUrl) + "\'>Run all tests</a></div>";\n  \t}\n\n  \tfunction appendUserAgent() {\n  \t\tvar userAgent = id("qunit-userAgent");\n\n  \t\tif (userAgent) {\n  \t\t\tuserAgent.innerHTML = "";\n  \t\t\tuserAgent.appendChild(document.createTextNode("QUnit " + QUnit.version + "; " + navigator.userAgent));\n  \t\t}\n  \t}\n\n  \tfunction appendInterface() {\n  \t\tvar qunit = id("qunit");\n\n  \t\tif (qunit) {\n  \t\t\tqunit.innerHTML = "<h1 id=\'qunit-header\'>" + escapeText(document.title) + "</h1>" + "<h2 id=\'qunit-banner\'></h2>" + "<div id=\'qunit-testrunner-toolbar\'></div>" + appendFilteredTest() + "<h2 id=\'qunit-userAgent\'></h2>" + "<ol id=\'qunit-tests\'></ol>";\n  \t\t}\n\n  \t\tappendHeader();\n  \t\tappendBanner();\n  \t\tappendTestResults();\n  \t\tappendUserAgent();\n  \t\tappendToolbar();\n  \t}\n\n  \tfunction appendTest(name, testId, moduleName) {\n  \t\tvar title,\n  \t\t    rerunTrigger,\n  \t\t    testBlock,\n  \t\t    assertList,\n  \t\t    tests = id("qunit-tests");\n\n  \t\tif (!tests) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\ttitle = document.createElement("strong");\n  \t\ttitle.innerHTML = getNameHtml(name, moduleName);\n\n  \t\trerunTrigger = document.createElement("a");\n  \t\trerunTrigger.innerHTML = "Rerun";\n  \t\trerunTrigger.href = setUrl({ testId: testId });\n\n  \t\ttestBlock = document.createElement("li");\n  \t\ttestBlock.appendChild(title);\n  \t\ttestBlock.appendChild(rerunTrigger);\n  \t\ttestBlock.id = "qunit-test-output-" + testId;\n\n  \t\tassertList = document.createElement("ol");\n  \t\tassertList.className = "qunit-assert-list";\n\n  \t\ttestBlock.appendChild(assertList);\n\n  \t\ttests.appendChild(testBlock);\n  \t}\n\n  \t// HTML Reporter initialization and load\n  \tQUnit.begin(function (details) {\n  \t\tvar i, moduleObj;\n\n  \t\t// Sort modules by name for the picker\n  \t\tfor (i = 0; i < details.modules.length; i++) {\n  \t\t\tmoduleObj = details.modules[i];\n  \t\t\tif (moduleObj.name) {\n  \t\t\t\tmodulesList.push(moduleObj.name);\n  \t\t\t}\n  \t\t}\n  \t\tmodulesList.sort(function (a, b) {\n  \t\t\treturn a.localeCompare(b);\n  \t\t});\n\n  \t\t// Initialize QUnit elements\n  \t\tappendInterface();\n  \t});\n\n  \tQUnit.done(function (details) {\n  \t\tvar banner = id("qunit-banner"),\n  \t\t    tests = id("qunit-tests"),\n  \t\t    abortButton = id("qunit-abort-tests-button"),\n  \t\t    totalTests = stats.passedTests + stats.skippedTests + stats.todoTests + stats.failedTests,\n  \t\t    html = [totalTests, " tests completed in ", details.runtime, " milliseconds, with ", stats.failedTests, " failed, ", stats.skippedTests, " skipped, and ", stats.todoTests, " todo.<br />", "<span class=\'passed\'>", details.passed, "</span> assertions of <span class=\'total\'>", details.total, "</span> passed, <span class=\'failed\'>", details.failed, "</span> failed."].join(""),\n  \t\t    test,\n  \t\t    assertLi,\n  \t\t    assertList;\n\n  \t\t// Update remaing tests to aborted\n  \t\tif (abortButton && abortButton.disabled) {\n  \t\t\thtml = "Tests aborted after " + details.runtime + " milliseconds.";\n\n  \t\t\tfor (var i = 0; i < tests.children.length; i++) {\n  \t\t\t\ttest = tests.children[i];\n  \t\t\t\tif (test.className === "" || test.className === "running") {\n  \t\t\t\t\ttest.className = "aborted";\n  \t\t\t\t\tassertList = test.getElementsByTagName("ol")[0];\n  \t\t\t\t\tassertLi = document.createElement("li");\n  \t\t\t\t\tassertLi.className = "fail";\n  \t\t\t\t\tassertLi.innerHTML = "Test aborted.";\n  \t\t\t\t\tassertList.appendChild(assertLi);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tif (banner && (!abortButton || abortButton.disabled === false)) {\n  \t\t\tbanner.className = stats.failedTests ? "qunit-fail" : "qunit-pass";\n  \t\t}\n\n  \t\tif (abortButton) {\n  \t\t\tabortButton.parentNode.removeChild(abortButton);\n  \t\t}\n\n  \t\tif (tests) {\n  \t\t\tid("qunit-testresult-display").innerHTML = html;\n  \t\t}\n\n  \t\tif (config.altertitle && document.title) {\n\n  \t\t\t// Show \u2716 for good, \u2714 for bad suite result in title\n  \t\t\t// use escape sequences in case file gets loaded with non-utf-8\n  \t\t\t// charset\n  \t\t\tdocument.title = [stats.failedTests ? "\\u2716" : "\\u2714", document.title.replace(/^[\\u2714\\u2716] /i, "")].join(" ");\n  \t\t}\n\n  \t\t// Scroll back to top to show results\n  \t\tif (config.scrolltop && window$1.scrollTo) {\n  \t\t\twindow$1.scrollTo(0, 0);\n  \t\t}\n  \t});\n\n  \tfunction getNameHtml(name, module) {\n  \t\tvar nameHtml = "";\n\n  \t\tif (module) {\n  \t\t\tnameHtml = "<span class=\'module-name\'>" + escapeText(module) + "</span>: ";\n  \t\t}\n\n  \t\tnameHtml += "<span class=\'test-name\'>" + escapeText(name) + "</span>";\n\n  \t\treturn nameHtml;\n  \t}\n\n  \tQUnit.testStart(function (details) {\n  \t\tvar running, bad;\n\n  \t\tappendTest(details.name, details.testId, details.module);\n\n  \t\trunning = id("qunit-testresult-display");\n\n  \t\tif (running) {\n  \t\t\taddClass(running, "running");\n\n  \t\t\tbad = QUnit.config.reorder && details.previousFailure;\n\n  \t\t\trunning.innerHTML = [bad ? "Rerunning previously failed test: <br />" : "Running: <br />", getNameHtml(details.name, details.module)].join("");\n  \t\t}\n  \t});\n\n  \tfunction stripHtml(string) {\n\n  \t\t// Strip tags, html entity and whitespaces\n  \t\treturn string.replace(/<\\/?[^>]+(>|$)/g, "").replace(/&quot;/g, "").replace(/\\s+/g, "");\n  \t}\n\n  \tQUnit.log(function (details) {\n  \t\tvar assertList,\n  \t\t    assertLi,\n  \t\t    message,\n  \t\t    expected,\n  \t\t    actual,\n  \t\t    diff,\n  \t\t    showDiff = false,\n  \t\t    testItem = id("qunit-test-output-" + details.testId);\n\n  \t\tif (!testItem) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tmessage = escapeText(details.message) || (details.result ? "okay" : "failed");\n  \t\tmessage = "<span class=\'test-message\'>" + message + "</span>";\n  \t\tmessage += "<span class=\'runtime\'>@ " + details.runtime + " ms</span>";\n\n  \t\t// The pushFailure doesn\'t provide details.expected\n  \t\t// when it calls, it\'s implicit to also not show expected and diff stuff\n  \t\t// Also, we need to check details.expected existence, as it can exist and be undefined\n  \t\tif (!details.result && hasOwn.call(details, "expected")) {\n  \t\t\tif (details.negative) {\n  \t\t\t\texpected = "NOT " + QUnit.dump.parse(details.expected);\n  \t\t\t} else {\n  \t\t\t\texpected = QUnit.dump.parse(details.expected);\n  \t\t\t}\n\n  \t\t\tactual = QUnit.dump.parse(details.actual);\n  \t\t\tmessage += "<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>" + escapeText(expected) + "</pre></td></tr>";\n\n  \t\t\tif (actual !== expected) {\n\n  \t\t\t\tmessage += "<tr class=\'test-actual\'><th>Result: </th><td><pre>" + escapeText(actual) + "</pre></td></tr>";\n\n  \t\t\t\tif (typeof details.actual === "number" && typeof details.expected === "number") {\n  \t\t\t\t\tif (!isNaN(details.actual) && !isNaN(details.expected)) {\n  \t\t\t\t\t\tshowDiff = true;\n  \t\t\t\t\t\tdiff = details.actual - details.expected;\n  \t\t\t\t\t\tdiff = (diff > 0 ? "+" : "") + diff;\n  \t\t\t\t\t}\n  \t\t\t\t} else if (typeof details.actual !== "boolean" && typeof details.expected !== "boolean") {\n  \t\t\t\t\tdiff = QUnit.diff(expected, actual);\n\n  \t\t\t\t\t// don\'t show diff if there is zero overlap\n  \t\t\t\t\tshowDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;\n  \t\t\t\t}\n\n  \t\t\t\tif (showDiff) {\n  \t\t\t\t\tmessage += "<tr class=\'test-diff\'><th>Diff: </th><td><pre>" + diff + "</pre></td></tr>";\n  \t\t\t\t}\n  \t\t\t} else if (expected.indexOf("[object Array]") !== -1 || expected.indexOf("[object Object]") !== -1) {\n  \t\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" + "Diff suppressed as the depth of object is more than current max depth (" + QUnit.config.maxDepth + ").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to " + " run with a higher max depth or <a href=\'" + escapeText(setUrl({ maxDepth: -1 })) + "\'>" + "Rerun</a> without max depth.</p></td></tr>";\n  \t\t\t} else {\n  \t\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" + "Diff suppressed as the expected and actual results have an equivalent" + " serialization</td></tr>";\n  \t\t\t}\n\n  \t\t\tif (details.source) {\n  \t\t\t\tmessage += "<tr class=\'test-source\'><th>Source: </th><td><pre>" + escapeText(details.source) + "</pre></td></tr>";\n  \t\t\t}\n\n  \t\t\tmessage += "</table>";\n\n  \t\t\t// This occurs when pushFailure is set and we have an extracted stack trace\n  \t\t} else if (!details.result && details.source) {\n  \t\t\tmessage += "<table>" + "<tr class=\'test-source\'><th>Source: </th><td><pre>" + escapeText(details.source) + "</pre></td></tr>" + "</table>";\n  \t\t}\n\n  \t\tassertList = testItem.getElementsByTagName("ol")[0];\n\n  \t\tassertLi = document.createElement("li");\n  \t\tassertLi.className = details.result ? "pass" : "fail";\n  \t\tassertLi.innerHTML = message;\n  \t\tassertList.appendChild(assertLi);\n  \t});\n\n  \tQUnit.testDone(function (details) {\n  \t\tvar testTitle,\n  \t\t    time,\n  \t\t    testItem,\n  \t\t    assertList,\n  \t\t    status,\n  \t\t    good,\n  \t\t    bad,\n  \t\t    testCounts,\n  \t\t    skipped,\n  \t\t    sourceName,\n  \t\t    tests = id("qunit-tests");\n\n  \t\tif (!tests) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\ttestItem = id("qunit-test-output-" + details.testId);\n\n  \t\tremoveClass(testItem, "running");\n\n  \t\tif (details.failed > 0) {\n  \t\t\tstatus = "failed";\n  \t\t} else if (details.todo) {\n  \t\t\tstatus = "todo";\n  \t\t} else {\n  \t\t\tstatus = details.skipped ? "skipped" : "passed";\n  \t\t}\n\n  \t\tassertList = testItem.getElementsByTagName("ol")[0];\n\n  \t\tgood = details.passed;\n  \t\tbad = details.failed;\n\n  \t\t// This test passed if it has no unexpected failed assertions\n  \t\tvar testPassed = details.failed > 0 ? details.todo : !details.todo;\n\n  \t\tif (testPassed) {\n\n  \t\t\t// Collapse the passing tests\n  \t\t\taddClass(assertList, "qunit-collapsed");\n  \t\t} else if (config.collapse) {\n  \t\t\tif (!collapseNext) {\n\n  \t\t\t\t// Skip collapsing the first failing test\n  \t\t\t\tcollapseNext = true;\n  \t\t\t} else {\n\n  \t\t\t\t// Collapse remaining tests\n  \t\t\t\taddClass(assertList, "qunit-collapsed");\n  \t\t\t}\n  \t\t}\n\n  \t\t// The testItem.firstChild is the test name\n  \t\ttestTitle = testItem.firstChild;\n\n  \t\ttestCounts = bad ? "<b class=\'failed\'>" + bad + "</b>, " + "<b class=\'passed\'>" + good + "</b>, " : "";\n\n  \t\ttestTitle.innerHTML += " <b class=\'counts\'>(" + testCounts + details.assertions.length + ")</b>";\n\n  \t\tif (details.skipped) {\n  \t\t\tstats.skippedTests++;\n\n  \t\t\ttestItem.className = "skipped";\n  \t\t\tskipped = document.createElement("em");\n  \t\t\tskipped.className = "qunit-skipped-label";\n  \t\t\tskipped.innerHTML = "skipped";\n  \t\t\ttestItem.insertBefore(skipped, testTitle);\n  \t\t} else {\n  \t\t\taddEvent(testTitle, "click", function () {\n  \t\t\t\ttoggleClass(assertList, "qunit-collapsed");\n  \t\t\t});\n\n  \t\t\ttestItem.className = testPassed ? "pass" : "fail";\n\n  \t\t\tif (details.todo) {\n  \t\t\t\tvar todoLabel = document.createElement("em");\n  \t\t\t\ttodoLabel.className = "qunit-todo-label";\n  \t\t\t\ttodoLabel.innerHTML = "todo";\n  \t\t\t\ttestItem.className += " todo";\n  \t\t\t\ttestItem.insertBefore(todoLabel, testTitle);\n  \t\t\t}\n\n  \t\t\ttime = document.createElement("span");\n  \t\t\ttime.className = "runtime";\n  \t\t\ttime.innerHTML = details.runtime + " ms";\n  \t\t\ttestItem.insertBefore(time, assertList);\n\n  \t\t\tif (!testPassed) {\n  \t\t\t\tstats.failedTests++;\n  \t\t\t} else if (details.todo) {\n  \t\t\t\tstats.todoTests++;\n  \t\t\t} else {\n  \t\t\t\tstats.passedTests++;\n  \t\t\t}\n  \t\t}\n\n  \t\t// Show the source of the test when showing assertions\n  \t\tif (details.source) {\n  \t\t\tsourceName = document.createElement("p");\n  \t\t\tsourceName.innerHTML = "<strong>Source: </strong>" + escapeText(details.source);\n  \t\t\taddClass(sourceName, "qunit-source");\n  \t\t\tif (testPassed) {\n  \t\t\t\taddClass(sourceName, "qunit-collapsed");\n  \t\t\t}\n  \t\t\taddEvent(testTitle, "click", function () {\n  \t\t\t\ttoggleClass(sourceName, "qunit-collapsed");\n  \t\t\t});\n  \t\t\ttestItem.appendChild(sourceName);\n  \t\t}\n\n  \t\tif (config.hidepassed && status === "passed") {\n\n  \t\t\t// use removeChild instead of remove because of support\n  \t\t\thiddenTests.push(testItem);\n\n  \t\t\ttests.removeChild(testItem);\n  \t\t}\n  \t});\n\n  \t// Avoid readyState issue with phantomjs\n  \t// Ref: #818\n  \tvar notPhantom = function (p) {\n  \t\treturn !(p && p.version && p.version.major > 0);\n  \t}(window$1.phantom);\n\n  \tif (notPhantom && document.readyState === "complete") {\n  \t\tQUnit.load();\n  \t} else {\n  \t\taddEvent(window$1, "load", QUnit.load);\n  \t}\n\n  \t// Wrap window.onerror. We will call the original window.onerror to see if\n  \t// the existing handler fully handles the error; if not, we will call the\n  \t// QUnit.onError function.\n  \tvar originalWindowOnError = window$1.onerror;\n\n  \t// Cover uncaught exceptions\n  \t// Returning true will suppress the default browser handler,\n  \t// returning false will let it run.\n  \twindow$1.onerror = function (message, fileName, lineNumber, columnNumber, errorObj) {\n  \t\tvar ret = false;\n  \t\tif (originalWindowOnError) {\n  \t\t\tfor (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n  \t\t\t\targs[_key - 5] = arguments[_key];\n  \t\t\t}\n\n  \t\t\tret = originalWindowOnError.call.apply(originalWindowOnError, [this, message, fileName, lineNumber, columnNumber, errorObj].concat(args));\n  \t\t}\n\n  \t\t// Treat return value as window.onerror itself does,\n  \t\t// Only do our handling if not suppressed.\n  \t\tif (ret !== true) {\n  \t\t\tvar error = {\n  \t\t\t\tmessage: message,\n  \t\t\t\tfileName: fileName,\n  \t\t\t\tlineNumber: lineNumber\n  \t\t\t};\n\n  \t\t\t// According to\n  \t\t\t// https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,\n  \t\t\t// most modern browsers support an errorObj argument; use that to\n  \t\t\t// get a full stack trace if it\'s available.\n  \t\t\tif (errorObj && errorObj.stack) {\n  \t\t\t\terror.stacktrace = extractStacktrace(errorObj, 0);\n  \t\t\t}\n\n  \t\t\tret = QUnit.onError(error);\n  \t\t}\n\n  \t\treturn ret;\n  \t};\n\n  \t// Listen for unhandled rejections, and call QUnit.onUnhandledRejection\n  \twindow$1.addEventListener("unhandledrejection", function (event) {\n  \t\tQUnit.onUnhandledRejection(event.reason);\n  \t});\n  })();\n\n  /*\n   * This file is a modified version of google-diff-match-patch\'s JavaScript implementation\n   * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n   * modifications are licensed as more fully set forth in LICENSE.txt.\n   *\n   * The original source of google-diff-match-patch is attributable and licensed as follows:\n   *\n   * Copyright 2006 Google Inc.\n   * https://code.google.com/p/google-diff-match-patch/\n   *\n   * Licensed under the Apache License, Version 2.0 (the "License");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * https://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an "AS IS" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * More Info:\n   *  https://code.google.com/p/google-diff-match-patch/\n   *\n   * Usage: QUnit.diff(expected, actual)\n   *\n   */\n  QUnit.diff = function () {\n  \tfunction DiffMatchPatch() {}\n\n  \t//  DIFF FUNCTIONS\n\n  \t/**\n    * The data structure representing a diff is an array of tuples:\n    * [[DIFF_DELETE, \'Hello\'], [DIFF_INSERT, \'Goodbye\'], [DIFF_EQUAL, \' world.\']]\n    * which means: delete \'Hello\', add \'Goodbye\' and keep \' world.\'\n    */\n  \tvar DIFF_DELETE = -1,\n  \t    DIFF_INSERT = 1,\n  \t    DIFF_EQUAL = 0;\n\n  \t/**\n    * Find the differences between two texts.  Simplifies the problem by stripping\n    * any common prefix or suffix off the texts before diffing.\n    * @param {string} text1 Old string to be diffed.\n    * @param {string} text2 New string to be diffed.\n    * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n    *     then don\'t run a line-level diff first to identify the changed areas.\n    *     Defaults to true, which does a faster, slightly less optimal diff.\n    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n    */\n  \tDiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {\n  \t\tvar deadline, checklines, commonlength, commonprefix, commonsuffix, diffs;\n\n  \t\t// The diff must be complete in up to 1 second.\n  \t\tdeadline = new Date().getTime() + 1000;\n\n  \t\t// Check for null inputs.\n  \t\tif (text1 === null || text2 === null) {\n  \t\t\tthrow new Error("Null input. (DiffMain)");\n  \t\t}\n\n  \t\t// Check for equality (speedup).\n  \t\tif (text1 === text2) {\n  \t\t\tif (text1) {\n  \t\t\t\treturn [[DIFF_EQUAL, text1]];\n  \t\t\t}\n  \t\t\treturn [];\n  \t\t}\n\n  \t\tif (typeof optChecklines === "undefined") {\n  \t\t\toptChecklines = true;\n  \t\t}\n\n  \t\tchecklines = optChecklines;\n\n  \t\t// Trim off common prefix (speedup).\n  \t\tcommonlength = this.diffCommonPrefix(text1, text2);\n  \t\tcommonprefix = text1.substring(0, commonlength);\n  \t\ttext1 = text1.substring(commonlength);\n  \t\ttext2 = text2.substring(commonlength);\n\n  \t\t// Trim off common suffix (speedup).\n  \t\tcommonlength = this.diffCommonSuffix(text1, text2);\n  \t\tcommonsuffix = text1.substring(text1.length - commonlength);\n  \t\ttext1 = text1.substring(0, text1.length - commonlength);\n  \t\ttext2 = text2.substring(0, text2.length - commonlength);\n\n  \t\t// Compute the diff on the middle block.\n  \t\tdiffs = this.diffCompute(text1, text2, checklines, deadline);\n\n  \t\t// Restore the prefix and suffix.\n  \t\tif (commonprefix) {\n  \t\t\tdiffs.unshift([DIFF_EQUAL, commonprefix]);\n  \t\t}\n  \t\tif (commonsuffix) {\n  \t\t\tdiffs.push([DIFF_EQUAL, commonsuffix]);\n  \t\t}\n  \t\tthis.diffCleanupMerge(diffs);\n  \t\treturn diffs;\n  \t};\n\n  \t/**\n    * Reduce the number of edits by eliminating operationally trivial equalities.\n    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n    */\n  \tDiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {\n  \t\tvar changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;\n  \t\tchanges = false;\n  \t\tequalities = []; // Stack of indices where equalities are found.\n  \t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n  \t\t/** @type {?string} */\n  \t\tlastequality = null;\n\n  \t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  \t\tpointer = 0; // Index of current position.\n\n  \t\t// Is there an insertion operation before the last equality.\n  \t\tpreIns = false;\n\n  \t\t// Is there a deletion operation before the last equality.\n  \t\tpreDel = false;\n\n  \t\t// Is there an insertion operation after the last equality.\n  \t\tpostIns = false;\n\n  \t\t// Is there a deletion operation after the last equality.\n  \t\tpostDel = false;\n  \t\twhile (pointer < diffs.length) {\n\n  \t\t\t// Equality found.\n  \t\t\tif (diffs[pointer][0] === DIFF_EQUAL) {\n  \t\t\t\tif (diffs[pointer][1].length < 4 && (postIns || postDel)) {\n\n  \t\t\t\t\t// Candidate found.\n  \t\t\t\t\tequalities[equalitiesLength++] = pointer;\n  \t\t\t\t\tpreIns = postIns;\n  \t\t\t\t\tpreDel = postDel;\n  \t\t\t\t\tlastequality = diffs[pointer][1];\n  \t\t\t\t} else {\n\n  \t\t\t\t\t// Not a candidate, and can never become one.\n  \t\t\t\t\tequalitiesLength = 0;\n  \t\t\t\t\tlastequality = null;\n  \t\t\t\t}\n  \t\t\t\tpostIns = postDel = false;\n\n  \t\t\t\t// An insertion or deletion.\n  \t\t\t} else {\n\n  \t\t\t\tif (diffs[pointer][0] === DIFF_DELETE) {\n  \t\t\t\t\tpostDel = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tpostIns = true;\n  \t\t\t\t}\n\n  \t\t\t\t/*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n  \t\t\t\tif (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {\n\n  \t\t\t\t\t// Duplicate record.\n  \t\t\t\t\tdiffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n  \t\t\t\t\t// Change second copy to insert.\n  \t\t\t\t\tdiffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n  \t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n  \t\t\t\t\tlastequality = null;\n  \t\t\t\t\tif (preIns && preDel) {\n\n  \t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n  \t\t\t\t\t\tpostIns = postDel = true;\n  \t\t\t\t\t\tequalitiesLength = 0;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n  \t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n  \t\t\t\t\t\tpostIns = postDel = false;\n  \t\t\t\t\t}\n  \t\t\t\t\tchanges = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tpointer++;\n  \t\t}\n\n  \t\tif (changes) {\n  \t\t\tthis.diffCleanupMerge(diffs);\n  \t\t}\n  \t};\n\n  \t/**\n    * Convert a diff array into a pretty HTML report.\n    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n    * @param {integer} string to be beautified.\n    * @return {string} HTML representation.\n    */\n  \tDiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {\n  \t\tvar op,\n  \t\t    data,\n  \t\t    x,\n  \t\t    html = [];\n  \t\tfor (x = 0; x < diffs.length; x++) {\n  \t\t\top = diffs[x][0]; // Operation (insert, delete, equal)\n  \t\t\tdata = diffs[x][1]; // Text of change.\n  \t\t\tswitch (op) {\n  \t\t\t\tcase DIFF_INSERT:\n  \t\t\t\t\thtml[x] = "<ins>" + escapeText(data) + "</ins>";\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase DIFF_DELETE:\n  \t\t\t\t\thtml[x] = "<del>" + escapeText(data) + "</del>";\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase DIFF_EQUAL:\n  \t\t\t\t\thtml[x] = "<span>" + escapeText(data) + "</span>";\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\treturn html.join("");\n  \t};\n\n  \t/**\n    * Determine the common prefix of two strings.\n    * @param {string} text1 First string.\n    * @param {string} text2 Second string.\n    * @return {number} The number of characters common to the start of each\n    *     string.\n    */\n  \tDiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {\n  \t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n  \t\t// Quick check for common null cases.\n  \t\tif (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n  \t\t\treturn 0;\n  \t\t}\n\n  \t\t// Binary search.\n  \t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  \t\tpointermin = 0;\n  \t\tpointermax = Math.min(text1.length, text2.length);\n  \t\tpointermid = pointermax;\n  \t\tpointerstart = 0;\n  \t\twhile (pointermin < pointermid) {\n  \t\t\tif (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n  \t\t\t\tpointermin = pointermid;\n  \t\t\t\tpointerstart = pointermin;\n  \t\t\t} else {\n  \t\t\t\tpointermax = pointermid;\n  \t\t\t}\n  \t\t\tpointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  \t\t}\n  \t\treturn pointermid;\n  \t};\n\n  \t/**\n    * Determine the common suffix of two strings.\n    * @param {string} text1 First string.\n    * @param {string} text2 Second string.\n    * @return {number} The number of characters common to the end of each string.\n    */\n  \tDiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {\n  \t\tvar pointermid, pointermax, pointermin, pointerend;\n\n  \t\t// Quick check for common null cases.\n  \t\tif (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n  \t\t\treturn 0;\n  \t\t}\n\n  \t\t// Binary search.\n  \t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  \t\tpointermin = 0;\n  \t\tpointermax = Math.min(text1.length, text2.length);\n  \t\tpointermid = pointermax;\n  \t\tpointerend = 0;\n  \t\twhile (pointermin < pointermid) {\n  \t\t\tif (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n  \t\t\t\tpointermin = pointermid;\n  \t\t\t\tpointerend = pointermin;\n  \t\t\t} else {\n  \t\t\t\tpointermax = pointermid;\n  \t\t\t}\n  \t\t\tpointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  \t\t}\n  \t\treturn pointermid;\n  \t};\n\n  \t/**\n    * Find the differences between two texts.  Assumes that the texts do not\n    * have any common prefix or suffix.\n    * @param {string} text1 Old string to be diffed.\n    * @param {string} text2 New string to be diffed.\n    * @param {boolean} checklines Speedup flag.  If false, then don\'t run a\n    *     line-level diff first to identify the changed areas.\n    *     If true, then run a faster, slightly less optimal diff.\n    * @param {number} deadline Time when the diff should be complete by.\n    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n    * @private\n    */\n  \tDiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {\n  \t\tvar diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;\n\n  \t\tif (!text1) {\n\n  \t\t\t// Just add some text (speedup).\n  \t\t\treturn [[DIFF_INSERT, text2]];\n  \t\t}\n\n  \t\tif (!text2) {\n\n  \t\t\t// Just delete some text (speedup).\n  \t\t\treturn [[DIFF_DELETE, text1]];\n  \t\t}\n\n  \t\tlongtext = text1.length > text2.length ? text1 : text2;\n  \t\tshorttext = text1.length > text2.length ? text2 : text1;\n  \t\ti = longtext.indexOf(shorttext);\n  \t\tif (i !== -1) {\n\n  \t\t\t// Shorter text is inside the longer text (speedup).\n  \t\t\tdiffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n\n  \t\t\t// Swap insertions for deletions if diff is reversed.\n  \t\t\tif (text1.length > text2.length) {\n  \t\t\t\tdiffs[0][0] = diffs[2][0] = DIFF_DELETE;\n  \t\t\t}\n  \t\t\treturn diffs;\n  \t\t}\n\n  \t\tif (shorttext.length === 1) {\n\n  \t\t\t// Single character string.\n  \t\t\t// After the previous speedup, the character can\'t be an equality.\n  \t\t\treturn [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  \t\t}\n\n  \t\t// Check to see if the problem can be split in two.\n  \t\thm = this.diffHalfMatch(text1, text2);\n  \t\tif (hm) {\n\n  \t\t\t// A half-match was found, sort out the return data.\n  \t\t\ttext1A = hm[0];\n  \t\t\ttext1B = hm[1];\n  \t\t\ttext2A = hm[2];\n  \t\t\ttext2B = hm[3];\n  \t\t\tmidCommon = hm[4];\n\n  \t\t\t// Send both pairs off for separate processing.\n  \t\t\tdiffsA = this.DiffMain(text1A, text2A, checklines, deadline);\n  \t\t\tdiffsB = this.DiffMain(text1B, text2B, checklines, deadline);\n\n  \t\t\t// Merge the results.\n  \t\t\treturn diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  \t\t}\n\n  \t\tif (checklines && text1.length > 100 && text2.length > 100) {\n  \t\t\treturn this.diffLineMode(text1, text2, deadline);\n  \t\t}\n\n  \t\treturn this.diffBisect(text1, text2, deadline);\n  \t};\n\n  \t/**\n    * Do the two texts share a substring which is at least half the length of the\n    * longer text?\n    * This speedup can produce non-minimal diffs.\n    * @param {string} text1 First string.\n    * @param {string} text2 Second string.\n    * @return {Array.<string>} Five element Array, containing the prefix of\n    *     text1, the suffix of text1, the prefix of text2, the suffix of\n    *     text2 and the common middle.  Or null if there was no match.\n    * @private\n    */\n  \tDiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {\n  \t\tvar longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;\n\n  \t\tlongtext = text1.length > text2.length ? text1 : text2;\n  \t\tshorttext = text1.length > text2.length ? text2 : text1;\n  \t\tif (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n  \t\t\treturn null; // Pointless.\n  \t\t}\n  \t\tdmp = this; // \'this\' becomes \'window\' in a closure.\n\n  \t\t/**\n     * Does a substring of shorttext exist within longtext such that the substring\n     * is at least half the length of longtext?\n     * Closure, but does not reference any external variables.\n     * @param {string} longtext Longer string.\n     * @param {string} shorttext Shorter string.\n     * @param {number} i Start index of quarter length substring within longtext.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n     *     of shorttext and the common middle.  Or null if there was no match.\n     * @private\n     */\n  \t\tfunction diffHalfMatchI(longtext, shorttext, i) {\n  \t\t\tvar seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n  \t\t\t// Start with a 1/4 length substring at position i as a seed.\n  \t\t\tseed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n  \t\t\tj = -1;\n  \t\t\tbestCommon = "";\n  \t\t\twhile ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n  \t\t\t\tprefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\n  \t\t\t\tsuffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n  \t\t\t\tif (bestCommon.length < suffixLength + prefixLength) {\n  \t\t\t\t\tbestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n  \t\t\t\t\tbestLongtextA = longtext.substring(0, i - suffixLength);\n  \t\t\t\t\tbestLongtextB = longtext.substring(i + prefixLength);\n  \t\t\t\t\tbestShorttextA = shorttext.substring(0, j - suffixLength);\n  \t\t\t\t\tbestShorttextB = shorttext.substring(j + prefixLength);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tif (bestCommon.length * 2 >= longtext.length) {\n  \t\t\t\treturn [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];\n  \t\t\t} else {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n\n  \t\t// First check if the second quarter is the seed for a half-match.\n  \t\thm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));\n\n  \t\t// Check again based on the third quarter.\n  \t\thm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n  \t\tif (!hm1 && !hm2) {\n  \t\t\treturn null;\n  \t\t} else if (!hm2) {\n  \t\t\thm = hm1;\n  \t\t} else if (!hm1) {\n  \t\t\thm = hm2;\n  \t\t} else {\n\n  \t\t\t// Both matched.  Select the longest.\n  \t\t\thm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  \t\t}\n\n  \t\t// A half-match was found, sort out the return data.\n  \t\tif (text1.length > text2.length) {\n  \t\t\ttext1A = hm[0];\n  \t\t\ttext1B = hm[1];\n  \t\t\ttext2A = hm[2];\n  \t\t\ttext2B = hm[3];\n  \t\t} else {\n  \t\t\ttext2A = hm[0];\n  \t\t\ttext2B = hm[1];\n  \t\t\ttext1A = hm[2];\n  \t\t\ttext1B = hm[3];\n  \t\t}\n  \t\tmidCommon = hm[4];\n  \t\treturn [text1A, text1B, text2A, text2B, midCommon];\n  \t};\n\n  \t/**\n    * Do a quick line-level diff on both strings, then rediff the parts for\n    * greater accuracy.\n    * This speedup can produce non-minimal diffs.\n    * @param {string} text1 Old string to be diffed.\n    * @param {string} text2 New string to be diffed.\n    * @param {number} deadline Time when the diff should be complete by.\n    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n    * @private\n    */\n  \tDiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {\n  \t\tvar a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;\n\n  \t\t// Scan the text on a line-by-line basis first.\n  \t\ta = this.diffLinesToChars(text1, text2);\n  \t\ttext1 = a.chars1;\n  \t\ttext2 = a.chars2;\n  \t\tlinearray = a.lineArray;\n\n  \t\tdiffs = this.DiffMain(text1, text2, false, deadline);\n\n  \t\t// Convert the diff back to original text.\n  \t\tthis.diffCharsToLines(diffs, linearray);\n\n  \t\t// Eliminate freak matches (e.g. blank lines)\n  \t\tthis.diffCleanupSemantic(diffs);\n\n  \t\t// Rediff any replacement blocks, this time character-by-character.\n  \t\t// Add a dummy entry at the end.\n  \t\tdiffs.push([DIFF_EQUAL, ""]);\n  \t\tpointer = 0;\n  \t\tcountDelete = 0;\n  \t\tcountInsert = 0;\n  \t\ttextDelete = "";\n  \t\ttextInsert = "";\n  \t\twhile (pointer < diffs.length) {\n  \t\t\tswitch (diffs[pointer][0]) {\n  \t\t\t\tcase DIFF_INSERT:\n  \t\t\t\t\tcountInsert++;\n  \t\t\t\t\ttextInsert += diffs[pointer][1];\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase DIFF_DELETE:\n  \t\t\t\t\tcountDelete++;\n  \t\t\t\t\ttextDelete += diffs[pointer][1];\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase DIFF_EQUAL:\n\n  \t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n  \t\t\t\t\tif (countDelete >= 1 && countInsert >= 1) {\n\n  \t\t\t\t\t\t// Delete the offending records and add the merged ones.\n  \t\t\t\t\t\tdiffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n  \t\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n  \t\t\t\t\t\ta = this.DiffMain(textDelete, textInsert, false, deadline);\n  \t\t\t\t\t\tfor (j = a.length - 1; j >= 0; j--) {\n  \t\t\t\t\t\t\tdiffs.splice(pointer, 0, a[j]);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\tpointer = pointer + a.length;\n  \t\t\t\t\t}\n  \t\t\t\t\tcountInsert = 0;\n  \t\t\t\t\tcountDelete = 0;\n  \t\t\t\t\ttextDelete = "";\n  \t\t\t\t\ttextInsert = "";\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tpointer++;\n  \t\t}\n  \t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n  \t\treturn diffs;\n  \t};\n\n  \t/**\n    * Find the \'middle snake\' of a diff, split the problem in two\n    * and return the recursively constructed diff.\n    * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n    * @param {string} text1 Old string to be diffed.\n    * @param {string} text2 New string to be diffed.\n    * @param {number} deadline Time at which to bail if not yet complete.\n    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n    * @private\n    */\n  \tDiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {\n  \t\tvar text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n  \t\t// Cache the text lengths to prevent multiple calls.\n  \t\ttext1Length = text1.length;\n  \t\ttext2Length = text2.length;\n  \t\tmaxD = Math.ceil((text1Length + text2Length) / 2);\n  \t\tvOffset = maxD;\n  \t\tvLength = 2 * maxD;\n  \t\tv1 = new Array(vLength);\n  \t\tv2 = new Array(vLength);\n\n  \t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  \t\t// integers and undefined.\n  \t\tfor (x = 0; x < vLength; x++) {\n  \t\t\tv1[x] = -1;\n  \t\t\tv2[x] = -1;\n  \t\t}\n  \t\tv1[vOffset + 1] = 0;\n  \t\tv2[vOffset + 1] = 0;\n  \t\tdelta = text1Length - text2Length;\n\n  \t\t// If the total number of characters is odd, then the front path will collide\n  \t\t// with the reverse path.\n  \t\tfront = delta % 2 !== 0;\n\n  \t\t// Offsets for start and end of k loop.\n  \t\t// Prevents mapping of space beyond the grid.\n  \t\tk1start = 0;\n  \t\tk1end = 0;\n  \t\tk2start = 0;\n  \t\tk2end = 0;\n  \t\tfor (d = 0; d < maxD; d++) {\n\n  \t\t\t// Bail out if deadline is reached.\n  \t\t\tif (new Date().getTime() > deadline) {\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\t// Walk the front path one step.\n  \t\t\tfor (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n  \t\t\t\tk1Offset = vOffset + k1;\n  \t\t\t\tif (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {\n  \t\t\t\t\tx1 = v1[k1Offset + 1];\n  \t\t\t\t} else {\n  \t\t\t\t\tx1 = v1[k1Offset - 1] + 1;\n  \t\t\t\t}\n  \t\t\t\ty1 = x1 - k1;\n  \t\t\t\twhile (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n  \t\t\t\t\tx1++;\n  \t\t\t\t\ty1++;\n  \t\t\t\t}\n  \t\t\t\tv1[k1Offset] = x1;\n  \t\t\t\tif (x1 > text1Length) {\n\n  \t\t\t\t\t// Ran off the right of the graph.\n  \t\t\t\t\tk1end += 2;\n  \t\t\t\t} else if (y1 > text2Length) {\n\n  \t\t\t\t\t// Ran off the bottom of the graph.\n  \t\t\t\t\tk1start += 2;\n  \t\t\t\t} else if (front) {\n  \t\t\t\t\tk2Offset = vOffset + delta - k1;\n  \t\t\t\t\tif (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n\n  \t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n  \t\t\t\t\t\tx2 = text1Length - v2[k2Offset];\n  \t\t\t\t\t\tif (x1 >= x2) {\n\n  \t\t\t\t\t\t\t// Overlap detected.\n  \t\t\t\t\t\t\treturn this.diffBisectSplit(text1, text2, x1, y1, deadline);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// Walk the reverse path one step.\n  \t\t\tfor (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n  \t\t\t\tk2Offset = vOffset + k2;\n  \t\t\t\tif (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {\n  \t\t\t\t\tx2 = v2[k2Offset + 1];\n  \t\t\t\t} else {\n  \t\t\t\t\tx2 = v2[k2Offset - 1] + 1;\n  \t\t\t\t}\n  \t\t\t\ty2 = x2 - k2;\n  \t\t\t\twhile (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {\n  \t\t\t\t\tx2++;\n  \t\t\t\t\ty2++;\n  \t\t\t\t}\n  \t\t\t\tv2[k2Offset] = x2;\n  \t\t\t\tif (x2 > text1Length) {\n\n  \t\t\t\t\t// Ran off the left of the graph.\n  \t\t\t\t\tk2end += 2;\n  \t\t\t\t} else if (y2 > text2Length) {\n\n  \t\t\t\t\t// Ran off the top of the graph.\n  \t\t\t\t\tk2start += 2;\n  \t\t\t\t} else if (!front) {\n  \t\t\t\t\tk1Offset = vOffset + delta - k2;\n  \t\t\t\t\tif (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n  \t\t\t\t\t\tx1 = v1[k1Offset];\n  \t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n  \t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n  \t\t\t\t\t\tx2 = text1Length - x2;\n  \t\t\t\t\t\tif (x1 >= x2) {\n\n  \t\t\t\t\t\t\t// Overlap detected.\n  \t\t\t\t\t\t\treturn this.diffBisectSplit(text1, text2, x1, y1, deadline);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// Diff took too long and hit the deadline or\n  \t\t// number of diffs equals number of characters, no commonality at all.\n  \t\treturn [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  \t};\n\n  \t/**\n    * Given the location of the \'middle snake\', split the diff in two parts\n    * and recurse.\n    * @param {string} text1 Old string to be diffed.\n    * @param {string} text2 New string to be diffed.\n    * @param {number} x Index of split point in text1.\n    * @param {number} y Index of split point in text2.\n    * @param {number} deadline Time at which to bail if not yet complete.\n    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n    * @private\n    */\n  \tDiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {\n  \t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n  \t\ttext1a = text1.substring(0, x);\n  \t\ttext2a = text2.substring(0, y);\n  \t\ttext1b = text1.substring(x);\n  \t\ttext2b = text2.substring(y);\n\n  \t\t// Compute both diffs serially.\n  \t\tdiffs = this.DiffMain(text1a, text2a, false, deadline);\n  \t\tdiffsb = this.DiffMain(text1b, text2b, false, deadline);\n\n  \t\treturn diffs.concat(diffsb);\n  \t};\n\n  \t/**\n    * Reduce the number of edits by eliminating semantically trivial equalities.\n    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n    */\n  \tDiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {\n  \t\tvar changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n  \t\tchanges = false;\n  \t\tequalities = []; // Stack of indices where equalities are found.\n  \t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n  \t\t/** @type {?string} */\n  \t\tlastequality = null;\n\n  \t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  \t\tpointer = 0; // Index of current position.\n\n  \t\t// Number of characters that changed prior to the equality.\n  \t\tlengthInsertions1 = 0;\n  \t\tlengthDeletions1 = 0;\n\n  \t\t// Number of characters that changed after the equality.\n  \t\tlengthInsertions2 = 0;\n  \t\tlengthDeletions2 = 0;\n  \t\twhile (pointer < diffs.length) {\n  \t\t\tif (diffs[pointer][0] === DIFF_EQUAL) {\n  \t\t\t\t// Equality found.\n  \t\t\t\tequalities[equalitiesLength++] = pointer;\n  \t\t\t\tlengthInsertions1 = lengthInsertions2;\n  \t\t\t\tlengthDeletions1 = lengthDeletions2;\n  \t\t\t\tlengthInsertions2 = 0;\n  \t\t\t\tlengthDeletions2 = 0;\n  \t\t\t\tlastequality = diffs[pointer][1];\n  \t\t\t} else {\n  \t\t\t\t// An insertion or deletion.\n  \t\t\t\tif (diffs[pointer][0] === DIFF_INSERT) {\n  \t\t\t\t\tlengthInsertions2 += diffs[pointer][1].length;\n  \t\t\t\t} else {\n  \t\t\t\t\tlengthDeletions2 += diffs[pointer][1].length;\n  \t\t\t\t}\n\n  \t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n  \t\t\t\t// sides of it.\n  \t\t\t\tif (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {\n\n  \t\t\t\t\t// Duplicate record.\n  \t\t\t\t\tdiffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n  \t\t\t\t\t// Change second copy to insert.\n  \t\t\t\t\tdiffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\n  \t\t\t\t\t// Throw away the equality we just deleted.\n  \t\t\t\t\tequalitiesLength--;\n\n  \t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n  \t\t\t\t\tequalitiesLength--;\n  \t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\n  \t\t\t\t\t// Reset the counters.\n  \t\t\t\t\tlengthInsertions1 = 0;\n  \t\t\t\t\tlengthDeletions1 = 0;\n  \t\t\t\t\tlengthInsertions2 = 0;\n  \t\t\t\t\tlengthDeletions2 = 0;\n  \t\t\t\t\tlastequality = null;\n  \t\t\t\t\tchanges = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tpointer++;\n  \t\t}\n\n  \t\t// Normalize the diff.\n  \t\tif (changes) {\n  \t\t\tthis.diffCleanupMerge(diffs);\n  \t\t}\n\n  \t\t// Find any overlaps between deletions and insertions.\n  \t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  \t\t//   -> <del>abc</del>xxx<ins>def</ins>\n  \t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n  \t\t//   -> <ins>def</ins>xxx<del>abc</del>\n  \t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n  \t\tpointer = 1;\n  \t\twhile (pointer < diffs.length) {\n  \t\t\tif (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n  \t\t\t\tdeletion = diffs[pointer - 1][1];\n  \t\t\t\tinsertion = diffs[pointer][1];\n  \t\t\t\toverlapLength1 = this.diffCommonOverlap(deletion, insertion);\n  \t\t\t\toverlapLength2 = this.diffCommonOverlap(insertion, deletion);\n  \t\t\t\tif (overlapLength1 >= overlapLength2) {\n  \t\t\t\t\tif (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n\n  \t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n  \t\t\t\t\t\tdiffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);\n  \t\t\t\t\t\tdiffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n  \t\t\t\t\t\tdiffs[pointer + 1][1] = insertion.substring(overlapLength1);\n  \t\t\t\t\t\tpointer++;\n  \t\t\t\t\t}\n  \t\t\t\t} else {\n  \t\t\t\t\tif (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n\n  \t\t\t\t\t\t// Reverse overlap found.\n  \t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n  \t\t\t\t\t\tdiffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);\n\n  \t\t\t\t\t\tdiffs[pointer - 1][0] = DIFF_INSERT;\n  \t\t\t\t\t\tdiffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n  \t\t\t\t\t\tdiffs[pointer + 1][0] = DIFF_DELETE;\n  \t\t\t\t\t\tdiffs[pointer + 1][1] = deletion.substring(overlapLength2);\n  \t\t\t\t\t\tpointer++;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t\tpointer++;\n  \t\t\t}\n  \t\t\tpointer++;\n  \t\t}\n  \t};\n\n  \t/**\n    * Determine if the suffix of one string is the prefix of another.\n    * @param {string} text1 First string.\n    * @param {string} text2 Second string.\n    * @return {number} The number of characters common to the end of the first\n    *     string and the start of the second string.\n    * @private\n    */\n  \tDiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {\n  \t\tvar text1Length, text2Length, textLength, best, length, pattern, found;\n\n  \t\t// Cache the text lengths to prevent multiple calls.\n  \t\ttext1Length = text1.length;\n  \t\ttext2Length = text2.length;\n\n  \t\t// Eliminate the null case.\n  \t\tif (text1Length === 0 || text2Length === 0) {\n  \t\t\treturn 0;\n  \t\t}\n\n  \t\t// Truncate the longer string.\n  \t\tif (text1Length > text2Length) {\n  \t\t\ttext1 = text1.substring(text1Length - text2Length);\n  \t\t} else if (text1Length < text2Length) {\n  \t\t\ttext2 = text2.substring(0, text1Length);\n  \t\t}\n  \t\ttextLength = Math.min(text1Length, text2Length);\n\n  \t\t// Quick check for the worst case.\n  \t\tif (text1 === text2) {\n  \t\t\treturn textLength;\n  \t\t}\n\n  \t\t// Start by looking for a single character match\n  \t\t// and increase length until no match is found.\n  \t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  \t\tbest = 0;\n  \t\tlength = 1;\n  \t\twhile (true) {\n  \t\t\tpattern = text1.substring(textLength - length);\n  \t\t\tfound = text2.indexOf(pattern);\n  \t\t\tif (found === -1) {\n  \t\t\t\treturn best;\n  \t\t\t}\n  \t\t\tlength += found;\n  \t\t\tif (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n  \t\t\t\tbest = length;\n  \t\t\t\tlength++;\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \t/**\n    * Split two texts into an array of strings.  Reduce the texts to a string of\n    * hashes where each Unicode character represents one line.\n    * @param {string} text1 First string.\n    * @param {string} text2 Second string.\n    * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n    *     An object containing the encoded text1, the encoded text2 and\n    *     the array of unique strings.\n    *     The zeroth element of the array of unique strings is intentionally blank.\n    * @private\n    */\n  \tDiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {\n  \t\tvar lineArray, lineHash, chars1, chars2;\n  \t\tlineArray = []; // E.g. lineArray[4] === \'Hello\\n\'\n  \t\tlineHash = {}; // E.g. lineHash[\'Hello\\n\'] === 4\n\n  \t\t// \'\\x00\' is a valid character, but various debuggers don\'t like it.\n  \t\t// So we\'ll insert a junk entry to avoid generating a null character.\n  \t\tlineArray[0] = "";\n\n  \t\t/**\n     * Split a text into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * Modifies linearray and linehash through being a closure.\n     * @param {string} text String to encode.\n     * @return {string} Encoded string.\n     * @private\n     */\n  \t\tfunction diffLinesToCharsMunge(text) {\n  \t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n  \t\t\tchars = "";\n\n  \t\t\t// Walk the text, pulling out a substring for each line.\n  \t\t\t// text.split(\'\\n\') would would temporarily double our memory footprint.\n  \t\t\t// Modifying text would create many large strings to garbage collect.\n  \t\t\tlineStart = 0;\n  \t\t\tlineEnd = -1;\n\n  \t\t\t// Keeping our own length variable is faster than looking it up.\n  \t\t\tlineArrayLength = lineArray.length;\n  \t\t\twhile (lineEnd < text.length - 1) {\n  \t\t\t\tlineEnd = text.indexOf("\\n", lineStart);\n  \t\t\t\tif (lineEnd === -1) {\n  \t\t\t\t\tlineEnd = text.length - 1;\n  \t\t\t\t}\n  \t\t\t\tline = text.substring(lineStart, lineEnd + 1);\n  \t\t\t\tlineStart = lineEnd + 1;\n\n  \t\t\t\tvar lineHashExists = lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined;\n\n  \t\t\t\tif (lineHashExists) {\n  \t\t\t\t\tchars += String.fromCharCode(lineHash[line]);\n  \t\t\t\t} else {\n  \t\t\t\t\tchars += String.fromCharCode(lineArrayLength);\n  \t\t\t\t\tlineHash[line] = lineArrayLength;\n  \t\t\t\t\tlineArray[lineArrayLength++] = line;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\treturn chars;\n  \t\t}\n\n  \t\tchars1 = diffLinesToCharsMunge(text1);\n  \t\tchars2 = diffLinesToCharsMunge(text2);\n  \t\treturn {\n  \t\t\tchars1: chars1,\n  \t\t\tchars2: chars2,\n  \t\t\tlineArray: lineArray\n  \t\t};\n  \t};\n\n  \t/**\n    * Rehydrate the text in a diff from a string of line hashes to real lines of\n    * text.\n    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n    * @param {!Array.<string>} lineArray Array of unique strings.\n    * @private\n    */\n  \tDiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {\n  \t\tvar x, chars, text, y;\n  \t\tfor (x = 0; x < diffs.length; x++) {\n  \t\t\tchars = diffs[x][1];\n  \t\t\ttext = [];\n  \t\t\tfor (y = 0; y < chars.length; y++) {\n  \t\t\t\ttext[y] = lineArray[chars.charCodeAt(y)];\n  \t\t\t}\n  \t\t\tdiffs[x][1] = text.join("");\n  \t\t}\n  \t};\n\n  \t/**\n    * Reorder and merge like edit sections.  Merge equalities.\n    * Any edit section can move as long as it doesn\'t cross an equality.\n    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n    */\n  \tDiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {\n  \t\tvar pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;\n  \t\tdiffs.push([DIFF_EQUAL, ""]); // Add a dummy entry at the end.\n  \t\tpointer = 0;\n  \t\tcountDelete = 0;\n  \t\tcountInsert = 0;\n  \t\ttextDelete = "";\n  \t\ttextInsert = "";\n\n  \t\twhile (pointer < diffs.length) {\n  \t\t\tswitch (diffs[pointer][0]) {\n  \t\t\t\tcase DIFF_INSERT:\n  \t\t\t\t\tcountInsert++;\n  \t\t\t\t\ttextInsert += diffs[pointer][1];\n  \t\t\t\t\tpointer++;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase DIFF_DELETE:\n  \t\t\t\t\tcountDelete++;\n  \t\t\t\t\ttextDelete += diffs[pointer][1];\n  \t\t\t\t\tpointer++;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase DIFF_EQUAL:\n\n  \t\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n  \t\t\t\t\tif (countDelete + countInsert > 1) {\n  \t\t\t\t\t\tif (countDelete !== 0 && countInsert !== 0) {\n\n  \t\t\t\t\t\t\t// Factor out any common prefixes.\n  \t\t\t\t\t\t\tcommonlength = this.diffCommonPrefix(textInsert, textDelete);\n  \t\t\t\t\t\t\tif (commonlength !== 0) {\n  \t\t\t\t\t\t\t\tif (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {\n  \t\t\t\t\t\t\t\t\tdiffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);\n  \t\t\t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t\t\tdiffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);\n  \t\t\t\t\t\t\t\t\tpointer++;\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t\ttextInsert = textInsert.substring(commonlength);\n  \t\t\t\t\t\t\t\ttextDelete = textDelete.substring(commonlength);\n  \t\t\t\t\t\t\t}\n\n  \t\t\t\t\t\t\t// Factor out any common suffixies.\n  \t\t\t\t\t\t\tcommonlength = this.diffCommonSuffix(textInsert, textDelete);\n  \t\t\t\t\t\t\tif (commonlength !== 0) {\n  \t\t\t\t\t\t\t\tdiffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];\n  \t\t\t\t\t\t\t\ttextInsert = textInsert.substring(0, textInsert.length - commonlength);\n  \t\t\t\t\t\t\t\ttextDelete = textDelete.substring(0, textDelete.length - commonlength);\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// Delete the offending records and add the merged ones.\n  \t\t\t\t\t\tif (countDelete === 0) {\n  \t\t\t\t\t\t\tdiffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);\n  \t\t\t\t\t\t} else if (countInsert === 0) {\n  \t\t\t\t\t\t\tdiffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tdiffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\tpointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;\n  \t\t\t\t\t} else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n\n  \t\t\t\t\t\t// Merge this equality with the previous one.\n  \t\t\t\t\t\tdiffs[pointer - 1][1] += diffs[pointer][1];\n  \t\t\t\t\t\tdiffs.splice(pointer, 1);\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tpointer++;\n  \t\t\t\t\t}\n  \t\t\t\t\tcountInsert = 0;\n  \t\t\t\t\tcountDelete = 0;\n  \t\t\t\t\ttextDelete = "";\n  \t\t\t\t\ttextInsert = "";\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tif (diffs[diffs.length - 1][1] === "") {\n  \t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n  \t\t}\n\n  \t\t// Second pass: look for single edits surrounded on both sides by equalities\n  \t\t// which can be shifted sideways to eliminate an equality.\n  \t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  \t\tchanges = false;\n  \t\tpointer = 1;\n\n  \t\t// Intentionally ignore the first and last element (don\'t need checking).\n  \t\twhile (pointer < diffs.length - 1) {\n  \t\t\tif (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n\n  \t\t\t\tdiffPointer = diffs[pointer][1];\n  \t\t\t\tposition = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);\n\n  \t\t\t\t// This is a single edit surrounded by equalities.\n  \t\t\t\tif (position === diffs[pointer - 1][1]) {\n\n  \t\t\t\t\t// Shift the edit over the previous equality.\n  \t\t\t\t\tdiffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n  \t\t\t\t\tdiffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n  \t\t\t\t\tdiffs.splice(pointer - 1, 1);\n  \t\t\t\t\tchanges = true;\n  \t\t\t\t} else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n\n  \t\t\t\t\t// Shift the edit over the next equality.\n  \t\t\t\t\tdiffs[pointer - 1][1] += diffs[pointer + 1][1];\n  \t\t\t\t\tdiffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n  \t\t\t\t\tdiffs.splice(pointer + 1, 1);\n  \t\t\t\t\tchanges = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tpointer++;\n  \t\t}\n\n  \t\t// If shifts were made, the diff needs reordering and another shift sweep.\n  \t\tif (changes) {\n  \t\t\tthis.diffCleanupMerge(diffs);\n  \t\t}\n  \t};\n\n  \treturn function (o, n) {\n  \t\tvar diff, output, text;\n  \t\tdiff = new DiffMatchPatch();\n  \t\toutput = diff.DiffMain(o, n);\n  \t\tdiff.diffCleanupEfficiency(output);\n  \t\ttext = diff.diffPrettyHtml(output);\n\n  \t\treturn text;\n  \t};\n  }();\n\n}((function() { return this; }())));\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, 'QUnit');
});
/*steal-css@1.3.2#css*/
define('steal-css@1.3.2#css', [
    'require',
    'exports',
    'module',
    '@loader',
    '@steal'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var loader = require('@loader');
        var steal = require('@steal');
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var importRegEx = /@import [^uU]['"]?([^'"\)]*)['"]?/g;
        var resourceRegEx = /url\(['"]?([^'"\)]*)['"]?\)/g;
        var waitSeconds = loader.cssOptions && loader.cssOptions.timeout ? parseInt(loader.cssOptions.timeout, 10) : 60;
        var onloadCss = function (link, cb) {
            var styleSheets = getDocument().styleSheets, i = styleSheets.length;
            while (i--) {
                if (styleSheets[i].href === link.href) {
                    return cb();
                }
            }
            setTimeout(function () {
                onloadCss(link, cb);
            });
        };
        function isIE9() {
            var doc = getDocument();
            return doc && !!Function('/*@cc_on return (/^9/.test(@_jscript_version) && /MSIE 9.0(?!.*IEMobile)/i.test(navigator.userAgent)); @*/')();
        }
        function getDocument() {
            if (typeof doneSsr !== 'undefined' && doneSsr.globalDocument) {
                return doneSsr.globalDocument;
            }
            if (typeof document !== 'undefined') {
                return document;
            }
            throw new Error('Unable to load CSS in an environment without a document.');
        }
        function getHead() {
            var doc = getDocument();
            var head = doc.head || doc.getElementsByTagName('head')[0];
            if (!head) {
                var docEl = doc.documentElement || doc;
                head = doc.createElement('head');
                docEl.insertBefore(head, docEl.firstChild);
            }
            return head;
        }
        function CSSModule(load, loader) {
            if (typeof load === 'object') {
                this.load = load;
                this.loader = loader;
                this.address = this.load.address;
                this.source = this.load.source;
            } else {
                this.address = load;
                this.source = loader;
            }
        }
        CSSModule.cssCount = 0;
        CSSModule.ie9MaxStyleSheets = 31;
        CSSModule.currentStyleSheet = null;
        CSSModule.prototype = {
            injectLink: function () {
                if (this._loaded) {
                    return this._loaded;
                }
                if (this.linkExists()) {
                    this._loaded = Promise.resolve('');
                    return this._loaded;
                }
                var doc = getDocument();
                var link = this.link = doc.createElement('link');
                link.type = 'text/css';
                link.rel = 'stylesheet';
                link.href = this.address;
                this._loaded = new Promise(function (resolve, reject) {
                    var timeout = setTimeout(function () {
                        reject('Unable to load CSS');
                    }, waitSeconds * 1000);
                    var loadCB = function (event) {
                        clearTimeout(timeout);
                        link.removeEventListener('load', loadCB);
                        link.removeEventListener('error', loadCB);
                        if (event && event.type === 'error') {
                            reject('Unable to load CSS');
                        } else {
                            resolve('');
                        }
                    };
                    if ('isApplicationInstalled' in navigator || !link.addEventListener) {
                        onloadCss(link, loadCB);
                    } else if (navigator.noUI) {
                        loadCB();
                    } else {
                        link.addEventListener('load', loadCB);
                        link.addEventListener('error', loadCB);
                    }
                    getHead().appendChild(link);
                });
                return this._loaded;
            },
            injectStyle: function () {
                var doc = getDocument();
                var head = getHead();
                var style = this.style = doc.createElement('style');
                style.type = 'text/css';
                if (style.sheet) {
                    style.sheet.cssText = this.source;
                } else if (style.styleSheet) {
                    style.styleSheet.cssText = this.source;
                } else {
                    style.appendChild(doc.createTextNode(this.source));
                }
                head.appendChild(style);
            },
            ie9StyleSheetLimitHack: function () {
                var doc = getDocument();
                if (!CSSModule.cssCount) {
                    CSSModule.currentStyleSheet = doc.createStyleSheet();
                }
                CSSModule.cssCount += 1;
                CSSModule.currentStyleSheet.cssText += this.source;
                if (CSSModule.cssCount === CSSModule.ie9MaxStyleSheets) {
                    CSSModule.cssCount = 0;
                }
            },
            updateURLs: function () {
                var rawSource = this.source, address = this.address;
                this.source = rawSource.replace(importRegEx, function (whole, part) {
                    if (isNode) {
                        return '@import url(' + part + ')';
                    } else {
                        return '@import url(' + steal.joinURIs(address, part) + ')';
                    }
                });
                if (!loader.isEnv('build')) {
                    this.source = this.source + '/*# sourceURL=' + address + ' */';
                    this.source = this.source.replace(resourceRegEx, function (whole, part) {
                        return 'url(' + steal.joinURIs(address, part) + ')';
                    });
                }
                return this.source;
            },
            getExistingNode: function () {
                var doc = getDocument();
                var selector = '[href=\'' + this.address + '\']';
                return doc.querySelector && doc.querySelector(selector);
            },
            linkExists: function () {
                var styleSheets = getDocument().styleSheets;
                for (var i = 0; i < styleSheets.length; ++i) {
                    if (this.address === styleSheets[i].href) {
                        return true;
                    }
                }
                return false;
            },
            setupLiveReload: function (loader, name) {
                var head = getHead();
                var css = this;
                if (loader.liveReloadInstalled) {
                    var cssReload = loader['import']('live-reload', { name: module.id });
                    Promise.resolve(cssReload).then(function (reload) {
                        loader['import'](name).then(function () {
                            reload.once('!dispose/' + name, function () {
                                css.style.__isDirty = true;
                                reload.once('!cycleComplete', function () {
                                    head.removeChild(css.style);
                                });
                            });
                        });
                    });
                }
            }
        };
        if (loader.isEnv('production')) {
            exports.fetch = function (load) {
                var css = new CSSModule(load.address);
                return css.injectLink();
            };
        } else {
            exports.instantiate = function (load) {
                var loader = this;
                var css = new CSSModule(load.address, load.source);
                load.source = css.updateURLs();
                load.metadata.deps = [];
                load.metadata.format = 'css';
                load.metadata.execute = function () {
                    if (getDocument()) {
                        if (isIE9()) {
                            css.ie9StyleSheetLimitHack();
                        } else {
                            css.injectStyle();
                        }
                        css.setupLiveReload(loader, load.name);
                    }
                    return loader.newModule({ source: css.source });
                };
            };
        }
        exports.CSSModule = CSSModule;
        exports.getDocument = getDocument;
        exports.getHead = getHead;
        exports.locateScheme = true;
        exports.buildType = 'css';
        exports.includeInBuild = true;
        exports.pluginBuilder = 'steal-css/slim';
    }(function () {
        return this;
    }(), require, exports, module));
});
/*steal-qunit@2.0.0#steal-qunit*/
'format amd';
define('steal-qunit@2.0.0#steal-qunit', [
    '@loader',
    'qunit/qunit/qunit',
    'qunit/qunit/qunit.css'
], function (loader, QUnit) {
    if (loader.has('live-reload')) {
        setupLiveReload();
    }
    setupSauceLabsReporting();
    function setupLiveReload() {
        QUnit.done(updateResults);
        function findModule(name) {
            var mods = QUnit.config.modules;
            return mods.filter(function (mod) {
                return mod.name === name;
            }).pop();
        }
        function findTestResult(mod, id) {
            var tests = mod.tests || [];
            return tests.filter(function (test) {
                return test.testId === id;
            })[0];
        }
        function updateResults() {
            var tests = document.getElementById('qunit-tests').children;
            var node, id, test, moduleName, mod;
            passed = true, removedNodes = [];
            for (var i = 0, len = tests.length; i < len; i++) {
                node = tests.item(i);
                id = node.id.split('-').pop();
                moduleName = node.querySelector('.module-name').textContent;
                mod = findModule(moduleName);
                test = findTestResult(mod, id);
                if (test) {
                    removeAllButLast(node, 'runtime');
                    if (node.hasAttribute && node.hasAttribute('class') && node.className !== 'pass') {
                        passed = false;
                        break;
                    }
                } else {
                    removedNodes.push(node);
                }
            }
            removedNodes.forEach(function (node) {
                node.parentNode.removeChild(node);
            });
            document.getElementById('qunit-banner').className = passed ? 'qunit-pass' : 'qunit-fail';
        }
        function removeAllButLast(parent, className) {
            var node, nodes = [];
            var children = parent.children;
            for (var i = 0, len = children.length; i < len; i++) {
                node = children.item(i);
                if (node.className === className)
                    nodes.push(node);
            }
            while (nodes.length > 1) {
                node = nodes.shift();
                parent.removeChild(node);
            }
        }
    }
    function setupSauceLabsReporting() {
        var log = [];
        QUnit.done(function (test_results) {
            var tests = [];
            for (var i = 0, len = log.length; i < len; i++) {
                var details = log[i];
                tests.push({
                    name: details.name,
                    result: details.result,
                    expected: details.expected,
                    actual: details.actual,
                    source: details.source
                });
            }
            test_results.tests = tests;
            window.global_test_results = test_results;
        });
        QUnit.testStart(function (testDetails) {
            QUnit.log(function (details) {
                if (!details.result) {
                    details.name = testDetails.name;
                    log.push(details);
                }
            });
        });
    }
    QUnit.config.autostart = false;
    steal.done().then(function () {
        if (window.Testee && window.Testee.init) {
            Testee.init();
        }
        var qunitVersion = Number(QUnit.version.split('.')[0]);
        if (qunitVersion < 2) {
            QUnit.load();
        }
    });
    return QUnit;
});
/*can-namespace@1.0.0#can-namespace*/
define('can-namespace@1.0.0#can-namespace', function (require, exports, module) {
    module.exports = {};
});
/*can-symbol@1.6.5#can-symbol*/
define('can-symbol@1.6.5#can-symbol', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var supportsNativeSymbols = function () {
            var symbolExists = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
            if (!symbolExists) {
                return false;
            }
            var symbol = Symbol('a symbol for testing symbols');
            return typeof symbol === 'symbol';
        }();
        var CanSymbol;
        if (supportsNativeSymbols) {
            CanSymbol = Symbol;
        } else {
            var symbolNum = 0;
            CanSymbol = function CanSymbolPolyfill(description) {
                var symbolValue = '@@symbol' + symbolNum++ + description;
                var symbol = {};
                Object.defineProperties(symbol, {
                    toString: {
                        value: function () {
                            return symbolValue;
                        }
                    }
                });
                return symbol;
            };
            var descriptionToSymbol = {};
            var symbolToDescription = {};
            CanSymbol.for = function (description) {
                var symbol = descriptionToSymbol[description];
                if (!symbol) {
                    symbol = descriptionToSymbol[description] = CanSymbol(description);
                    symbolToDescription[symbol] = description;
                }
                return symbol;
            };
            CanSymbol.keyFor = function (symbol) {
                return symbolToDescription[symbol];
            };
            [
                'hasInstance',
                'isConcatSpreadable',
                'iterator',
                'match',
                'prototype',
                'replace',
                'search',
                'species',
                'split',
                'toPrimitive',
                'toStringTag',
                'unscopables'
            ].forEach(function (name) {
                CanSymbol[name] = CanSymbol('Symbol.' + name);
            });
        }
        [
            'isMapLike',
            'isListLike',
            'isValueLike',
            'isFunctionLike',
            'getOwnKeys',
            'getOwnKeyDescriptor',
            'proto',
            'getOwnEnumerableKeys',
            'hasOwnKey',
            'hasKey',
            'size',
            'getName',
            'getIdentity',
            'assignDeep',
            'updateDeep',
            'getValue',
            'setValue',
            'getKeyValue',
            'setKeyValue',
            'updateValues',
            'addValue',
            'removeValues',
            'apply',
            'new',
            'onValue',
            'offValue',
            'onKeyValue',
            'offKeyValue',
            'getKeyDependencies',
            'getValueDependencies',
            'keyHasDependencies',
            'valueHasDependencies',
            'onKeys',
            'onKeysAdded',
            'onKeysRemoved',
            'onPatches'
        ].forEach(function (name) {
            CanSymbol.for('can.' + name);
        });
        module.exports = namespace.Symbol = CanSymbol;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-reflect@1.17.11#reflections/helpers*/
define('can-reflect@1.17.11#reflections/helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    module.exports = {
        makeGetFirstSymbolValue: function (symbolNames) {
            var symbols = symbolNames.map(function (name) {
                return canSymbol.for(name);
            });
            var length = symbols.length;
            return function getFirstSymbol(obj) {
                var index = -1;
                while (++index < length) {
                    if (obj[symbols[index]] !== undefined) {
                        return obj[symbols[index]];
                    }
                }
            };
        },
        hasLength: function (list) {
            var type = typeof list;
            if (type === 'string' || Array.isArray(list)) {
                return true;
            }
            var length = list && (type !== 'boolean' && type !== 'number' && 'length' in list) && list.length;
            return typeof list !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in list);
        }
    };
});
/*can-reflect@1.17.11#reflections/type/type*/
define('can-reflect@1.17.11#reflections/type/type', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var helpers = require('../helpers');
    var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames(function () {
    }.prototype);
    var plainFunctionPrototypeProto = Object.getPrototypeOf(function () {
    }.prototype);
    function isConstructorLike(func) {
        var value = func[canSymbol.for('can.new')];
        if (value !== undefined) {
            return value;
        }
        if (typeof func !== 'function') {
            return false;
        }
        var prototype = func.prototype;
        if (!prototype) {
            return false;
        }
        if (plainFunctionPrototypeProto !== Object.getPrototypeOf(prototype)) {
            return true;
        }
        var propertyNames = Object.getOwnPropertyNames(prototype);
        if (propertyNames.length === plainFunctionPrototypePropertyNames.length) {
            for (var i = 0, len = propertyNames.length; i < len; i++) {
                if (propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
                    return true;
                }
            }
            return false;
        } else {
            return true;
        }
    }
    var getNewOrApply = helpers.makeGetFirstSymbolValue([
        'can.new',
        'can.apply'
    ]);
    function isFunctionLike(obj) {
        var result, symbolValue = !!obj && obj[canSymbol.for('can.isFunctionLike')];
        if (symbolValue !== undefined) {
            return symbolValue;
        }
        result = getNewOrApply(obj);
        if (result !== undefined) {
            return !!result;
        }
        return typeof obj === 'function';
    }
    function isPrimitive(obj) {
        var type = typeof obj;
        if (obj == null || type !== 'function' && type !== 'object') {
            return true;
        } else {
            return false;
        }
    }
    var coreHasOwn = Object.prototype.hasOwnProperty;
    var funcToString = Function.prototype.toString;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        var proto = Object.getPrototypeOf(obj);
        if (proto === Object.prototype || proto === null) {
            return true;
        }
        var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
        return typeof Constructor === 'function' && Constructor instanceof Constructor && funcToString.call(Constructor) === objectCtorString;
    }
    function isBuiltIn(obj) {
        if (isPrimitive(obj) || Array.isArray(obj) || isPlainObject(obj) || Object.prototype.toString.call(obj) !== '[object Object]' && Object.prototype.toString.call(obj).indexOf('[object ') !== -1) {
            return true;
        } else {
            return false;
        }
    }
    function isValueLike(obj) {
        var symbolValue;
        if (isPrimitive(obj)) {
            return true;
        }
        symbolValue = obj[canSymbol.for('can.isValueLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = obj[canSymbol.for('can.getValue')];
        if (value !== undefined) {
            return !!value;
        }
    }
    function isMapLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var isMapLike = obj[canSymbol.for('can.isMapLike')];
        if (typeof isMapLike !== 'undefined') {
            return !!isMapLike;
        }
        var value = obj[canSymbol.for('can.getKeyValue')];
        if (value !== undefined) {
            return !!value;
        }
        return true;
    }
    var onValueSymbol = canSymbol.for('can.onValue'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), onPatchesSymbol = canSymbol.for('can.onPatches');
    function isObservableLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        return Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);
    }
    function isListLike(list) {
        var symbolValue, type = typeof list;
        if (type === 'string') {
            return true;
        }
        if (isPrimitive(list)) {
            return false;
        }
        symbolValue = list[canSymbol.for('can.isListLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = list[canSymbol.iterator];
        if (value !== undefined) {
            return !!value;
        }
        if (Array.isArray(list)) {
            return true;
        }
        return helpers.hasLength(list);
    }
    var supportsNativeSymbols = function () {
        var symbolExists = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
        if (!symbolExists) {
            return false;
        }
        var symbol = Symbol('a symbol for testing symbols');
        return typeof symbol === 'symbol';
    }();
    var isSymbolLike;
    if (supportsNativeSymbols) {
        isSymbolLike = function (symbol) {
            return typeof symbol === 'symbol';
        };
    } else {
        var symbolStart = '@@symbol';
        isSymbolLike = function (symbol) {
            if (typeof symbol === 'object' && !Array.isArray(symbol)) {
                return symbol.toString().substr(0, symbolStart.length) === symbolStart;
            } else {
                return false;
            }
        };
    }
    module.exports = {
        isConstructorLike: isConstructorLike,
        isFunctionLike: isFunctionLike,
        isListLike: isListLike,
        isMapLike: isMapLike,
        isObservableLike: isObservableLike,
        isPrimitive: isPrimitive,
        isBuiltIn: isBuiltIn,
        isValueLike: isValueLike,
        isSymbolLike: isSymbolLike,
        isMoreListLikeThanMapLike: function (obj) {
            if (Array.isArray(obj)) {
                return true;
            }
            if (obj instanceof Array) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            var value = obj[canSymbol.for('can.isMoreListLikeThanMapLike')];
            if (value !== undefined) {
                return value;
            }
            var isListLike = this.isListLike(obj), isMapLike = this.isMapLike(obj);
            if (isListLike && !isMapLike) {
                return true;
            } else if (!isListLike && isMapLike) {
                return false;
            }
        },
        isIteratorLike: function (obj) {
            return obj && typeof obj === 'object' && typeof obj.next === 'function' && obj.next.length === 0;
        },
        isPromise: function (obj) {
            return obj instanceof Promise || Object.prototype.toString.call(obj) === '[object Promise]';
        },
        isPlainObject: isPlainObject
    };
});
/*can-reflect@1.17.11#reflections/call/call*/
define('can-reflect@1.17.11#reflections/call/call', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    module.exports = {
        call: function (func, context) {
            var args = [].slice.call(arguments, 2);
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        apply: function (func, context, args) {
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        'new': function (func) {
            var args = [].slice.call(arguments, 1);
            var makeNew = func[canSymbol.for('can.new')];
            if (makeNew) {
                return makeNew.apply(func, args);
            } else {
                var context = Object.create(func.prototype);
                var ret = func.apply(context, args);
                if (typeReflections.isPrimitive(ret)) {
                    return context;
                } else {
                    return ret;
                }
            }
        }
    };
});
/*can-reflect@1.17.11#reflections/get-set/get-set*/
define('can-reflect@1.17.11#reflections/get-set/get-set', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), getValueSymbol = canSymbol.for('can.getValue'), setValueSymbol = canSymbol.for('can.setValue');
    var reflections = {
        setKeyValue: function (obj, key, value) {
            if (typeReflections.isSymbolLike(key)) {
                if (typeof key === 'symbol') {
                    obj[key] = value;
                } else {
                    Object.defineProperty(obj, key, {
                        enumerable: false,
                        configurable: true,
                        value: value,
                        writable: true
                    });
                }
                return;
            }
            var setKeyValue = obj[setKeyValueSymbol];
            if (setKeyValue !== undefined) {
                return setKeyValue.call(obj, key, value);
            } else {
                obj[key] = value;
            }
        },
        getKeyValue: function (obj, key) {
            var getKeyValue = obj[getKeyValueSymbol];
            if (getKeyValue) {
                return getKeyValue.call(obj, key);
            }
            return obj[key];
        },
        deleteKeyValue: function (obj, key) {
            var deleteKeyValue = obj[canSymbol.for('can.deleteKeyValue')];
            if (deleteKeyValue) {
                return deleteKeyValue.call(obj, key);
            }
            delete obj[key];
        },
        getValue: function (value) {
            if (typeReflections.isPrimitive(value)) {
                return value;
            }
            var getValue = value[getValueSymbol];
            if (getValue) {
                return getValue.call(value);
            }
            return value;
        },
        setValue: function (item, value) {
            var setValue = item && item[setValueSymbol];
            if (setValue) {
                return setValue.call(item, value);
            } else {
                throw new Error('can-reflect.setValue - Can not set value.');
            }
        },
        splice: function (obj, index, removing, adding) {
            var howMany;
            if (typeof removing !== 'number') {
                var updateValues = obj[canSymbol.for('can.updateValues')];
                if (updateValues) {
                    return updateValues.call(obj, index, removing, adding);
                }
                howMany = removing.length;
            } else {
                howMany = removing;
            }
            if (arguments.length <= 3) {
                adding = [];
            }
            var splice = obj[canSymbol.for('can.splice')];
            if (splice) {
                return splice.call(obj, index, howMany, adding);
            }
            return [].splice.apply(obj, [
                index,
                howMany
            ].concat(adding));
        },
        addValues: function (obj, adding, index) {
            var add = obj[canSymbol.for('can.addValues')];
            if (add) {
                return add.call(obj, adding, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                return obj.push.apply(obj, adding);
            }
            return reflections.splice(obj, index, [], adding);
        },
        removeValues: function (obj, removing, index) {
            var removeValues = obj[canSymbol.for('can.removeValues')];
            if (removeValues) {
                return removeValues.call(obj, removing, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                removing.forEach(function (item) {
                    var index = obj.indexOf(item);
                    if (index >= 0) {
                        obj.splice(index, 1);
                    }
                });
                return;
            }
            return reflections.splice(obj, index, removing, []);
        }
    };
    reflections.get = reflections.getKeyValue;
    reflections.set = reflections.setKeyValue;
    reflections['delete'] = reflections.deleteKeyValue;
    module.exports = reflections;
});
/*can-reflect@1.17.11#reflections/observe/observe*/
define('can-reflect@1.17.11#reflections/observe/observe', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var slice = [].slice;
    function makeFallback(symbolName, fallbackName) {
        return function (obj, event, handler, queueName) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                return method.call(obj, event, handler, queueName);
            }
            return this[fallbackName].apply(this, arguments);
        };
    }
    function makeErrorIfMissing(symbolName, errorMessage) {
        return function (obj) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                var args = slice.call(arguments, 1);
                return method.apply(obj, args);
            }
            throw new Error(errorMessage);
        };
    }
    module.exports = {
        onKeyValue: makeFallback('can.onKeyValue', 'onEvent'),
        offKeyValue: makeFallback('can.offKeyValue', 'offEvent'),
        onKeys: makeErrorIfMissing('can.onKeys', 'can-reflect: can not observe an onKeys event'),
        onKeysAdded: makeErrorIfMissing('can.onKeysAdded', 'can-reflect: can not observe an onKeysAdded event'),
        onKeysRemoved: makeErrorIfMissing('can.onKeysRemoved', 'can-reflect: can not unobserve an onKeysRemoved event'),
        getKeyDependencies: makeErrorIfMissing('can.getKeyDependencies', 'can-reflect: can not determine dependencies'),
        getWhatIChange: makeErrorIfMissing('can.getWhatIChange', 'can-reflect: can not determine dependencies'),
        getChangesDependencyRecord: function getChangesDependencyRecord(handler) {
            var fn = handler[canSymbol.for('can.getChangesDependencyRecord')];
            if (typeof fn === 'function') {
                return fn();
            }
        },
        keyHasDependencies: makeErrorIfMissing('can.keyHasDependencies', 'can-reflect: can not determine if this has key dependencies'),
        onValue: makeErrorIfMissing('can.onValue', 'can-reflect: can not observe value change'),
        offValue: makeErrorIfMissing('can.offValue', 'can-reflect: can not unobserve value change'),
        getValueDependencies: makeErrorIfMissing('can.getValueDependencies', 'can-reflect: can not determine dependencies'),
        valueHasDependencies: makeErrorIfMissing('can.valueHasDependencies', 'can-reflect: can not determine if value has dependencies'),
        onPatches: makeErrorIfMissing('can.onPatches', 'can-reflect: can not observe patches on object'),
        offPatches: makeErrorIfMissing('can.offPatches', 'can-reflect: can not unobserve patches on object'),
        onInstancePatches: makeErrorIfMissing('can.onInstancePatches', 'can-reflect: can not observe onInstancePatches on Type'),
        offInstancePatches: makeErrorIfMissing('can.offInstancePatches', 'can-reflect: can not unobserve onInstancePatches on Type'),
        onInstanceBoundChange: makeErrorIfMissing('can.onInstanceBoundChange', 'can-reflect: can not observe bound state change in instances.'),
        offInstanceBoundChange: makeErrorIfMissing('can.offInstanceBoundChange', 'can-reflect: can not unobserve bound state change'),
        isBound: makeErrorIfMissing('can.isBound', 'can-reflect: cannot determine if object is bound'),
        onEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var onEvent = obj[canSymbol.for('can.onEvent')];
                if (onEvent !== undefined) {
                    return onEvent.call(obj, eventName, callback, queue);
                } else if (obj.addEventListener) {
                    obj.addEventListener(eventName, callback, queue);
                }
            }
        },
        offEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var offEvent = obj[canSymbol.for('can.offEvent')];
                if (offEvent !== undefined) {
                    return offEvent.call(obj, eventName, callback, queue);
                } else if (obj.removeEventListener) {
                    obj.removeEventListener(eventName, callback, queue);
                }
            }
        },
        setPriority: function (obj, priority) {
            if (obj) {
                var setPriority = obj[canSymbol.for('can.setPriority')];
                if (setPriority !== undefined) {
                    setPriority.call(obj, priority);
                    return true;
                }
            }
            return false;
        },
        getPriority: function (obj) {
            if (obj) {
                var getPriority = obj[canSymbol.for('can.getPriority')];
                if (getPriority !== undefined) {
                    return getPriority.call(obj);
                }
            }
            return undefined;
        }
    };
});
/*can-reflect@1.17.11#reflections/shape/shape*/
define('can-reflect@1.17.11#reflections/shape/shape', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../get-set/get-set',
    '../type/type',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var getSetReflections = require('../get-set/get-set');
    var typeReflections = require('../type/type');
    var helpers = require('../helpers');
    var getPrototypeOfWorksWithPrimitives = true;
    try {
        Object.getPrototypeOf(1);
    } catch (e) {
        getPrototypeOfWorksWithPrimitives = false;
    }
    var ArrayMap;
    if (typeof Map === 'function') {
        ArrayMap = Map;
    } else {
        var isEven = function isEven(num) {
            return num % 2 === 0;
        };
        ArrayMap = function () {
            this.contents = [];
        };
        ArrayMap.prototype = {
            _getIndex: function (key) {
                var idx;
                do {
                    idx = this.contents.indexOf(key, idx);
                } while (idx !== -1 && !isEven(idx));
                return idx;
            },
            has: function (key) {
                return this._getIndex(key) !== -1;
            },
            get: function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    return this.contents[idx + 1];
                }
            },
            set: function (key, value) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents[idx + 1] = value;
                } else {
                    this.contents.push(key);
                    this.contents.push(value);
                }
            },
            'delete': function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents.splice(idx, 2);
                }
            }
        };
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var shapeReflections;
    var shiftFirstArgumentToThis = function (func) {
        return function () {
            var args = [this];
            args.push.apply(args, arguments);
            return func.apply(null, args);
        };
    };
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue');
    var shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue');
    var shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);
    var sizeSymbol = canSymbol.for('can.size');
    var hasUpdateSymbol = helpers.makeGetFirstSymbolValue([
        'can.updateDeep',
        'can.assignDeep',
        'can.setKeyValue'
    ]);
    var shouldUpdateOrAssign = function (obj) {
        return typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
    };
    function isSerializedHelper(obj) {
        if (typeReflections.isPrimitive(obj)) {
            return true;
        }
        if (hasUpdateSymbol(obj)) {
            return false;
        }
        return typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj);
    }
    var Object_Keys;
    try {
        Object.keys(1);
        Object_Keys = Object.keys;
    } catch (e) {
        Object_Keys = function (obj) {
            if (typeReflections.isPrimitive(obj)) {
                return [];
            } else {
                return Object.keys(obj);
            }
        };
    }
    function createSerializeMap(Type) {
        var MapType = Type || ArrayMap;
        return {
            unwrap: new MapType(),
            serialize: new MapType(),
            isSerializing: {
                unwrap: new MapType(),
                serialize: new MapType()
            },
            circularReferenceIsSerializing: {
                unwrap: new MapType(),
                serialize: new MapType()
            }
        };
    }
    function makeSerializer(methodName, symbolsToCheck) {
        var serializeMap = null;
        function SerializeOperation(MapType) {
            this.first = !serializeMap;
            if (this.first) {
                serializeMap = createSerializeMap(MapType);
            }
            this.map = serializeMap;
            this.result = null;
        }
        SerializeOperation.prototype.end = function () {
            if (this.first) {
                serializeMap = null;
            }
            return this.result;
        };
        return function serializer(value, MapType) {
            if (isSerializedHelper(value)) {
                return value;
            }
            var operation = new SerializeOperation(MapType);
            if (typeReflections.isValueLike(value)) {
                operation.result = this[methodName](getSetReflections.getValue(value));
            } else {
                var isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);
                operation.result = isListLike ? [] : {};
                if (operation.map[methodName].has(value)) {
                    if (operation.map.isSerializing[methodName].has(value)) {
                        operation.map.circularReferenceIsSerializing[methodName].set(value, true);
                    }
                    return operation.map[methodName].get(value);
                } else {
                    operation.map[methodName].set(value, operation.result);
                }
                for (var i = 0, len = symbolsToCheck.length; i < len; i++) {
                    var serializer = value[symbolsToCheck[i]];
                    if (serializer) {
                        operation.map.isSerializing[methodName].set(value, true);
                        var oldResult = operation.result;
                        operation.result = serializer.call(value, oldResult);
                        operation.map.isSerializing[methodName].delete(value);
                        if (operation.result !== oldResult) {
                            if (operation.map.circularReferenceIsSerializing[methodName].has(value)) {
                                operation.end();
                                throw new Error('Cannot serialize cirular reference!');
                            }
                            operation.map[methodName].set(value, operation.result);
                        }
                        return operation.end();
                    }
                }
                if (typeof obj === 'function') {
                    operation.map[methodName].set(value, value);
                    operation.result = value;
                } else if (isListLike) {
                    this.eachIndex(value, function (childValue, index) {
                        operation.result[index] = this[methodName](childValue);
                    }, this);
                } else {
                    this.eachKey(value, function (childValue, prop) {
                        operation.result[prop] = this[methodName](childValue);
                    }, this);
                }
            }
            return operation.end();
        };
    }
    var makeMap;
    if (typeof Map !== 'undefined') {
        makeMap = function (keys) {
            var map = new Map();
            shapeReflections.eachIndex(keys, function (key) {
                map.set(key, true);
            });
            return map;
        };
    } else {
        makeMap = function (keys) {
            var map = {};
            keys.forEach(function (key) {
                map[key] = true;
            });
            return {
                get: function (key) {
                    return map[key];
                },
                set: function (key, value) {
                    map[key] = value;
                },
                keys: function () {
                    return keys;
                }
            };
        };
    }
    var fastHasOwnKey = function (obj) {
        var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
        if (hasOwnKey) {
            return hasOwnKey.bind(obj);
        } else {
            var map = makeMap(shapeReflections.getOwnEnumerableKeys(obj));
            return function (key) {
                return map.get(key);
            };
        }
    };
    function addPatch(patches, patch) {
        var lastPatch = patches[patches.length - 1];
        if (lastPatch) {
            if (lastPatch.deleteCount === lastPatch.insert.length && patch.index - lastPatch.index === lastPatch.deleteCount) {
                lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
                lastPatch.deleteCount += patch.deleteCount;
                return;
            }
        }
        patches.push(patch);
    }
    function updateDeepList(target, source, isAssign) {
        var sourceArray = this.toArray(source);
        var patches = [], lastIndex = -1;
        this.eachIndex(target, function (curVal, index) {
            lastIndex = index;
            if (index >= sourceArray.length) {
                if (!isAssign) {
                    addPatch(patches, {
                        index: index,
                        deleteCount: target.length - index + 1,
                        insert: []
                    });
                }
                return false;
            }
            var newVal = sourceArray[index];
            if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                addPatch(patches, {
                    index: index,
                    deleteCount: 1,
                    insert: [newVal]
                });
            } else {
                if (isAssign === true) {
                    this.assignDeep(curVal, newVal);
                } else {
                    this.updateDeep(curVal, newVal);
                }
            }
        }, this);
        if (sourceArray.length > lastIndex) {
            addPatch(patches, {
                index: lastIndex + 1,
                deleteCount: 0,
                insert: sourceArray.slice(lastIndex + 1)
            });
        }
        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
            var patch = patches[i];
            getSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);
        }
        return target;
    }
    shapeReflections = {
        each: function (obj, callback, context) {
            if (typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj)) {
                return shapeReflections.eachIndex(obj, callback, context);
            } else {
                return shapeReflections.eachKey(obj, callback, context);
            }
        },
        eachIndex: function (list, callback, context) {
            if (Array.isArray(list)) {
                return shapeReflections.eachListLike(list, callback, context);
            } else {
                var iter, iterator = list[canSymbol.iterator];
                if (typeReflections.isIteratorLike(list)) {
                    iter = list;
                } else if (iterator) {
                    iter = iterator.call(list);
                }
                if (iter) {
                    var res, index = 0;
                    while (!(res = iter.next()).done) {
                        if (callback.call(context || list, res.value, index++, list) === false) {
                            break;
                        }
                    }
                } else {
                    shapeReflections.eachListLike(list, callback, context);
                }
            }
            return list;
        },
        eachListLike: function (list, callback, context) {
            var index = -1;
            var length = list.length;
            if (length === undefined) {
                var size = list[sizeSymbol];
                if (size) {
                    length = size.call(list);
                } else {
                    throw new Error('can-reflect: unable to iterate.');
                }
            }
            while (++index < length) {
                var item = list[index];
                if (callback.call(context || item, item, index, list) === false) {
                    break;
                }
            }
            return list;
        },
        toArray: function (obj) {
            var arr = [];
            shapeReflections.each(obj, function (value) {
                arr.push(value);
            });
            return arr;
        },
        eachKey: function (obj, callback, context) {
            if (obj) {
                var enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);
                var getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;
                return shapeReflections.eachIndex(enumerableKeys, function (key) {
                    var value = getKeyValue.call(obj, key);
                    return callback.call(context || obj, value, key, obj);
                });
            }
            return obj;
        },
        'hasOwnKey': function (obj, key) {
            var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
            if (hasOwnKey) {
                return hasOwnKey.call(obj, key);
            }
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                var found = false;
                shapeReflections.eachIndex(getOwnKeys.call(obj), function (objKey) {
                    if (objKey === key) {
                        found = true;
                        return false;
                    }
                });
                return found;
            }
            return hasOwnProperty.call(obj, key);
        },
        getOwnEnumerableKeys: function (obj) {
            var getOwnEnumerableKeys = obj[canSymbol.for('can.getOwnEnumerableKeys')];
            if (getOwnEnumerableKeys) {
                return getOwnEnumerableKeys.call(obj);
            }
            if (obj[canSymbol.for('can.getOwnKeys')] && obj[canSymbol.for('can.getOwnKeyDescriptor')]) {
                var keys = [];
                shapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function (key) {
                    var descriptor = shapeReflections.getOwnKeyDescriptor(obj, key);
                    if (descriptor.enumerable) {
                        keys.push(key);
                    }
                }, this);
                return keys;
            } else {
                return Object_Keys(obj);
            }
        },
        getOwnKeys: function (obj) {
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                return getOwnKeys.call(obj);
            } else {
                return Object.getOwnPropertyNames(obj);
            }
        },
        getOwnKeyDescriptor: function (obj, key) {
            var getOwnKeyDescriptor = obj[canSymbol.for('can.getOwnKeyDescriptor')];
            if (getOwnKeyDescriptor) {
                return getOwnKeyDescriptor.call(obj, key);
            } else {
                return Object.getOwnPropertyDescriptor(obj, key);
            }
        },
        unwrap: makeSerializer('unwrap', [canSymbol.for('can.unwrap')]),
        serialize: makeSerializer('serialize', [
            canSymbol.for('can.serialize'),
            canSymbol.for('can.unwrap')
        ]),
        assignMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(source, function (value, key) {
                if (!hasOwnKey(key) || getKeyValue.call(target, key) !== value) {
                    setKeyValue.call(target, key, value);
                }
            });
            return target;
        },
        assignList: function (target, source) {
            var inserting = shapeReflections.toArray(source);
            getSetReflections.splice(target, 0, inserting, inserting);
            return target;
        },
        assign: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.assignList(target, source);
            } else {
                shapeReflections.assignMap(target, source);
            }
            return target;
        },
        assignDeepMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(source, function (newVal, key) {
                if (!hasOwnKey(key)) {
                    getSetReflections.setKeyValue(target, key, newVal);
                } else {
                    var curVal = getKeyValue.call(target, key);
                    if (newVal === curVal) {
                    } else if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                        setKeyValue.call(target, key, newVal);
                    } else {
                        shapeReflections.assignDeep(curVal, newVal);
                    }
                }
            }, this);
            return target;
        },
        assignDeepList: function (target, source) {
            return updateDeepList.call(this, target, source, true);
        },
        assignDeep: function (target, source) {
            var assignDeep = target[canSymbol.for('can.assignDeep')];
            if (assignDeep) {
                assignDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.assignDeepList(target, source);
            } else {
                shapeReflections.assignDeepMap(target, source);
            }
            return target;
        },
        updateMap: function (target, source) {
            var sourceKeyMap = makeMap(shapeReflections.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (newVal !== curVal) {
                    targetSetKeyValue.call(target, key, newVal);
                }
            }, this);
            shapeReflections.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateList: function (target, source) {
            var inserting = shapeReflections.toArray(source);
            getSetReflections.splice(target, 0, target, inserting);
            return target;
        },
        update: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.updateList(target, source);
            } else {
                shapeReflections.updateMap(target, source);
            }
            return target;
        },
        updateDeepMap: function (target, source) {
            var sourceKeyMap = makeMap(shapeReflections.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                    targetSetKeyValue.call(target, key, newVal);
                } else {
                    shapeReflections.updateDeep(curVal, newVal);
                }
            }, this);
            shapeReflections.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateDeepList: function (target, source) {
            return updateDeepList.call(this, target, source);
        },
        updateDeep: function (target, source) {
            var updateDeep = target[canSymbol.for('can.updateDeep')];
            if (updateDeep) {
                updateDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.updateDeepList(target, source);
            } else {
                shapeReflections.updateDeepMap(target, source);
            }
            return target;
        },
        hasKey: function (obj, key) {
            if (obj == null) {
                return false;
            }
            if (typeReflections.isPrimitive(obj)) {
                if (hasOwnProperty.call(obj, key)) {
                    return true;
                } else {
                    var proto;
                    if (getPrototypeOfWorksWithPrimitives) {
                        proto = Object.getPrototypeOf(obj);
                    } else {
                        proto = obj.__proto__;
                    }
                    if (proto !== undefined) {
                        return key in proto;
                    } else {
                        return obj[key] !== undefined;
                    }
                }
            }
            var hasKey = obj[canSymbol.for('can.hasKey')];
            if (hasKey) {
                return hasKey.call(obj, key);
            }
            var found = shapeReflections.hasOwnKey(obj, key);
            return found || key in obj;
        },
        getAllEnumerableKeys: function () {
        },
        getAllKeys: function () {
        },
        assignSymbols: function (target, source) {
            shapeReflections.eachKey(source, function (value, key) {
                var symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);
                getSetReflections.setKeyValue(target, symbol, value);
            });
            return target;
        },
        isSerialized: isSerializedHelper,
        size: function (obj) {
            if (obj == null) {
                return 0;
            }
            var size = obj[sizeSymbol];
            var count = 0;
            if (size) {
                return size.call(obj);
            } else if (helpers.hasLength(obj)) {
                return obj.length;
            } else if (typeReflections.isListLike(obj)) {
                shapeReflections.eachIndex(obj, function () {
                    count++;
                });
                return count;
            } else if (obj) {
                return shapeReflections.getOwnEnumerableKeys(obj).length;
            } else {
                return undefined;
            }
        },
        defineInstanceKey: function (cls, key, properties) {
            var defineInstanceKey = cls[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                return defineInstanceKey.call(cls, key, properties);
            }
            var proto = cls.prototype;
            defineInstanceKey = proto[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                defineInstanceKey.call(proto, key, properties);
            } else {
                Object.defineProperty(proto, key, shapeReflections.assign({
                    configurable: true,
                    enumerable: !typeReflections.isSymbolLike(key),
                    writable: true
                }, properties));
            }
        }
    };
    shapeReflections.isSerializable = shapeReflections.isSerialized;
    shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
    module.exports = shapeReflections;
});
/*can-reflect@1.17.11#reflections/shape/schema/schema*/
define('can-reflect@1.17.11#reflections/shape/schema/schema', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../../type/type',
    '../../get-set/get-set',
    '../shape'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../../type/type');
    var getSetReflections = require('../../get-set/get-set');
    var shapeReflections = require('../shape');
    var getSchemaSymbol = canSymbol.for('can.getSchema'), isMemberSymbol = canSymbol.for('can.isMember'), newSymbol = canSymbol.for('can.new');
    function comparator(a, b) {
        return a.localeCompare(b);
    }
    function sort(obj) {
        if (typeReflections.isPrimitive(obj) || obj instanceof Date) {
            return obj;
        }
        var out;
        if (typeReflections.isListLike(obj)) {
            out = [];
            shapeReflections.eachKey(obj, function (item) {
                out.push(sort(item));
            });
            return out;
        }
        if (typeReflections.isMapLike(obj)) {
            out = {};
            shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {
                out[key] = sort(getSetReflections.getKeyValue(obj, key));
            });
            return out;
        }
        return obj;
    }
    function isPrimitiveConverter(Type) {
        return Type === Number || Type === String || Type === Boolean;
    }
    var schemaReflections = {
        getSchema: function (type) {
            if (type === undefined) {
                return undefined;
            }
            var getSchema = type[getSchemaSymbol];
            if (getSchema === undefined) {
                type = type.constructor;
                getSchema = type && type[getSchemaSymbol];
            }
            return getSchema !== undefined ? getSchema.call(type) : undefined;
        },
        getIdentity: function (value, schema) {
            schema = schema || schemaReflections.getSchema(value);
            if (schema === undefined) {
                throw new Error('can-reflect.getIdentity - Unable to find a schema for the given value.');
            }
            var identity = schema.identity;
            if (!identity || identity.length === 0) {
                throw new Error('can-reflect.getIdentity - Provided schema lacks an identity property.');
            } else if (identity.length === 1) {
                return getSetReflections.getKeyValue(value, identity[0]);
            } else {
                var id = {};
                identity.forEach(function (key) {
                    id[key] = getSetReflections.getKeyValue(value, key);
                });
                return JSON.stringify(schemaReflections.cloneKeySort(id));
            }
        },
        cloneKeySort: function (obj) {
            return sort(obj);
        },
        convert: function (value, Type) {
            if (isPrimitiveConverter(Type)) {
                return Type(value);
            }
            var isMemberTest = Type[isMemberSymbol], isMember = false, type = typeof Type, createNew = Type[newSymbol];
            if (isMemberTest !== undefined) {
                isMember = isMemberTest.call(Type, value);
            } else if (type === 'function') {
                if (typeReflections.isConstructorLike(Type)) {
                    isMember = value instanceof Type;
                }
            }
            if (isMember) {
                return value;
            }
            if (createNew !== undefined) {
                return createNew.call(Type, value);
            } else if (type === 'function') {
                if (typeReflections.isConstructorLike(Type)) {
                    return new Type(value);
                } else {
                    return Type(value);
                }
            } else {
                throw new Error('can-reflect: Can not convert values into type. Type must provide `can.new` symbol.');
            }
        }
    };
    module.exports = schemaReflections;
});
/*can-reflect@1.17.11#reflections/get-name/get-name*/
define('can-reflect@1.17.11#reflections/get-name/get-name', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var getNameSymbol = canSymbol.for('can.getName');
    function setName(obj, nameGetter) {
        if (typeof nameGetter !== 'function') {
            var value = nameGetter;
            nameGetter = function () {
                return value;
            };
        }
        Object.defineProperty(obj, getNameSymbol, { value: nameGetter });
    }
    var anonymousID = 0;
    function getName(obj) {
        var type = typeof obj;
        if (obj === null || type !== 'object' && type !== 'function') {
            return '' + obj;
        }
        var nameGetter = obj[getNameSymbol];
        if (nameGetter) {
            return nameGetter.call(obj);
        }
        if (type === 'function') {
            if (!('name' in obj)) {
                obj.name = 'functionIE' + anonymousID++;
            }
            return obj.name;
        }
        if (obj.constructor && obj !== obj.constructor) {
            var parent = getName(obj.constructor);
            if (parent) {
                if (typeReflections.isValueLike(obj)) {
                    return parent + '<>';
                }
                if (typeReflections.isMoreListLikeThanMapLike(obj)) {
                    return parent + '[]';
                }
                if (typeReflections.isMapLike(obj)) {
                    return parent + '{}';
                }
            }
        }
        return undefined;
    }
    module.exports = {
        setName: setName,
        getName: getName
    };
});
/*can-reflect@1.17.11#types/map*/
define('can-reflect@1.17.11#types/map', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    function keysPolyfill() {
        var keys = [];
        var currentIndex = 0;
        this.forEach(function (val, key) {
            keys.push(key);
        });
        return {
            next: function () {
                return {
                    value: keys[currentIndex],
                    done: currentIndex++ === keys.length
                };
            }
        };
    }
    if (typeof Map !== 'undefined') {
        shape.assignSymbols(Map.prototype, {
            'can.getOwnEnumerableKeys': Map.prototype.keys,
            'can.setKeyValue': Map.prototype.set,
            'can.getKeyValue': Map.prototype.get,
            'can.deleteKeyValue': Map.prototype['delete'],
            'can.hasOwnKey': Map.prototype.has
        });
        if (typeof Map.prototype.keys !== 'function') {
            Map.prototype.keys = Map.prototype[CanSymbol.for('can.getOwnEnumerableKeys')] = keysPolyfill;
        }
    }
    if (typeof WeakMap !== 'undefined') {
        shape.assignSymbols(WeakMap.prototype, {
            'can.getOwnEnumerableKeys': function () {
                throw new Error('can-reflect: WeakMaps do not have enumerable keys.');
            },
            'can.setKeyValue': WeakMap.prototype.set,
            'can.getKeyValue': WeakMap.prototype.get,
            'can.deleteKeyValue': WeakMap.prototype['delete'],
            'can.hasOwnKey': WeakMap.prototype.has
        });
    }
});
/*can-reflect@1.17.11#types/set*/
define('can-reflect@1.17.11#types/set', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    if (typeof Set !== 'undefined') {
        shape.assignSymbols(Set.prototype, {
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                return this.size;
            }
        });
        if (typeof Set.prototype[CanSymbol.iterator] !== 'function') {
            Set.prototype[CanSymbol.iterator] = function () {
                var arr = [];
                var currentIndex = 0;
                this.forEach(function (val) {
                    arr.push(val);
                });
                return {
                    next: function () {
                        return {
                            value: arr[currentIndex],
                            done: currentIndex++ === arr.length
                        };
                    }
                };
            };
        }
    }
    if (typeof WeakSet !== 'undefined') {
        shape.assignSymbols(WeakSet.prototype, {
            'can.isListLike': true,
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                throw new Error('can-reflect: WeakSets do not have enumerable keys.');
            }
        });
    }
});
/*can-reflect@1.17.11#can-reflect*/
define('can-reflect@1.17.11#can-reflect', [
    'require',
    'exports',
    'module',
    './reflections/call/call',
    './reflections/get-set/get-set',
    './reflections/observe/observe',
    './reflections/shape/shape',
    './reflections/shape/schema/schema',
    './reflections/type/type',
    './reflections/get-name/get-name',
    'can-namespace',
    './types/map',
    './types/set'
], function (require, exports, module) {
    'use strict';
    var functionReflections = require('./reflections/call/call');
    var getSet = require('./reflections/get-set/get-set');
    var observe = require('./reflections/observe/observe');
    var shape = require('./reflections/shape/shape');
    var schema = require('./reflections/shape/schema/schema');
    var type = require('./reflections/type/type');
    var getName = require('./reflections/get-name/get-name');
    var namespace = require('can-namespace');
    var reflect = {};
    [
        functionReflections,
        getSet,
        observe,
        shape,
        type,
        getName,
        schema
    ].forEach(function (reflections) {
        for (var prop in reflections) {
            reflect[prop] = reflections[prop];
        }
    });
    require('./types/map');
    require('./types/set');
    module.exports = namespace.Reflect = reflect;
});
/*can-globals@1.2.2#can-globals-proto*/
define('can-globals@1.2.2#can-globals-proto', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var canReflect = require('can-reflect');
        function dispatch(key) {
            var handlers = this.eventHandlers[key];
            if (handlers) {
                var handlersCopy = handlers.slice();
                var value = this.getKeyValue(key);
                for (var i = 0; i < handlersCopy.length; i++) {
                    handlersCopy[i](value);
                }
            }
        }
        function Globals() {
            this.eventHandlers = {};
            this.properties = {};
        }
        Globals.prototype.define = function (key, value, enableCache) {
            if (enableCache === undefined) {
                enableCache = true;
            }
            if (!this.properties[key]) {
                this.properties[key] = {
                    default: value,
                    value: value,
                    enableCache: enableCache
                };
            }
            return this;
        };
        Globals.prototype.getKeyValue = function (key) {
            var property = this.properties[key];
            if (property) {
                if (typeof property.value === 'function') {
                    if (property.cachedValue) {
                        return property.cachedValue;
                    }
                    if (property.enableCache) {
                        property.cachedValue = property.value();
                        return property.cachedValue;
                    } else {
                        return property.value();
                    }
                }
                return property.value;
            }
        };
        Globals.prototype.makeExport = function (key) {
            return function (value) {
                if (arguments.length === 0) {
                    return this.getKeyValue(key);
                }
                if (typeof value === 'undefined' || value === null) {
                    this.deleteKeyValue(key);
                } else {
                    if (typeof value === 'function') {
                        this.setKeyValue(key, function () {
                            return value;
                        });
                    } else {
                        this.setKeyValue(key, value);
                    }
                    return value;
                }
            }.bind(this);
        };
        Globals.prototype.offKeyValue = function (key, handler) {
            if (this.properties[key]) {
                var handlers = this.eventHandlers[key];
                if (handlers) {
                    var i = handlers.indexOf(handler);
                    handlers.splice(i, 1);
                }
            }
            return this;
        };
        Globals.prototype.onKeyValue = function (key, handler) {
            if (this.properties[key]) {
                if (!this.eventHandlers[key]) {
                    this.eventHandlers[key] = [];
                }
                this.eventHandlers[key].push(handler);
            }
            return this;
        };
        Globals.prototype.deleteKeyValue = function (key) {
            var property = this.properties[key];
            if (property !== undefined) {
                property.value = property.default;
                property.cachedValue = undefined;
                dispatch.call(this, key);
            }
            return this;
        };
        Globals.prototype.setKeyValue = function (key, value) {
            if (!this.properties[key]) {
                return this.define(key, value);
            }
            var property = this.properties[key];
            property.value = value;
            property.cachedValue = undefined;
            dispatch.call(this, key);
            return this;
        };
        Globals.prototype.reset = function () {
            for (var key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    this.properties[key].value = this.properties[key].default;
                    this.properties[key].cachedValue = undefined;
                    dispatch.call(this, key);
                }
            }
            return this;
        };
        canReflect.assignSymbols(Globals.prototype, {
            'can.getKeyValue': Globals.prototype.getKeyValue,
            'can.setKeyValue': Globals.prototype.setKeyValue,
            'can.deleteKeyValue': Globals.prototype.deleteKeyValue,
            'can.onKeyValue': Globals.prototype.onKeyValue,
            'can.offKeyValue': Globals.prototype.offKeyValue
        });
        module.exports = Globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#can-globals-instance*/
define('can-globals@1.2.2#can-globals-instance', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './can-globals-proto'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var Globals = require('./can-globals-proto');
        var globals = new Globals();
        if (namespace.globals) {
            throw new Error('You can\'t have two versions of can-globals, check your dependencies');
        } else {
            module.exports = namespace.globals = globals;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#global/global*/
define('can-globals@1.2.2#global/global', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('global', function () {
            return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : typeof process === 'object' && {}.toString.call(process) === '[object process]' ? global : window;
        });
        module.exports = globals.makeExport('global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#document/document*/
define('can-globals@1.2.2#document/document', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('document', function () {
            return globals.getKeyValue('global').document;
        });
        module.exports = globals.makeExport('document');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#location/location*/
define('can-globals@1.2.2#location/location', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('location', function () {
            return globals.getKeyValue('global').location;
        });
        module.exports = globals.makeExport('location');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#mutation-observer/mutation-observer*/
define('can-globals@1.2.2#mutation-observer/mutation-observer', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('MutationObserver', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;
        });
        module.exports = globals.makeExport('MutationObserver');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#is-node/is-node*/
define('can-globals@1.2.2#is-node/is-node', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('isNode', function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        });
        module.exports = globals.makeExport('isNode');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#is-browser-window/is-browser-window*/
define('can-globals@1.2.2#is-browser-window/is-browser-window', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    '../is-node/is-node'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('../is-node/is-node');
        globals.define('isBrowserWindow', function () {
            var isNode = globals.getKeyValue('isNode');
            return typeof window !== 'undefined' && typeof document !== 'undefined' && isNode === false;
        });
        module.exports = globals.makeExport('isBrowserWindow');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#custom-elements/custom-elements*/
define('can-globals@1.2.2#custom-elements/custom-elements', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('customElements', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.customElements;
        });
        module.exports = globals.makeExport('customElements');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.2#can-globals*/
define('can-globals@1.2.2#can-globals', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    './global/global',
    './document/document',
    './location/location',
    './mutation-observer/mutation-observer',
    './is-browser-window/is-browser-window',
    './is-node/is-node',
    './custom-elements/custom-elements'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('./global/global');
        require('./document/document');
        require('./location/location');
        require('./mutation-observer/mutation-observer');
        require('./is-browser-window/is-browser-window');
        require('./is-node/is-node');
        require('./custom-elements/custom-elements');
        module.exports = globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.7#-util*/
define('can-dom-mutate@1.3.7#-util', [
    'require',
    'exports',
    'module',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        function eliminate(array, item) {
            var index = array.indexOf(item);
            if (index >= 0) {
                array.splice(index, 1);
            }
        }
        function addToSet(items, set) {
            for (var i = 0, length = items.length; i < length; i++) {
                set.add(items[i]);
            }
        }
        function contains(parent, child) {
            if (parent.contains) {
                return parent.contains(child);
            }
            if (parent.nodeType === Node.DOCUMENT_NODE && parent.documentElement) {
                return contains(parent.documentElement, child);
            } else {
                child = child.parentNode;
                if (child === parent) {
                    return true;
                }
                return false;
            }
        }
        function isDocumentElement(node) {
            return getDocument().documentElement === node;
        }
        function isFragment(node) {
            return !!(node && node.nodeType === 11);
        }
        function isElementNode(node) {
            return !!(node && node.nodeType === 1);
        }
        function getChildren(parentNode) {
            var nodes = [];
            var node = parentNode.firstChild;
            while (node) {
                nodes.push(node);
                node = node.nextSibling;
            }
            return nodes;
        }
        function getParents(node) {
            var nodes;
            if (isFragment(node)) {
                nodes = getChildren(node);
            } else {
                nodes = [node];
            }
            return nodes;
        }
        function getNodesLegacyB(node) {
            var skip, tmp;
            var depth = 0;
            var items = isFragment(node) ? [] : [node];
            if (node.firstChild == null) {
                return items;
            }
            do {
                if (!skip && (tmp = node.firstChild)) {
                    depth++;
                    items.push(tmp);
                } else if (tmp = node.nextSibling) {
                    skip = false;
                    items.push(tmp);
                } else {
                    tmp = node.parentNode;
                    depth--;
                    skip = true;
                }
                node = tmp;
            } while (depth > 0);
            return items;
        }
        function treeWalkerFilterFunction() {
            return NodeFilter.FILTER_ACCEPT;
        }
        var treeWalkerFilter = treeWalkerFilterFunction;
        treeWalkerFilter.acceptNode = treeWalkerFilterFunction;
        function getNodesWithTreeWalker(rootNode) {
            var result = isFragment(rootNode) ? [] : [rootNode];
            var walker = isElementNode(rootNode) && getDocument().createTreeWalker(rootNode, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, treeWalkerFilter, false);
            var node;
            while (node = walker && walker.nextNode()) {
                result.push(node);
            }
            return result;
        }
        function getAllNodes(node) {
            if (getDocument().createTreeWalker !== undefined) {
                return getNodesWithTreeWalker(node);
            } else {
                return getNodesLegacyB(node);
            }
        }
        function subscription(fn) {
            return function _subscription() {
                var disposal = fn.apply(this, arguments);
                var isDisposed = false;
                return function _disposal() {
                    if (isDisposed) {
                        var fnName = fn.name || fn.displayName || 'an anonymous function';
                        var message = 'Disposal function returned by ' + fnName + ' called more than once.';
                        throw new Error(message);
                    }
                    disposal.apply(this, arguments);
                    isDisposed = true;
                };
            };
        }
        module.exports = {
            eliminate: eliminate,
            getDocument: getDocument,
            isDocumentElement: isDocumentElement,
            isFragment: isFragment,
            getParents: getParents,
            getAllNodes: getAllNodes,
            getChildren: getChildren,
            subscription: subscription,
            addToSet: addToSet,
            contains: contains
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.7#can-dom-mutate*/
define('can-dom-mutate@1.3.7#can-dom-mutate', [
    'require',
    'exports',
    'module',
    'can-globals',
    'can-globals/global/global',
    'can-globals/mutation-observer/mutation-observer',
    'can-namespace',
    'can-globals/document/document',
    'can-reflect',
    './-util'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        var getRoot = require('can-globals/global/global');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var namespace = require('can-namespace');
        var DOCUMENT = require('can-globals/document/document');
        var canReflect = require('can-reflect');
        var util = require('./-util');
        var eliminate = util.eliminate;
        var subscription = util.subscription;
        var isDocumentElement = util.isDocumentElement;
        var getAllNodes = util.getAllNodes;
        var domMutate, dispatchInsertion, dispatchRemoval, dispatchAttributeChange;
        var dataStore = new WeakMap();
        function getRelatedData(node, key) {
            var data = dataStore.get(node);
            if (data) {
                return data[key];
            }
        }
        function setRelatedData(node, key, targetListenersMap) {
            var data = dataStore.get(node);
            if (!data) {
                data = {};
                dataStore.set(node, data);
            }
            data[key] = targetListenersMap;
        }
        function deleteRelatedData(node, key) {
            var data = dataStore.get(node);
            return delete data[key];
        }
        function toMutationEvents(nodes) {
            var events = [];
            for (var i = 0; i < nodes.length; i++) {
                events.push({ target: nodes[i] });
            }
            return events;
        }
        function batch(processBatchItems) {
            return function batchAdd(items, callback, dispatchConnected, flush) {
                processBatchItems(items, dispatchConnected, flush);
                if (callback) {
                    callback();
                }
            };
        }
        function getDocumentListeners(target, key) {
            var doc = DOCUMENT();
            var data = getRelatedData(doc, key);
            if (data) {
                return data.listeners;
            }
        }
        function getTargetListeners(target, key) {
            var doc = DOCUMENT();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                return;
            }
            return targetListenersMap.get(target);
        }
        function addTargetListener(target, key, listener) {
            var doc = DOCUMENT();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                targetListenersMap = new Map();
                setRelatedData(doc, key, targetListenersMap);
            }
            var targetListeners = targetListenersMap.get(target);
            if (!targetListeners) {
                targetListeners = [];
                targetListenersMap.set(target, targetListeners);
            }
            targetListeners.push(listener);
        }
        function removeTargetListener(target, key, listener) {
            var doc = DOCUMENT();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                return;
            }
            var targetListeners = targetListenersMap.get(target);
            if (!targetListeners) {
                return;
            }
            eliminate(targetListeners, listener);
            if (targetListeners.length === 0) {
                targetListenersMap['delete'](target);
                if (targetListenersMap.size === 0) {
                    deleteRelatedData(doc, key);
                }
            }
        }
        var promise = Promise.resolve();
        function nextTick(handler) {
            promise.then(handler);
        }
        var recordsAndCallbacks = null;
        function flushCallbacks(callbacks, arg) {
            var callbacksCount = callbacks.length;
            var safeCallbacks = callbacks.slice(0);
            for (var c = 0; c < callbacksCount; c++) {
                safeCallbacks[c](arg);
            }
        }
        function flushRecords() {
            if (recordsAndCallbacks === null) {
                return;
            }
            var safeBatch = recordsAndCallbacks;
            recordsAndCallbacks = null;
            var batchCount = safeBatch.length;
            for (var i = 0; i < batchCount; i++) {
                var batchData = safeBatch[i];
                flushCallbacks(batchData.callbacks, batchData.arg);
            }
        }
        function flushAsync(callbacks, arg) {
            if (recordsAndCallbacks === null) {
                recordsAndCallbacks = [{
                        arg: arg,
                        callbacks: callbacks
                    }];
                nextTick(flushRecords);
            } else {
                recordsAndCallbacks.push({
                    arg: arg,
                    callbacks: callbacks
                });
            }
        }
        function dispatch(targetKey, connectedKey, documentDataKey) {
            return function dispatchEvents(events, dispatchConnected, flush) {
                for (var e = 0; e < events.length; e++) {
                    var event = events[e];
                    var target = event.target;
                    var targetListeners = getTargetListeners(target, targetKey);
                    if (targetListeners) {
                        flush(targetListeners, event);
                    }
                    if (!dispatchConnected) {
                        continue;
                    }
                    var connectedListeners;
                    if (connectedKey) {
                        connectedListeners = getTargetListeners(target, connectedKey);
                    }
                    if (connectedListeners) {
                        flush(connectedListeners, event);
                    }
                    if (!documentDataKey) {
                        continue;
                    }
                    var documentListeners = getDocumentListeners(target, documentDataKey);
                    if (documentListeners) {
                        flush(documentListeners, event);
                    }
                }
            };
        }
        var count = 0;
        function observeMutations(target, observerKey, config, handler) {
            var observerData = getRelatedData(target, observerKey);
            if (!observerData) {
                observerData = { observingCount: 0 };
                setRelatedData(target, observerKey, observerData);
            }
            var setupObserver = function () {
                if (observerData.observer) {
                    observerData.observer.disconnect();
                    observerData.observer = null;
                }
                var MutationObserver = getMutationObserver();
                if (MutationObserver) {
                    var Node = getRoot().Node;
                    var isRealNode = !!(Node && target instanceof Node);
                    if (isRealNode) {
                        var targetObserver = new MutationObserver(handler);
                        targetObserver.id = count++;
                        targetObserver.observe(target, config);
                        observerData.observer = targetObserver;
                    }
                }
            };
            if (observerData.observingCount === 0) {
                globals.onKeyValue('MutationObserver', setupObserver);
                setupObserver();
            }
            observerData.observingCount++;
            return function stopObservingMutations() {
                var observerData = getRelatedData(target, observerKey);
                if (observerData) {
                    observerData.observingCount--;
                    if (observerData.observingCount <= 0) {
                        if (observerData.observer) {
                            observerData.observer.disconnect();
                        }
                        deleteRelatedData(target, observerKey);
                        globals.offKeyValue('MutationObserver', setupObserver);
                    }
                }
            };
        }
        function handleTreeMutations(mutations) {
            if (typeof Set === 'undefined') {
                return;
            }
            var mutationCount = mutations.length;
            var added = new Set(), removed = new Set();
            for (var m = 0; m < mutationCount; m++) {
                var mutation = mutations[m];
                var addedCount = mutation.addedNodes.length;
                for (var a = 0; a < addedCount; a++) {
                    util.addToSet(getAllNodes(mutation.addedNodes[a]), added);
                }
                var removedCount = mutation.removedNodes.length;
                for (var r = 0; r < removedCount; r++) {
                    util.addToSet(getAllNodes(mutation.removedNodes[r]), removed);
                }
            }
            dispatchRemoval(toMutationEvents(canReflect.toArray(removed)), null, true, flushCallbacks);
            dispatchInsertion(toMutationEvents(canReflect.toArray(added)), null, true, flushCallbacks);
        }
        function handleAttributeMutations(mutations) {
            var mutationCount = mutations.length;
            for (var m = 0; m < mutationCount; m++) {
                var mutation = mutations[m];
                if (mutation.type === 'attributes') {
                    var node = mutation.target;
                    var attributeName = mutation.attributeName;
                    var oldValue = mutation.oldValue;
                    dispatchAttributeChange([{
                            target: node,
                            attributeName: attributeName,
                            oldValue: oldValue
                        }], null, true, flushCallbacks);
                }
            }
        }
        var treeMutationConfig = {
            subtree: true,
            childList: true
        };
        var attributeMutationConfig = {
            attributes: true,
            attributeOldValue: true
        };
        function addNodeListener(listenerKey, observerKey, isAttributes) {
            return subscription(function _addNodeListener(target, listener) {
                if (target.nodeType === 11) {
                    return Function.prototype;
                }
                var stopObserving;
                if (isAttributes) {
                    stopObserving = observeMutations(target, observerKey, attributeMutationConfig, handleAttributeMutations);
                } else {
                    stopObserving = observeMutations(DOCUMENT(), observerKey, treeMutationConfig, handleTreeMutations);
                }
                addTargetListener(target, listenerKey, listener);
                return function removeNodeListener() {
                    if (stopObserving) {
                        stopObserving();
                    }
                    removeTargetListener(target, listenerKey, listener);
                };
            });
        }
        function addGlobalListener(globalDataKey, addNodeListener) {
            return subscription(function addGlobalGroupListener(documentElement, listener) {
                if (!isDocumentElement(documentElement)) {
                    throw new Error('Global mutation listeners must pass a documentElement');
                }
                var doc = DOCUMENT();
                var documentData = getRelatedData(doc, globalDataKey);
                if (!documentData) {
                    documentData = { listeners: [] };
                    setRelatedData(doc, globalDataKey, documentData);
                }
                var listeners = documentData.listeners;
                if (listeners.length === 0) {
                    documentData.removeListener = addNodeListener(doc, function () {
                    });
                }
                listeners.push(listener);
                return function removeGlobalGroupListener() {
                    var documentData = getRelatedData(doc, globalDataKey);
                    if (!documentData) {
                        return;
                    }
                    var listeners = documentData.listeners;
                    eliminate(listeners, listener);
                    if (listeners.length === 0) {
                        documentData.removeListener();
                        deleteRelatedData(doc, globalDataKey);
                    }
                };
            });
        }
        var domMutationPrefix = 'domMutation';
        var connectedDataKey = domMutationPrefix + 'ConnectedData';
        var disconnectedDataKey = domMutationPrefix + 'DisconnectedData';
        var insertedDataKey = domMutationPrefix + 'InsertedData';
        var removedDataKey = domMutationPrefix + 'RemovedData';
        var attributeChangeDataKey = domMutationPrefix + 'AttributeChangeData';
        var documentConnectedDataKey = domMutationPrefix + 'DocumentConnectedData';
        var documentDisconnectedDataKey = domMutationPrefix + 'DocumentDisconnectedData';
        var documentAttributeChangeDataKey = domMutationPrefix + 'DocumentAttributeChangeData';
        var treeDataKey = domMutationPrefix + 'TreeData';
        var attributeDataKey = domMutationPrefix + 'AttributeData';
        dispatchInsertion = batch(dispatch(insertedDataKey, connectedDataKey, documentConnectedDataKey));
        dispatchRemoval = batch(dispatch(removedDataKey, disconnectedDataKey, documentDisconnectedDataKey));
        dispatchAttributeChange = batch(dispatch(attributeChangeDataKey, null, documentAttributeChangeDataKey));
        var addNodeConnectedListener = addNodeListener(connectedDataKey, treeDataKey);
        var addNodeDisconnectedListener = addNodeListener(disconnectedDataKey, treeDataKey);
        var addNodeInsertedListener = addNodeListener(insertedDataKey, treeDataKey);
        var addNodeRemovedListener = addNodeListener(removedDataKey, treeDataKey);
        var addNodeAttributeChangeListener = addNodeListener(attributeChangeDataKey, attributeDataKey, true);
        var addConnectedListener = addGlobalListener(documentConnectedDataKey, addNodeConnectedListener);
        var addDisconnectedListener = addGlobalListener(documentDisconnectedDataKey, addNodeDisconnectedListener);
        var addAttributeChangeListener = addGlobalListener(documentAttributeChangeDataKey, addNodeAttributeChangeListener);
        domMutate = {
            dispatchNodeInsertion: function (node, callback, dispatchConnected) {
                var nodes = new Set();
                util.addToSet(getAllNodes(node), nodes);
                var events = toMutationEvents(canReflect.toArray(nodes));
                dispatchInsertion(events, callback, dispatchConnected, flushAsync);
            },
            dispatchNodeRemoval: function (node, callback, dispatchConnected) {
                var nodes = new Set();
                util.addToSet(getAllNodes(node), nodes);
                var events = toMutationEvents(canReflect.toArray(nodes));
                dispatchRemoval(events, callback, dispatchConnected, flushAsync);
            },
            dispatchNodeAttributeChange: function (target, attributeName, oldValue, callback) {
                dispatchAttributeChange([{
                        target: target,
                        attributeName: attributeName,
                        oldValue: oldValue
                    }], callback, true, flushAsync);
            },
            onNodeConnected: addNodeConnectedListener,
            onNodeInsertion: function () {
                console.warn('can-dom-mutate: Use onNodeConnected instead of onNodeInsertion');
                return addNodeConnectedListener.apply(this, arguments);
            },
            onNodeDisconnected: addNodeDisconnectedListener,
            onNodeRemoval: function () {
                console.warn('can-dom-mutate: Use onNodeDisconnected instead of onNodeRemoval');
                return addNodeDisconnectedListener.apply(this, arguments);
            },
            onNodeAttributeChange: addNodeAttributeChangeListener,
            onDisconnected: addDisconnectedListener,
            onRemoval: function () {
                console.warn('can-dom-mutate: Use onDisconnected instead of onRemoval');
                return addDisconnectedListener.apply(this, arguments);
            },
            onConnected: addConnectedListener,
            onInsertion: function () {
                console.warn('can-dom-mutate: Use onConnected instead of onInsertion');
                return addConnectedListener.apply(this, arguments);
            },
            onAttributeChange: addAttributeChangeListener,
            flushRecords: function (doc) {
                doc = doc || DOCUMENT();
                var data = dataStore.get(doc);
                if (data) {
                    if (data.domMutationTreeData && data.domMutationTreeData.observer) {
                        var records = data.domMutationTreeData.observer.takeRecords();
                        handleTreeMutations(records);
                    }
                    flushRecords();
                }
            },
            onNodeInserted: addNodeInsertedListener,
            onNodeRemoved: addNodeRemovedListener
        };
        module.exports = namespace.domMutate = domMutate;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.7#node/node*/
define('can-dom-mutate@1.3.7#node/node', [
    'require',
    'exports',
    'module',
    'can-globals',
    'can-namespace',
    '../can-dom-mutate',
    '../-util'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        var namespace = require('can-namespace');
        var domMutate = require('../can-dom-mutate');
        var util = require('../-util');
        var getParents = util.getParents;
        var contains = util.contains;
        var isConnected;
        function getIsConnectedFromNode(node) {
            return node.isConnected;
        }
        function getIsConnectedFromDocument(node) {
            var doc = node.ownerDocument;
            return doc === null || doc === node || contains(doc, node);
        }
        function setIsConnected(doc) {
            var node = doc.createTextNode('');
            isConnected = 'isConnected' in node.constructor.prototype ? getIsConnectedFromNode : getIsConnectedFromDocument;
        }
        setIsConnected(globals.getKeyValue('document'));
        globals.onKeyValue('document', setIsConnected);
        var compat = {
            replaceChild: function (newChild, oldChild) {
                var newChildren = getParents(newChild);
                var result = this.replaceChild(newChild, oldChild);
                domMutate.dispatchNodeRemoval(oldChild, null, isConnected(this) && !isConnected(oldChild));
                for (var i = 0; i < newChildren.length; i++) {
                    domMutate.dispatchNodeInsertion(newChildren[i], null, isConnected(this));
                }
                return result;
            },
            setAttribute: function (name, value) {
                var oldAttributeValue = this.getAttribute(name);
                var result = this.setAttribute(name, value);
                var newAttributeValue = this.getAttribute(name);
                if (oldAttributeValue !== newAttributeValue) {
                    domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
                }
                return result;
            },
            removeAttribute: function (name) {
                var oldAttributeValue = this.getAttribute(name);
                var result = this.removeAttribute(name);
                if (oldAttributeValue) {
                    domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
                }
                return result;
            }
        };
        var compatData = [
            [
                'appendChild',
                'Insertion'
            ],
            [
                'insertBefore',
                'Insertion'
            ],
            [
                'removeChild',
                'Removal'
            ]
        ];
        compatData.forEach(function (pair) {
            var nodeMethod = pair[0];
            var dispatchMethod = 'dispatchNode' + pair[1];
            compat[nodeMethod] = function (node) {
                var nodes = getParents(node);
                var result = this[nodeMethod].apply(this, arguments);
                for (var i = 0; i < nodes.length; i++) {
                    domMutate[dispatchMethod](nodes[i], null, isConnected(this) && (pair[1] === 'Removal' ? !isConnected(nodes[i]) : true));
                }
                return result;
            };
        });
        var normal = {};
        var nodeMethods = [
            'appendChild',
            'insertBefore',
            'removeChild',
            'replaceChild',
            'setAttribute',
            'removeAttribute'
        ];
        nodeMethods.forEach(function (methodName) {
            normal[methodName] = function () {
                if (isConnected(this)) {
                    return this[methodName].apply(this, arguments);
                } else {
                    return compat[methodName].apply(this, arguments);
                }
            };
        });
        var mutate = {};
        function setMutateStrategy(observer) {
            var strategy = observer ? normal : compat;
            for (var key in strategy) {
                mutate[key] = strategy[key];
            }
        }
        var mutationObserverKey = 'MutationObserver';
        setMutateStrategy(globals.getKeyValue(mutationObserverKey));
        globals.onKeyValue(mutationObserverKey, setMutateStrategy);
        module.exports = namespace.domMutateNode = domMutate.node = mutate;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.7#node*/
define('can-dom-mutate@1.3.7#node', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './node/node'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var node = require('./node/node');
    module.exports = namespace.node = node;
});
/*can-dom-mutate@1.3.7#test/test-utils*/
define('can-dom-mutate@1.3.7#test/test-utils', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-globals'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var unit = require('steal-qunit');
        var globals = require('can-globals');
        var mutationObserverKey = 'MutationObserver';
        function moduleWithMutationObserver(title, tests) {
            var hasMutationObserverSupport = !!globals.getKeyValue(mutationObserverKey);
            if (!hasMutationObserverSupport) {
                return;
            }
            unit.module(title + ' w/ MutationObserver', {}, tests);
        }
        function moduleWithoutMutationObserver(title, doc, tests) {
            var hooks = {
                beforeEach: function () {
                    globals.setKeyValue(mutationObserverKey, null);
                    globals.setKeyValue('document', doc);
                    if (doc === document) {
                        this.fixture = document.getElementById('qunit-fixture');
                    } else {
                        this.fixture = doc.createElement('div');
                        this.fixture.setAttribute('id', 'qunit-fixture');
                        doc.body.appendChild(this.fixture);
                    }
                },
                afterEach: function (assert) {
                    globals.deleteKeyValue(mutationObserverKey);
                    if (doc !== document) {
                        doc.body.removeChild(this.fixture);
                    }
                    var done = assert.async();
                    setTimeout(function () {
                        globals.deleteKeyValue('document');
                        var fixture = document.getElementById('qunit-fixture');
                        while (fixture && fixture.hasChildNodes()) {
                            fixture.removeChild(fixture.lastChild);
                        }
                        done();
                    }, 10);
                }
            };
            unit.module(title + ' w/o MutationObserver', hooks, tests);
        }
        function moduleMutationObserver(title, doc, tests) {
            if (doc === document) {
                moduleWithMutationObserver(title, tests);
            }
            moduleWithoutMutationObserver(title, doc, tests);
        }
        function mock(obj, methodName, newMethod) {
            var oldMethod = obj[methodName];
            obj[methodName] = newMethod;
            return function unmock() {
                obj[methodName] = oldMethod;
            };
        }
        function getFixture() {
            return globals.getKeyValue('document').getElementById('qunit-fixture');
        }
        module.exports = {
            mock: mock,
            getFixture: getFixture,
            moduleMutationObserver: moduleMutationObserver,
            moduleWithMutationObserver: moduleWithMutationObserver,
            moduleWithoutMutationObserver: moduleWithoutMutationObserver
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-dom@1.6.2#lib/document/node*/
define('can-simple-dom@1.6.2#lib/document/node', function (require, exports, module) {
    function Node(nodeType, nodeName, nodeValue, ownerDocument) {
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.ownerDocument = ownerDocument;
        this.childNodes = new ChildNodes(this);
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
    }
    Node.prototype._cloneNode = function () {
        return new Node(this.nodeType, this.nodeName, this.nodeValue, this.ownerDocument);
    };
    Node.prototype.cloneNode = function (deep) {
        var node = this._cloneNode();
        if (deep) {
            var child = this.firstChild, nextChild = child;
            while (nextChild) {
                nextChild = child.nextSibling;
                nodeAppendChild.call(node, child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    };
    var nodeAppendChild = Node.prototype.appendChild = function (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, this.lastChild, null);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = node;
            this.lastChild = node;
        } else {
            node.previousSibling = refNode;
            refNode.nextSibling = node;
            this.lastChild = node;
        }
        ensureOwnerDocument(this, node);
        return node;
    };
    function insertFragment(fragment, newParent, before, after) {
        if (!fragment.firstChild) {
            return;
        }
        var firstChild = fragment.firstChild;
        var lastChild = firstChild;
        var node = firstChild;
        firstChild.previousSibling = before;
        if (before) {
            before.nextSibling = firstChild;
        } else {
            newParent.firstChild = firstChild;
        }
        while (node) {
            node.parentNode = newParent;
            ensureOwnerDocument(newParent, node);
            lastChild = node;
            node = node.nextSibling;
        }
        lastChild.nextSibling = after;
        if (after) {
            after.previousSibling = lastChild;
        } else {
            newParent.lastChild = lastChild;
        }
        fragment.firstChild = null;
        fragment.lastChild = null;
    }
    function ensureOwnerDocument(parent, child) {
        var ownerDocument = parent.nodeType === 9 ? parent : parent.ownerDocument;
        if (parent.ownerDocument !== child.ownerDocument) {
            var node = child;
            while (node) {
                node.ownerDocument = ownerDocument;
                if (node.firstChild) {
                    ensureOwnerDocument(node, node.firstChild);
                }
                node = node.nextSibling;
            }
        }
    }
    var nodeInsertBefore = Node.prototype.insertBefore = function (node, refNode) {
        if (refNode == null) {
            return nodeAppendChild.call(this, node);
        }
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, refNode ? refNode.previousSibling : null, refNode);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var previousSibling = refNode.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = node;
            node.previousSibling = previousSibling;
        }
        refNode.previousSibling = node;
        node.nextSibling = refNode;
        if (this.firstChild === refNode) {
            this.firstChild = node;
        }
        ensureOwnerDocument(this, node);
        return node;
    };
    var nodeRemoveChild = Node.prototype.removeChild = function (refNode) {
        if (this.firstChild === refNode) {
            this.firstChild = refNode.nextSibling;
        }
        if (this.lastChild === refNode) {
            this.lastChild = refNode.previousSibling;
        }
        if (refNode.previousSibling) {
            refNode.previousSibling.nextSibling = refNode.nextSibling;
        }
        if (refNode.nextSibling) {
            refNode.nextSibling.previousSibling = refNode.previousSibling;
        }
        refNode.parentNode = null;
        refNode.nextSibling = null;
        refNode.previousSibling = null;
        return refNode;
    };
    Node.prototype.replaceChild = function (newChild, oldChild) {
        nodeInsertBefore.call(this, newChild, oldChild);
        nodeRemoveChild.call(this, oldChild);
        return oldChild;
    };
    Node.prototype.contains = function (child) {
        child = child.parentNode;
        while (child) {
            if (child === this) {
                return true;
            }
            child = child.parentNode;
        }
        return false;
    };
    Node.prototype.addEventListener = function () {
    };
    Node.prototype.removeEventListener = function () {
    };
    Node.ELEMENT_NODE = 1;
    Node.ATTRIBUTE_NODE = 2;
    Node.TEXT_NODE = 3;
    Node.CDATA_SECTION_NODE = 4;
    Node.ENTITY_REFERENCE_NODE = 5;
    Node.ENTITY_NODE = 6;
    Node.PROCESSING_INSTRUCTION_NODE = 7;
    Node.COMMENT_NODE = 8;
    Node.DOCUMENT_NODE = 9;
    Node.DOCUMENT_TYPE_NODE = 10;
    Node.DOCUMENT_FRAGMENT_NODE = 11;
    Node.NOTATION_NODE = 12;
    function ChildNodes(node) {
        this.node = node;
    }
    ChildNodes.prototype.item = function (index) {
        var child = this.node.firstChild;
        for (var i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    };
    exports.Node = Node;
    exports.nodeRemoveChild = nodeRemoveChild;
});
/*can-simple-dom@1.6.2#lib/document/style*/
define('can-simple-dom@1.6.2#lib/document/style', function (require, exports, module) {
    function CSSStyleDeclaration(node) {
        this.__node = node;
    }
    CSSStyleDeclaration.prototype.getPropertyValue = function () {
    };
    Object.defineProperty(CSSStyleDeclaration.prototype, 'cssText', {
        enumerable: true,
        configurable: true,
        get: function () {
            return this.__node.getAttribute('style') || '';
        },
        set: function (val) {
            this.__node._setAttribute('style', val);
        }
    });
    module.exports = CSSStyleDeclaration;
});
/*can-simple-dom@1.6.2#lib/document/element*/
define('can-simple-dom@1.6.2#lib/document/element', [
    'require',
    'exports',
    'module',
    './node',
    './style'
], function (require, exports, module) {
    var _node = require('./node');
    var nodeRemoveChild = _node.nodeRemoveChild;
    var Node = _node.Node;
    var CSSStyleDeclaration = require('./style');
    let attrSpecial = {
        'class': function (element, value) {
            element._className = value;
        }
    };
    function Element(tagName, ownerDocument) {
        tagName = tagName.toUpperCase();
        this.nodeConstructor(1, tagName, null, ownerDocument);
        this.style = new CSSStyleDeclaration(this);
        this.attributes = [];
        this.tagName = tagName;
    }
    Element.prototype = Object.create(Node.prototype);
    Element.prototype.constructor = Element;
    Element.prototype.nodeConstructor = Node;
    Element.prototype._cloneNode = function () {
        var node = this.ownerDocument.createElement(this.tagName);
        node.attributes = this.attributes.map(function (attr) {
            return {
                name: attr.name,
                value: attr.value,
                specified: attr.specified
            };
        });
        return node;
    };
    Element.prototype.getAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return attr.value;
            }
        }
        return null;
    };
    Element.prototype.setAttribute = function () {
        return this._setAttribute.apply(this, arguments);
    };
    Element.prototype._setAttribute = function (_name, value) {
        value += '';
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                attr.value = value;
                const special = attrSpecial[name];
                if (special) {
                    special(this, value);
                }
                return;
            }
        }
        attributes.push({
            name: name,
            value: value,
            specified: true
        });
        attributes[name] = value;
        const special = attrSpecial[name];
        if (special) {
            special(this, value);
        }
    };
    Element.prototype.setAttributeNS = function (namespaceURI, name, value) {
        this._setAttribute(name, value);
        var i = this.attributes.length;
        do {
            i--;
            var attrNode = this.attributes[i];
            if (attrNode.name === name) {
                attrNode.namespaceURI = namespaceURI;
                break;
            }
        } while (i > 0);
    };
    Element.prototype.hasAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, len = attributes.length; i < len; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return true;
            }
        }
        return false;
    };
    Element.prototype.removeAttribute = function (name) {
        var attributes = this.attributes;
        for (var i = 0, l = attributes.length; i < l; i++) {
            var attr = attributes[i];
            if (attr.name === name) {
                attributes.splice(i, 1);
                const special = attrSpecial[name];
                if (special) {
                    special(this, undefined);
                }
                delete attributes[name];
                return;
            }
        }
    };
    Element.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Element.prototype.getElementById = function (id) {
        var cur = this.firstChild, child;
        while (cur) {
            if (cur.attributes && cur.attributes.length) {
                var attr;
                for (var i = 0, len = cur.attributes.length; i < len; i++) {
                    attr = cur.attributes[i];
                    if (attr.name === 'id' && attr.value === id) {
                        return cur;
                    }
                }
            }
            if (cur.getElementById) {
                child = cur.getElementById(id);
                if (child) {
                    return child;
                }
            }
            cur = cur.nextSibling;
        }
    };
    function Style(node) {
        this.__node = node;
    }
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, 'className', {
            configurable: true,
            enumerable: true,
            get: function () {
                return this._className || '';
            },
            set: function (val) {
                this._setAttribute('class', val);
                this._className = val;
            }
        });
        Object.defineProperty(Element.prototype, 'innerHTML', {
            configurable: true,
            enumerable: true,
            get: function () {
                var html = '';
                var cur = this.firstChild;
                while (cur) {
                    html += this.ownerDocument.__serializer.serialize(cur);
                    cur = cur.nextSibling;
                }
                return html;
            },
            set: function (html) {
                this.lastChild = this.firstChild = null;
                var fragment;
                if (this.nodeName === 'SCRIPT' || this.nodeName === 'STYLE') {
                    fragment = this.ownerDocument.createTextNode(html);
                } else {
                    fragment = this.ownerDocument.__parser.parse(html);
                }
                this.appendChild(fragment);
            }
        });
        Object.defineProperty(Element.prototype, 'outerHTML', {
            get: function () {
                return this.ownerDocument.__serializer.serialize(this);
            },
            set: function (html) {
                this.parentNode.replaceChild(this.ownerDocument.__parser.parse(html), this);
            }
        });
        Object.defineProperty(Element.prototype, 'textContent', {
            get: function () {
                var fc = this.firstChild;
                return fc && fc.nodeValue || '';
            },
            set: function (val) {
                while (this.firstChild) {
                    nodeRemoveChild.call(this, this.firstChild);
                }
                var tn = this.ownerDocument.createTextNode(val);
                this.appendChild(tn);
            }
        });
    }
    module.exports = Element;
});
/*can-simple-dom@1.6.2#lib/document/text*/
define('can-simple-dom@1.6.2#lib/document/text', [
    'require',
    'exports',
    'module',
    './node'
], function (require, exports, module) {
    var Node = require('./node').Node;
    function Text(text, ownerDocument) {
        this.nodeConstructor(3, '#text', text, ownerDocument);
    }
    Text.prototype._cloneNode = function () {
        return this.ownerDocument.createTextNode(this.nodeValue);
    };
    Text.prototype = Object.create(Node.prototype);
    Text.prototype.constructor = Text;
    Text.prototype.nodeConstructor = Node;
    module.exports = Text;
});
/*can-simple-dom@1.6.2#lib/document/comment*/
define('can-simple-dom@1.6.2#lib/document/comment', [
    'require',
    'exports',
    'module',
    './node'
], function (require, exports, module) {
    var Node = require('./node').Node;
    function Comment(text, ownerDocument) {
        this.nodeConstructor(8, '#comment', text, ownerDocument);
    }
    Comment.prototype._cloneNode = function () {
        return this.ownerDocument.createComment(this.nodeValue);
    };
    Comment.prototype = Object.create(Node.prototype);
    Comment.prototype.constructor = Comment;
    Comment.prototype.nodeConstructor = Node;
    module.exports = Comment;
});
/*can-simple-dom@1.6.2#lib/document/document-fragment*/
define('can-simple-dom@1.6.2#lib/document/document-fragment', [
    'require',
    'exports',
    'module',
    './node'
], function (require, exports, module) {
    var Node = require('./node').Node;
    function DocumentFragment(ownerDocument) {
        this.nodeConstructor(11, '#document-fragment', null, ownerDocument);
    }
    DocumentFragment.prototype._cloneNode = function () {
        return this.ownerDocument.createDocumentFragment();
    };
    DocumentFragment.prototype = Object.create(Node.prototype);
    DocumentFragment.prototype.constructor = DocumentFragment;
    DocumentFragment.prototype.nodeConstructor = Node;
    module.exports = DocumentFragment;
});
/*micro-location@0.1.5#lib/micro-location*/
function Location() {
    this.init.apply(this, arguments);
}
Location.prototype = {
    init: function (protocol, host, hostname, port, pathname, search, hash) {
        this.protocol = protocol;
        this.host = host;
        this.hostname = hostname;
        this.port = port || '';
        this.pathname = pathname || '';
        this.search = search || '';
        this.hash = hash || '';
        if (protocol) {
            with (this)
                this.href = protocol + '//' + host + pathname + search + hash;
        } else if (host) {
            with (this)
                this.href = '//' + host + pathname + search + hash;
        } else {
            with (this)
                this.href = pathname + search + hash;
        }
    },
    params: function (name) {
        if (!this._params) {
            var params = {};
            var pairs = this.search.substring(1).split(/[;&]/);
            for (var i = 0, len = pairs.length; i < len; i++) {
                if (!pairs[i])
                    continue;
                var pair = pairs[i].split(/=/);
                var key = decodeURIComponent(pair[0].replace(/\+/g, '%20'));
                var val = decodeURIComponent(pair[1].replace(/\+/g, '%20'));
                if (!params[key])
                    params[key] = [];
                params[key].push(val);
            }
            this._params = params;
        }
        switch (typeof name) {
        case 'undefined':
            return this._params;
        case 'object':
            return this.build(name);
        }
        return this._params[name] ? this._params[name][0] : null;
    },
    build: function (params) {
        if (!params)
            params = this._params;
        var ret = new Location();
        var _search = this.search;
        if (params) {
            var search = [];
            for (var key in params)
                if (params.hasOwnProperty(key)) {
                    var val = params[key];
                    switch (typeof val) {
                    case 'object':
                        for (var i = 0, len = val.length; i < len; i++) {
                            search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val[i]));
                        }
                        break;
                    default:
                        search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                    }
                }
            _search = '?' + search.join('&');
        }
        with (this)
            ret.init.apply(ret, [
                protocol,
                host,
                hostname,
                port,
                pathname,
                _search,
                hash
            ]);
        return ret;
    }
};
Location.regexp = new RegExp('^(?:(https?:)//(([^:/]+)(:[^/]+)?))?([^#?]*)(\\?[^#]*)?(#.*)?$');
Location.parse = function (string) {
    var matched = String(string).match(this.regexp);
    var ret = new Location();
    ret.init.apply(ret, matched.slice(1));
    return ret;
};
(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = { Location: factory() };
    } else if (typeof define === 'function' && define.amd) {
        define('micro-location@0.1.5#lib/micro-location', [], function () {
            return { Location: factory() };
        });
    } else {
        root.Location = factory();
    }
}(this, function () {
    return Location;
}));
/*can-simple-dom@1.6.2#lib/extend*/
define('can-simple-dom@1.6.2#lib/extend', function (require, exports, module) {
    module.exports = function (a, b) {
        for (var p in b) {
            a[p] = b[p];
        }
        return a;
    };
});
/*can-simple-dom@1.6.2#lib/document/anchor-element*/
define('can-simple-dom@1.6.2#lib/document/anchor-element', [
    'require',
    'exports',
    'module',
    './element',
    'micro-location',
    '../extend'
], function (require, exports, module) {
    var Element = require('./element');
    var microLocation = require('micro-location');
    var extend = require('../extend');
    const Location = microLocation.Location || microLocation;
    function AnchorElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        Object.defineProperty(this, '_href', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: ''
        });
        extend(this, Location.parse(''));
    }
    AnchorElement.prototype = Object.create(Element.prototype);
    AnchorElement.prototype.constructor = AnchorElement;
    AnchorElement.prototype.elementConstructor = Element;
    AnchorElement.prototype.setAttribute = function (_name, value) {
        Element.prototype.setAttribute.apply(this, arguments);
        if (_name.toLowerCase() === 'href') {
            extend(this, Location.parse(value));
        }
    };
    Object.defineProperty(AnchorElement.prototype, 'href', {
        get: function () {
            return this._href;
        },
        set: function (val) {
            if (val !== this._href) {
                this._href = val;
                this.setAttribute('href', val);
            }
        }
    });
    module.exports = AnchorElement;
});
/*can-simple-dom@1.6.2#lib/document/utils*/
define('can-simple-dom@1.6.2#lib/document/utils', function (require, exports, module) {
    exports.propToAttr = function (Element, name) {
        Object.defineProperty(Element.prototype, name, {
            configurable: true,
            enumerable: true,
            get: function () {
                return this.getAttribute(name);
            },
            set: function (val) {
                this.setAttribute(name, val);
            }
        });
    };
});
/*can-simple-dom@1.6.2#lib/document/input-element*/
define('can-simple-dom@1.6.2#lib/document/input-element', [
    'require',
    'exports',
    'module',
    './element',
    './utils'
], function (require, exports, module) {
    var Element = require('./element');
    var propToAttr = require('./utils').propToAttr;
    function InputElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    InputElement.prototype = Object.create(Element.prototype);
    InputElement.prototype.constructor = InputElement;
    InputElement.prototype.elementConstructor = Element;
    propToAttr(InputElement, 'type');
    propToAttr(InputElement, 'value');
    Object.defineProperty(InputElement.prototype, 'checked', {
        configurable: true,
        enumerable: true,
        get: function () {
            return this.hasAttribute('checked');
        },
        set: function (value) {
            if (value) {
                this.setAttribute('checked', '');
            } else {
                this.removeAttribute('checked');
            }
        }
    });
    module.exports = InputElement;
});
/*can-simple-dom@1.6.2#lib/document/option-element*/
define('can-simple-dom@1.6.2#lib/document/option-element', [
    'require',
    'exports',
    'module',
    './element',
    './utils'
], function (require, exports, module) {
    var Element = require('./element');
    var propToAttr = require('./utils').propToAttr;
    function OptionElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    OptionElement.prototype = Object.create(Element.prototype);
    OptionElement.prototype.constructor = OptionElement;
    OptionElement.prototype.elementConstructor = Element;
    propToAttr(OptionElement, 'value');
    Object.defineProperty(OptionElement.prototype, 'selected', {
        enumerable: true,
        configurable: true,
        get: function () {
            var val = this.value || '';
            var parent = this.parentNode;
            return parent && parent.value == val;
        },
        set: function (val) {
            if (val) {
                var parent = this.parentNode;
                if (parent) {
                    parent.value = this.value;
                }
            }
        }
    });
    module.exports = OptionElement;
});
/*can-simple-dom@1.6.2#lib/document/select-element*/
define('can-simple-dom@1.6.2#lib/document/select-element', [
    'require',
    'exports',
    'module',
    './element',
    './utils'
], function (require, exports, module) {
    var Element = require('./element');
    var propToAttr = require('./utils').propToAttr;
    function SelectElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        this.selectedIndex = 0;
    }
    SelectElement.prototype = Object.create(Element.prototype);
    SelectElement.prototype.constructor = SelectElement;
    SelectElement.prototype.elementConstructor = Element;
    propToAttr(SelectElement, 'value');
    module.exports = SelectElement;
});
/*can-simple-dom@1.6.2#lib/document*/
define('can-simple-dom@1.6.2#lib/document', [
    'require',
    'exports',
    'module',
    './document/node',
    './document/element',
    './document/text',
    './document/comment',
    './document/document-fragment',
    './document/anchor-element',
    './document/input-element',
    './document/option-element',
    './document/select-element'
], function (require, exports, module) {
    var Node = require('./document/node').Node;
    var Element = require('./document/element');
    var Text = require('./document/text');
    var Comment = require('./document/comment');
    var DocumentFragment = require('./document/document-fragment');
    var AnchorElement = require('./document/anchor-element');
    var InputElement = require('./document/input-element');
    var OptionElement = require('./document/option-element');
    var SelectElement = require('./document/select-element');
    var noop = Function.prototype;
    function Document() {
        this.nodeConstructor(9, '#document', null, this);
        var documentElement = new Element('html', this);
        var body = new Element('body', this);
        var head = new Element('head', this);
        documentElement.appendChild(head);
        documentElement.appendChild(body);
        this.appendChild(documentElement);
        var self = this;
        this.implementation = {
            createHTMLDocument: function (content) {
                var document = new Document();
                var frag = self.__parser.parse(content);
                var body = Element.prototype.getElementsByTagName.call(frag, 'body')[0];
                var head = Element.prototype.getElementsByTagName.call(frag, 'head')[0];
                if (!body && !head) {
                    document.body.appendChild(frag);
                } else {
                    if (body) {
                        document.documentElement.replaceChild(body, document.body);
                    }
                    if (head) {
                        document.documentElement.replaceChild(head, document.head);
                    }
                    document.documentElement.appendChild(frag);
                }
                document.__addSerializerAndParser(self.__serializer, self.__parser);
                return document;
            }
        };
    }
    Document.prototype = Object.create(Node.prototype);
    Document.prototype.constructor = Document;
    Document.prototype.nodeConstructor = Node;
    const specialElements = {
        'a': AnchorElement,
        'input': InputElement,
        'option': OptionElement,
        'select': SelectElement
    };
    Document.prototype.createElement = function (tagName) {
        var Special = specialElements[tagName.toLowerCase()];
        if (Special) {
            return new Special(tagName, this);
        }
        return new Element(tagName, this);
    };
    Document.prototype.createTextNode = function (text) {
        return new Text(text, this);
    };
    Document.prototype.createComment = function (text) {
        return new Comment(text, this);
    };
    Document.prototype.createDocumentFragment = function () {
        return new DocumentFragment(this);
    };
    Document.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Document.prototype.getElementById = function (id) {
        return Element.prototype.getElementById.apply(this.documentElement, arguments);
    };
    Document.prototype.__addSerializerAndParser = function (serializer, parser) {
        this.__parser = parser;
        this.__serializer = serializer;
    };
    if (Object.defineProperty) {
        Object.defineProperty(Document.prototype, 'currentScript', {
            get: function () {
                var scripts = this.getElementsByTagName('script');
                var first = scripts[scripts.length - 1];
                if (!first) {
                    first = this.createElement('script');
                }
                return first;
            }
        });
        Object.defineProperty(Document.prototype, 'documentElement', {
            get: function () {
                return this.firstChild;
            },
            set: noop
        });
        function firstOfKind(root, nodeName) {
            if (root == null)
                return null;
            var node = root.firstChild;
            while (node) {
                if (node.nodeName === nodeName) {
                    return node;
                }
                node = node.nextSibling;
            }
            return null;
        }
        [
            'head',
            'body'
        ].forEach(function (localName) {
            var nodeName = localName.toUpperCase();
            Object.defineProperty(Document.prototype, localName, {
                get: function () {
                    return firstOfKind(this.documentElement, nodeName);
                },
                set: noop
            });
        });
    }
    module.exports = Document;
});
/*can-simple-dom@1.6.2#lib/event*/
define('can-simple-dom@1.6.2#lib/event', [
    'require',
    'exports',
    'module',
    './document/node',
    './document'
], function (require, exports, module) {
    var Node = require('./document/node').Node;
    var Document = require('./document');
    var Event = function () {
    };
    Event.prototype.initEvent = function (type, bubbles, cancelable) {
        this.type = type;
        this.bubbles = !!bubbles;
        this.cancelable = !!cancelable;
    };
    Event.prototype.stopPropagation = function () {
        this.isPropagationStopped = true;
    };
    Event.prototype.preventDefault = function () {
        this.isDefaultPrevented = true;
    };
    Document.prototype.createEvent = function (type) {
        return new Event();
    };
    Node.prototype.addEventListener = function (event, handler, capture) {
        if (!this.__handlers) {
            Object.defineProperty(this, '__handlers', {
                value: {},
                enumerable: false
            });
        }
        var phase = capture ? 'capture' : 'bubble';
        var handlersByType = this.__handlers[event + ' ' + phase];
        if (!handlersByType) {
            handlersByType = this.__handlers[event + ' ' + phase] = [];
        }
        if (handlersByType.indexOf(handler) === -1) {
            handlersByType.push(handler);
        }
    };
    Node.prototype.removeEventListener = function (event, handler, capture) {
        if (this.__handlers) {
            var phase = capture ? 'capture' : 'bubble';
            var handlersByType = this.__handlers[event + ' ' + phase];
            if (handlersByType) {
                var index = 0;
                while (index < handlersByType.length) {
                    if (handlersByType[index] === handler) {
                        handlersByType.splice(index, 1);
                    } else {
                        index++;
                    }
                }
            }
        }
    };
    Node.prototype.dispatchEvent = function (event) {
        event.target = this;
        var cur = this;
        var dispatchHandlers = [];
        do {
            var handlers = cur.__handlers && cur.__handlers[event.type + ' bubble'];
            if (handlers) {
                dispatchHandlers.push({
                    node: cur,
                    handlers: handlers
                });
            }
            cur = cur.parentNode;
        } while (event.bubbles && cur);
        for (var i = 0; i < dispatchHandlers.length; i++) {
            var dispatches = dispatchHandlers[i];
            event.currentTarget = dispatches.node;
            for (var h = 0; h < dispatches.handlers.length; h++) {
                var handler = dispatches.handlers[h];
                var res = handler.call(this, event);
                if (res) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (event.isImmediatePropagationStopped) {
                    return !event.isDefaultPrevented;
                }
            }
            if (event.isPropagationStopped) {
                return !event.isDefaultPrevented;
            }
        }
        return !event.isDefaultPrevented;
    };
    module.exports = Event;
});
/*he@1.1.1#he*/
;
(function (root) {
    var freeExports = typeof exports == 'object' && exports;
    var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
    var freeGlobal = typeof global == 'object' && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = {
        '\xAD': 'shy',
        '‌': 'zwnj',
        '‍': 'zwj',
        '\u200E': 'lrm',
        '\u2063': 'ic',
        '\u2062': 'it',
        '\u2061': 'af',
        '\u200F': 'rlm',
        '\u200B': 'ZeroWidthSpace',
        '\u2060': 'NoBreak',
        '̑': 'DownBreve',
        '⃛': 'tdot',
        '⃜': 'DotDot',
        '\t': 'Tab',
        '\n': 'NewLine',
        '\u2008': 'puncsp',
        '\u205F': 'MediumSpace',
        '\u2009': 'thinsp',
        '\u200A': 'hairsp',
        '\u2004': 'emsp13',
        '\u2002': 'ensp',
        '\u2005': 'emsp14',
        '\u2003': 'emsp',
        '\u2007': 'numsp',
        '\xA0': 'nbsp',
        '\u205F\u200A': 'ThickSpace',
        '\u203E': 'oline',
        '_': 'lowbar',
        '\u2010': 'dash',
        '\u2013': 'ndash',
        '\u2014': 'mdash',
        '\u2015': 'horbar',
        ',': 'comma',
        ';': 'semi',
        '\u204F': 'bsemi',
        ':': 'colon',
        '\u2A74': 'Colone',
        '!': 'excl',
        '\xA1': 'iexcl',
        '?': 'quest',
        '\xBF': 'iquest',
        '.': 'period',
        '\u2025': 'nldr',
        '\u2026': 'mldr',
        '\xB7': 'middot',
        '\'': 'apos',
        '\u2018': 'lsquo',
        '\u2019': 'rsquo',
        '\u201A': 'sbquo',
        '\u2039': 'lsaquo',
        '\u203A': 'rsaquo',
        '"': 'quot',
        '\u201C': 'ldquo',
        '\u201D': 'rdquo',
        '\u201E': 'bdquo',
        '\xAB': 'laquo',
        '\xBB': 'raquo',
        '(': 'lpar',
        ')': 'rpar',
        '[': 'lsqb',
        ']': 'rsqb',
        '{': 'lcub',
        '}': 'rcub',
        '\u2308': 'lceil',
        '\u2309': 'rceil',
        '\u230A': 'lfloor',
        '\u230B': 'rfloor',
        '\u2985': 'lopar',
        '\u2986': 'ropar',
        '\u298B': 'lbrke',
        '\u298C': 'rbrke',
        '\u298D': 'lbrkslu',
        '\u298E': 'rbrksld',
        '\u298F': 'lbrksld',
        '\u2990': 'rbrkslu',
        '\u2991': 'langd',
        '\u2992': 'rangd',
        '\u2993': 'lparlt',
        '\u2994': 'rpargt',
        '\u2995': 'gtlPar',
        '\u2996': 'ltrPar',
        '\u27E6': 'lobrk',
        '\u27E7': 'robrk',
        '\u27E8': 'lang',
        '\u27E9': 'rang',
        '\u27EA': 'Lang',
        '\u27EB': 'Rang',
        '\u27EC': 'loang',
        '\u27ED': 'roang',
        '\u2772': 'lbbrk',
        '\u2773': 'rbbrk',
        '\u2016': 'Vert',
        '\xA7': 'sect',
        '\xB6': 'para',
        '@': 'commat',
        '*': 'ast',
        '/': 'sol',
        'undefined': null,
        '&': 'amp',
        '#': 'num',
        '%': 'percnt',
        '\u2030': 'permil',
        '\u2031': 'pertenk',
        '\u2020': 'dagger',
        '\u2021': 'Dagger',
        '\u2022': 'bull',
        '\u2043': 'hybull',
        '\u2032': 'prime',
        '\u2033': 'Prime',
        '\u2034': 'tprime',
        '\u2057': 'qprime',
        '\u2035': 'bprime',
        '\u2041': 'caret',
        '`': 'grave',
        '\xB4': 'acute',
        '\u02DC': 'tilde',
        '^': 'Hat',
        '\xAF': 'macr',
        '\u02D8': 'breve',
        '\u02D9': 'dot',
        '\xA8': 'die',
        '\u02DA': 'ring',
        '\u02DD': 'dblac',
        '\xB8': 'cedil',
        '\u02DB': 'ogon',
        'ˆ': 'circ',
        'ˇ': 'caron',
        '\xB0': 'deg',
        '\xA9': 'copy',
        '\xAE': 'reg',
        '\u2117': 'copysr',
        '\u2118': 'wp',
        '\u211E': 'rx',
        '\u2127': 'mho',
        '\u2129': 'iiota',
        '\u2190': 'larr',
        '\u219A': 'nlarr',
        '\u2192': 'rarr',
        '\u219B': 'nrarr',
        '\u2191': 'uarr',
        '\u2193': 'darr',
        '\u2194': 'harr',
        '\u21AE': 'nharr',
        '\u2195': 'varr',
        '\u2196': 'nwarr',
        '\u2197': 'nearr',
        '\u2198': 'searr',
        '\u2199': 'swarr',
        '\u219D': 'rarrw',
        '\u219D̸': 'nrarrw',
        '\u219E': 'Larr',
        '\u219F': 'Uarr',
        '\u21A0': 'Rarr',
        '\u21A1': 'Darr',
        '\u21A2': 'larrtl',
        '\u21A3': 'rarrtl',
        '\u21A4': 'mapstoleft',
        '\u21A5': 'mapstoup',
        '\u21A6': 'map',
        '\u21A7': 'mapstodown',
        '\u21A9': 'larrhk',
        '\u21AA': 'rarrhk',
        '\u21AB': 'larrlp',
        '\u21AC': 'rarrlp',
        '\u21AD': 'harrw',
        '\u21B0': 'lsh',
        '\u21B1': 'rsh',
        '\u21B2': 'ldsh',
        '\u21B3': 'rdsh',
        '\u21B5': 'crarr',
        '\u21B6': 'cularr',
        '\u21B7': 'curarr',
        '\u21BA': 'olarr',
        '\u21BB': 'orarr',
        '\u21BC': 'lharu',
        '\u21BD': 'lhard',
        '\u21BE': 'uharr',
        '\u21BF': 'uharl',
        '\u21C0': 'rharu',
        '\u21C1': 'rhard',
        '\u21C2': 'dharr',
        '\u21C3': 'dharl',
        '\u21C4': 'rlarr',
        '\u21C5': 'udarr',
        '\u21C6': 'lrarr',
        '\u21C7': 'llarr',
        '\u21C8': 'uuarr',
        '\u21C9': 'rrarr',
        '\u21CA': 'ddarr',
        '\u21CB': 'lrhar',
        '\u21CC': 'rlhar',
        '\u21D0': 'lArr',
        '\u21CD': 'nlArr',
        '\u21D1': 'uArr',
        '\u21D2': 'rArr',
        '\u21CF': 'nrArr',
        '\u21D3': 'dArr',
        '\u21D4': 'iff',
        '\u21CE': 'nhArr',
        '\u21D5': 'vArr',
        '\u21D6': 'nwArr',
        '\u21D7': 'neArr',
        '\u21D8': 'seArr',
        '\u21D9': 'swArr',
        '\u21DA': 'lAarr',
        '\u21DB': 'rAarr',
        '\u21DD': 'zigrarr',
        '\u21E4': 'larrb',
        '\u21E5': 'rarrb',
        '\u21F5': 'duarr',
        '\u21FD': 'loarr',
        '\u21FE': 'roarr',
        '\u21FF': 'hoarr',
        '\u2200': 'forall',
        '\u2201': 'comp',
        '\u2202': 'part',
        '\u2202̸': 'npart',
        '\u2203': 'exist',
        '\u2204': 'nexist',
        '\u2205': 'empty',
        '\u2207': 'Del',
        '\u2208': 'in',
        '\u2209': 'notin',
        '\u220B': 'ni',
        '\u220C': 'notni',
        '\u03F6': 'bepsi',
        '\u220F': 'prod',
        '\u2210': 'coprod',
        '\u2211': 'sum',
        '+': 'plus',
        '\xB1': 'pm',
        '\xF7': 'div',
        '\xD7': 'times',
        '<': 'lt',
        '\u226E': 'nlt',
        '<⃒': 'nvlt',
        '=': 'equals',
        '\u2260': 'ne',
        '=⃥': 'bne',
        '\u2A75': 'Equal',
        '>': 'gt',
        '\u226F': 'ngt',
        '>⃒': 'nvgt',
        '\xAC': 'not',
        '|': 'vert',
        '\xA6': 'brvbar',
        '\u2212': 'minus',
        '\u2213': 'mp',
        '\u2214': 'plusdo',
        '\u2044': 'frasl',
        '\u2216': 'setmn',
        '\u2217': 'lowast',
        '\u2218': 'compfn',
        '\u221A': 'Sqrt',
        '\u221D': 'prop',
        '\u221E': 'infin',
        '\u221F': 'angrt',
        '\u2220': 'ang',
        '\u2220⃒': 'nang',
        '\u2221': 'angmsd',
        '\u2222': 'angsph',
        '\u2223': 'mid',
        '\u2224': 'nmid',
        '\u2225': 'par',
        '\u2226': 'npar',
        '\u2227': 'and',
        '\u2228': 'or',
        '\u2229': 'cap',
        '\u2229︀': 'caps',
        '\u222A': 'cup',
        '\u222A︀': 'cups',
        '\u222B': 'int',
        '\u222C': 'Int',
        '\u222D': 'tint',
        '\u2A0C': 'qint',
        '\u222E': 'oint',
        '\u222F': 'Conint',
        '\u2230': 'Cconint',
        '\u2231': 'cwint',
        '\u2232': 'cwconint',
        '\u2233': 'awconint',
        '\u2234': 'there4',
        '\u2235': 'becaus',
        '\u2236': 'ratio',
        '\u2237': 'Colon',
        '\u2238': 'minusd',
        '\u223A': 'mDDot',
        '\u223B': 'homtht',
        '\u223C': 'sim',
        '\u2241': 'nsim',
        '\u223C⃒': 'nvsim',
        '\u223D': 'bsim',
        '\u223Ḏ': 'race',
        '\u223E': 'ac',
        '\u223E̳': 'acE',
        '\u223F': 'acd',
        '\u2240': 'wr',
        '\u2242': 'esim',
        '\u2242̸': 'nesim',
        '\u2243': 'sime',
        '\u2244': 'nsime',
        '\u2245': 'cong',
        '\u2247': 'ncong',
        '\u2246': 'simne',
        '\u2248': 'ap',
        '\u2249': 'nap',
        '\u224A': 'ape',
        '\u224B': 'apid',
        '\u224B̸': 'napid',
        '\u224C': 'bcong',
        '\u224D': 'CupCap',
        '\u226D': 'NotCupCap',
        '\u224D⃒': 'nvap',
        '\u224E': 'bump',
        '\u224E̸': 'nbump',
        '\u224F': 'bumpe',
        '\u224F̸': 'nbumpe',
        '\u2250': 'doteq',
        '\u2250̸': 'nedot',
        '\u2251': 'eDot',
        '\u2252': 'efDot',
        '\u2253': 'erDot',
        '\u2254': 'colone',
        '\u2255': 'ecolon',
        '\u2256': 'ecir',
        '\u2257': 'cire',
        '\u2259': 'wedgeq',
        '\u225A': 'veeeq',
        '\u225C': 'trie',
        '\u225F': 'equest',
        '\u2261': 'equiv',
        '\u2262': 'nequiv',
        '\u2261⃥': 'bnequiv',
        '\u2264': 'le',
        '\u2270': 'nle',
        '\u2264⃒': 'nvle',
        '\u2265': 'ge',
        '\u2271': 'nge',
        '\u2265⃒': 'nvge',
        '\u2266': 'lE',
        '\u2266̸': 'nlE',
        '\u2267': 'gE',
        '\u2267̸': 'ngE',
        '\u2268︀': 'lvnE',
        '\u2268': 'lnE',
        '\u2269': 'gnE',
        '\u2269︀': 'gvnE',
        '\u226A': 'll',
        '\u226A̸': 'nLtv',
        '\u226A⃒': 'nLt',
        '\u226B': 'gg',
        '\u226B̸': 'nGtv',
        '\u226B⃒': 'nGt',
        '\u226C': 'twixt',
        '\u2272': 'lsim',
        '\u2274': 'nlsim',
        '\u2273': 'gsim',
        '\u2275': 'ngsim',
        '\u2276': 'lg',
        '\u2278': 'ntlg',
        '\u2277': 'gl',
        '\u2279': 'ntgl',
        '\u227A': 'pr',
        '\u2280': 'npr',
        '\u227B': 'sc',
        '\u2281': 'nsc',
        '\u227C': 'prcue',
        '\u22E0': 'nprcue',
        '\u227D': 'sccue',
        '\u22E1': 'nsccue',
        '\u227E': 'prsim',
        '\u227F': 'scsim',
        '\u227F̸': 'NotSucceedsTilde',
        '\u2282': 'sub',
        '\u2284': 'nsub',
        '\u2282⃒': 'vnsub',
        '\u2283': 'sup',
        '\u2285': 'nsup',
        '\u2283⃒': 'vnsup',
        '\u2286': 'sube',
        '\u2288': 'nsube',
        '\u2287': 'supe',
        '\u2289': 'nsupe',
        '\u228A︀': 'vsubne',
        '\u228A': 'subne',
        '\u228B︀': 'vsupne',
        '\u228B': 'supne',
        '\u228D': 'cupdot',
        '\u228E': 'uplus',
        '\u228F': 'sqsub',
        '\u228F̸': 'NotSquareSubset',
        '\u2290': 'sqsup',
        '\u2290̸': 'NotSquareSuperset',
        '\u2291': 'sqsube',
        '\u22E2': 'nsqsube',
        '\u2292': 'sqsupe',
        '\u22E3': 'nsqsupe',
        '\u2293': 'sqcap',
        '\u2293︀': 'sqcaps',
        '\u2294': 'sqcup',
        '\u2294︀': 'sqcups',
        '\u2295': 'oplus',
        '\u2296': 'ominus',
        '\u2297': 'otimes',
        '\u2298': 'osol',
        '\u2299': 'odot',
        '\u229A': 'ocir',
        '\u229B': 'oast',
        '\u229D': 'odash',
        '\u229E': 'plusb',
        '\u229F': 'minusb',
        '\u22A0': 'timesb',
        '\u22A1': 'sdotb',
        '\u22A2': 'vdash',
        '\u22AC': 'nvdash',
        '\u22A3': 'dashv',
        '\u22A4': 'top',
        '\u22A5': 'bot',
        '\u22A7': 'models',
        '\u22A8': 'vDash',
        '\u22AD': 'nvDash',
        '\u22A9': 'Vdash',
        '\u22AE': 'nVdash',
        '\u22AA': 'Vvdash',
        '\u22AB': 'VDash',
        '\u22AF': 'nVDash',
        '\u22B0': 'prurel',
        '\u22B2': 'vltri',
        '\u22EA': 'nltri',
        '\u22B3': 'vrtri',
        '\u22EB': 'nrtri',
        '\u22B4': 'ltrie',
        '\u22EC': 'nltrie',
        '\u22B4⃒': 'nvltrie',
        '\u22B5': 'rtrie',
        '\u22ED': 'nrtrie',
        '\u22B5⃒': 'nvrtrie',
        '\u22B6': 'origof',
        '\u22B7': 'imof',
        '\u22B8': 'mumap',
        '\u22B9': 'hercon',
        '\u22BA': 'intcal',
        '\u22BB': 'veebar',
        '\u22BD': 'barvee',
        '\u22BE': 'angrtvb',
        '\u22BF': 'lrtri',
        '\u22C0': 'Wedge',
        '\u22C1': 'Vee',
        '\u22C2': 'xcap',
        '\u22C3': 'xcup',
        '\u22C4': 'diam',
        '\u22C5': 'sdot',
        '\u22C6': 'Star',
        '\u22C7': 'divonx',
        '\u22C8': 'bowtie',
        '\u22C9': 'ltimes',
        '\u22CA': 'rtimes',
        '\u22CB': 'lthree',
        '\u22CC': 'rthree',
        '\u22CD': 'bsime',
        '\u22CE': 'cuvee',
        '\u22CF': 'cuwed',
        '\u22D0': 'Sub',
        '\u22D1': 'Sup',
        '\u22D2': 'Cap',
        '\u22D3': 'Cup',
        '\u22D4': 'fork',
        '\u22D5': 'epar',
        '\u22D6': 'ltdot',
        '\u22D7': 'gtdot',
        '\u22D8': 'Ll',
        '\u22D8̸': 'nLl',
        '\u22D9': 'Gg',
        '\u22D9̸': 'nGg',
        '\u22DA︀': 'lesg',
        '\u22DA': 'leg',
        '\u22DB': 'gel',
        '\u22DB︀': 'gesl',
        '\u22DE': 'cuepr',
        '\u22DF': 'cuesc',
        '\u22E6': 'lnsim',
        '\u22E7': 'gnsim',
        '\u22E8': 'prnsim',
        '\u22E9': 'scnsim',
        '\u22EE': 'vellip',
        '\u22EF': 'ctdot',
        '\u22F0': 'utdot',
        '\u22F1': 'dtdot',
        '\u22F2': 'disin',
        '\u22F3': 'isinsv',
        '\u22F4': 'isins',
        '\u22F5': 'isindot',
        '\u22F5̸': 'notindot',
        '\u22F6': 'notinvc',
        '\u22F7': 'notinvb',
        '\u22F9': 'isinE',
        '\u22F9̸': 'notinE',
        '\u22FA': 'nisd',
        '\u22FB': 'xnis',
        '\u22FC': 'nis',
        '\u22FD': 'notnivc',
        '\u22FE': 'notnivb',
        '\u2305': 'barwed',
        '\u2306': 'Barwed',
        '\u230C': 'drcrop',
        '\u230D': 'dlcrop',
        '\u230E': 'urcrop',
        '\u230F': 'ulcrop',
        '\u2310': 'bnot',
        '\u2312': 'profline',
        '\u2313': 'profsurf',
        '\u2315': 'telrec',
        '\u2316': 'target',
        '\u231C': 'ulcorn',
        '\u231D': 'urcorn',
        '\u231E': 'dlcorn',
        '\u231F': 'drcorn',
        '\u2322': 'frown',
        '\u2323': 'smile',
        '\u232D': 'cylcty',
        '\u232E': 'profalar',
        '\u2336': 'topbot',
        '\u233D': 'ovbar',
        '\u233F': 'solbar',
        '\u237C': 'angzarr',
        '\u23B0': 'lmoust',
        '\u23B1': 'rmoust',
        '\u23B4': 'tbrk',
        '\u23B5': 'bbrk',
        '\u23B6': 'bbrktbrk',
        '\u23DC': 'OverParenthesis',
        '\u23DD': 'UnderParenthesis',
        '\u23DE': 'OverBrace',
        '\u23DF': 'UnderBrace',
        '\u23E2': 'trpezium',
        '\u23E7': 'elinters',
        '\u2423': 'blank',
        '\u2500': 'boxh',
        '\u2502': 'boxv',
        '\u250C': 'boxdr',
        '\u2510': 'boxdl',
        '\u2514': 'boxur',
        '\u2518': 'boxul',
        '\u251C': 'boxvr',
        '\u2524': 'boxvl',
        '\u252C': 'boxhd',
        '\u2534': 'boxhu',
        '\u253C': 'boxvh',
        '\u2550': 'boxH',
        '\u2551': 'boxV',
        '\u2552': 'boxdR',
        '\u2553': 'boxDr',
        '\u2554': 'boxDR',
        '\u2555': 'boxdL',
        '\u2556': 'boxDl',
        '\u2557': 'boxDL',
        '\u2558': 'boxuR',
        '\u2559': 'boxUr',
        '\u255A': 'boxUR',
        '\u255B': 'boxuL',
        '\u255C': 'boxUl',
        '\u255D': 'boxUL',
        '\u255E': 'boxvR',
        '\u255F': 'boxVr',
        '\u2560': 'boxVR',
        '\u2561': 'boxvL',
        '\u2562': 'boxVl',
        '\u2563': 'boxVL',
        '\u2564': 'boxHd',
        '\u2565': 'boxhD',
        '\u2566': 'boxHD',
        '\u2567': 'boxHu',
        '\u2568': 'boxhU',
        '\u2569': 'boxHU',
        '\u256A': 'boxvH',
        '\u256B': 'boxVh',
        '\u256C': 'boxVH',
        '\u2580': 'uhblk',
        '\u2584': 'lhblk',
        '\u2588': 'block',
        '\u2591': 'blk14',
        '\u2592': 'blk12',
        '\u2593': 'blk34',
        '\u25A1': 'squ',
        '\u25AA': 'squf',
        '\u25AB': 'EmptyVerySmallSquare',
        '\u25AD': 'rect',
        '\u25AE': 'marker',
        '\u25B1': 'fltns',
        '\u25B3': 'xutri',
        '\u25B4': 'utrif',
        '\u25B5': 'utri',
        '\u25B8': 'rtrif',
        '\u25B9': 'rtri',
        '\u25BD': 'xdtri',
        '\u25BE': 'dtrif',
        '\u25BF': 'dtri',
        '\u25C2': 'ltrif',
        '\u25C3': 'ltri',
        '\u25CA': 'loz',
        '\u25CB': 'cir',
        '\u25EC': 'tridot',
        '\u25EF': 'xcirc',
        '\u25F8': 'ultri',
        '\u25F9': 'urtri',
        '\u25FA': 'lltri',
        '\u25FB': 'EmptySmallSquare',
        '\u25FC': 'FilledSmallSquare',
        '\u2605': 'starf',
        '\u2606': 'star',
        '\u260E': 'phone',
        '\u2640': 'female',
        '\u2642': 'male',
        '\u2660': 'spades',
        '\u2663': 'clubs',
        '\u2665': 'hearts',
        '\u2666': 'diams',
        '\u266A': 'sung',
        '\u2713': 'check',
        '\u2717': 'cross',
        '\u2720': 'malt',
        '\u2736': 'sext',
        '\u2758': 'VerticalSeparator',
        '\u27C8': 'bsolhsub',
        '\u27C9': 'suphsol',
        '\u27F5': 'xlarr',
        '\u27F6': 'xrarr',
        '\u27F7': 'xharr',
        '\u27F8': 'xlArr',
        '\u27F9': 'xrArr',
        '\u27FA': 'xhArr',
        '\u27FC': 'xmap',
        '\u27FF': 'dzigrarr',
        '\u2902': 'nvlArr',
        '\u2903': 'nvrArr',
        '\u2904': 'nvHarr',
        '\u2905': 'Map',
        '\u290C': 'lbarr',
        '\u290D': 'rbarr',
        '\u290E': 'lBarr',
        '\u290F': 'rBarr',
        '\u2910': 'RBarr',
        '\u2911': 'DDotrahd',
        '\u2912': 'UpArrowBar',
        '\u2913': 'DownArrowBar',
        '\u2916': 'Rarrtl',
        '\u2919': 'latail',
        '\u291A': 'ratail',
        '\u291B': 'lAtail',
        '\u291C': 'rAtail',
        '\u291D': 'larrfs',
        '\u291E': 'rarrfs',
        '\u291F': 'larrbfs',
        '\u2920': 'rarrbfs',
        '\u2923': 'nwarhk',
        '\u2924': 'nearhk',
        '\u2925': 'searhk',
        '\u2926': 'swarhk',
        '\u2927': 'nwnear',
        '\u2928': 'toea',
        '\u2929': 'tosa',
        '\u292A': 'swnwar',
        '\u2933': 'rarrc',
        '\u2933̸': 'nrarrc',
        '\u2935': 'cudarrr',
        '\u2936': 'ldca',
        '\u2937': 'rdca',
        '\u2938': 'cudarrl',
        '\u2939': 'larrpl',
        '\u293C': 'curarrm',
        '\u293D': 'cularrp',
        '\u2945': 'rarrpl',
        '\u2948': 'harrcir',
        '\u2949': 'Uarrocir',
        '\u294A': 'lurdshar',
        '\u294B': 'ldrushar',
        '\u294E': 'LeftRightVector',
        '\u294F': 'RightUpDownVector',
        '\u2950': 'DownLeftRightVector',
        '\u2951': 'LeftUpDownVector',
        '\u2952': 'LeftVectorBar',
        '\u2953': 'RightVectorBar',
        '\u2954': 'RightUpVectorBar',
        '\u2955': 'RightDownVectorBar',
        '\u2956': 'DownLeftVectorBar',
        '\u2957': 'DownRightVectorBar',
        '\u2958': 'LeftUpVectorBar',
        '\u2959': 'LeftDownVectorBar',
        '\u295A': 'LeftTeeVector',
        '\u295B': 'RightTeeVector',
        '\u295C': 'RightUpTeeVector',
        '\u295D': 'RightDownTeeVector',
        '\u295E': 'DownLeftTeeVector',
        '\u295F': 'DownRightTeeVector',
        '\u2960': 'LeftUpTeeVector',
        '\u2961': 'LeftDownTeeVector',
        '\u2962': 'lHar',
        '\u2963': 'uHar',
        '\u2964': 'rHar',
        '\u2965': 'dHar',
        '\u2966': 'luruhar',
        '\u2967': 'ldrdhar',
        '\u2968': 'ruluhar',
        '\u2969': 'rdldhar',
        '\u296A': 'lharul',
        '\u296B': 'llhard',
        '\u296C': 'rharul',
        '\u296D': 'lrhard',
        '\u296E': 'udhar',
        '\u296F': 'duhar',
        '\u2970': 'RoundImplies',
        '\u2971': 'erarr',
        '\u2972': 'simrarr',
        '\u2973': 'larrsim',
        '\u2974': 'rarrsim',
        '\u2975': 'rarrap',
        '\u2976': 'ltlarr',
        '\u2978': 'gtrarr',
        '\u2979': 'subrarr',
        '\u297B': 'suplarr',
        '\u297C': 'lfisht',
        '\u297D': 'rfisht',
        '\u297E': 'ufisht',
        '\u297F': 'dfisht',
        '\u299A': 'vzigzag',
        '\u299C': 'vangrt',
        '\u299D': 'angrtvbd',
        '\u29A4': 'ange',
        '\u29A5': 'range',
        '\u29A6': 'dwangle',
        '\u29A7': 'uwangle',
        '\u29A8': 'angmsdaa',
        '\u29A9': 'angmsdab',
        '\u29AA': 'angmsdac',
        '\u29AB': 'angmsdad',
        '\u29AC': 'angmsdae',
        '\u29AD': 'angmsdaf',
        '\u29AE': 'angmsdag',
        '\u29AF': 'angmsdah',
        '\u29B0': 'bemptyv',
        '\u29B1': 'demptyv',
        '\u29B2': 'cemptyv',
        '\u29B3': 'raemptyv',
        '\u29B4': 'laemptyv',
        '\u29B5': 'ohbar',
        '\u29B6': 'omid',
        '\u29B7': 'opar',
        '\u29B9': 'operp',
        '\u29BB': 'olcross',
        '\u29BC': 'odsold',
        '\u29BE': 'olcir',
        '\u29BF': 'ofcir',
        '\u29C0': 'olt',
        '\u29C1': 'ogt',
        '\u29C2': 'cirscir',
        '\u29C3': 'cirE',
        '\u29C4': 'solb',
        '\u29C5': 'bsolb',
        '\u29C9': 'boxbox',
        '\u29CD': 'trisb',
        '\u29CE': 'rtriltri',
        '\u29CF': 'LeftTriangleBar',
        '\u29CF̸': 'NotLeftTriangleBar',
        '\u29D0': 'RightTriangleBar',
        '\u29D0̸': 'NotRightTriangleBar',
        '\u29DC': 'iinfin',
        '\u29DD': 'infintie',
        '\u29DE': 'nvinfin',
        '\u29E3': 'eparsl',
        '\u29E4': 'smeparsl',
        '\u29E5': 'eqvparsl',
        '\u29EB': 'lozf',
        '\u29F4': 'RuleDelayed',
        '\u29F6': 'dsol',
        '\u2A00': 'xodot',
        '\u2A01': 'xoplus',
        '\u2A02': 'xotime',
        '\u2A04': 'xuplus',
        '\u2A06': 'xsqcup',
        '\u2A0D': 'fpartint',
        '\u2A10': 'cirfnint',
        '\u2A11': 'awint',
        '\u2A12': 'rppolint',
        '\u2A13': 'scpolint',
        '\u2A14': 'npolint',
        '\u2A15': 'pointint',
        '\u2A16': 'quatint',
        '\u2A17': 'intlarhk',
        '\u2A22': 'pluscir',
        '\u2A23': 'plusacir',
        '\u2A24': 'simplus',
        '\u2A25': 'plusdu',
        '\u2A26': 'plussim',
        '\u2A27': 'plustwo',
        '\u2A29': 'mcomma',
        '\u2A2A': 'minusdu',
        '\u2A2D': 'loplus',
        '\u2A2E': 'roplus',
        '\u2A2F': 'Cross',
        '\u2A30': 'timesd',
        '\u2A31': 'timesbar',
        '\u2A33': 'smashp',
        '\u2A34': 'lotimes',
        '\u2A35': 'rotimes',
        '\u2A36': 'otimesas',
        '\u2A37': 'Otimes',
        '\u2A38': 'odiv',
        '\u2A39': 'triplus',
        '\u2A3A': 'triminus',
        '\u2A3B': 'tritime',
        '\u2A3C': 'iprod',
        '\u2A3F': 'amalg',
        '\u2A40': 'capdot',
        '\u2A42': 'ncup',
        '\u2A43': 'ncap',
        '\u2A44': 'capand',
        '\u2A45': 'cupor',
        '\u2A46': 'cupcap',
        '\u2A47': 'capcup',
        '\u2A48': 'cupbrcap',
        '\u2A49': 'capbrcup',
        '\u2A4A': 'cupcup',
        '\u2A4B': 'capcap',
        '\u2A4C': 'ccups',
        '\u2A4D': 'ccaps',
        '\u2A50': 'ccupssm',
        '\u2A53': 'And',
        '\u2A54': 'Or',
        '\u2A55': 'andand',
        '\u2A56': 'oror',
        '\u2A57': 'orslope',
        '\u2A58': 'andslope',
        '\u2A5A': 'andv',
        '\u2A5B': 'orv',
        '\u2A5C': 'andd',
        '\u2A5D': 'ord',
        '\u2A5F': 'wedbar',
        '\u2A66': 'sdote',
        '\u2A6A': 'simdot',
        '\u2A6D': 'congdot',
        '\u2A6D̸': 'ncongdot',
        '\u2A6E': 'easter',
        '\u2A6F': 'apacir',
        '\u2A70': 'apE',
        '\u2A70̸': 'napE',
        '\u2A71': 'eplus',
        '\u2A72': 'pluse',
        '\u2A73': 'Esim',
        '\u2A77': 'eDDot',
        '\u2A78': 'equivDD',
        '\u2A79': 'ltcir',
        '\u2A7A': 'gtcir',
        '\u2A7B': 'ltquest',
        '\u2A7C': 'gtquest',
        '\u2A7D': 'les',
        '\u2A7D̸': 'nles',
        '\u2A7E': 'ges',
        '\u2A7E̸': 'nges',
        '\u2A7F': 'lesdot',
        '\u2A80': 'gesdot',
        '\u2A81': 'lesdoto',
        '\u2A82': 'gesdoto',
        '\u2A83': 'lesdotor',
        '\u2A84': 'gesdotol',
        '\u2A85': 'lap',
        '\u2A86': 'gap',
        '\u2A87': 'lne',
        '\u2A88': 'gne',
        '\u2A89': 'lnap',
        '\u2A8A': 'gnap',
        '\u2A8B': 'lEg',
        '\u2A8C': 'gEl',
        '\u2A8D': 'lsime',
        '\u2A8E': 'gsime',
        '\u2A8F': 'lsimg',
        '\u2A90': 'gsiml',
        '\u2A91': 'lgE',
        '\u2A92': 'glE',
        '\u2A93': 'lesges',
        '\u2A94': 'gesles',
        '\u2A95': 'els',
        '\u2A96': 'egs',
        '\u2A97': 'elsdot',
        '\u2A98': 'egsdot',
        '\u2A99': 'el',
        '\u2A9A': 'eg',
        '\u2A9D': 'siml',
        '\u2A9E': 'simg',
        '\u2A9F': 'simlE',
        '\u2AA0': 'simgE',
        '\u2AA1': 'LessLess',
        '\u2AA1̸': 'NotNestedLessLess',
        '\u2AA2': 'GreaterGreater',
        '\u2AA2̸': 'NotNestedGreaterGreater',
        '\u2AA4': 'glj',
        '\u2AA5': 'gla',
        '\u2AA6': 'ltcc',
        '\u2AA7': 'gtcc',
        '\u2AA8': 'lescc',
        '\u2AA9': 'gescc',
        '\u2AAA': 'smt',
        '\u2AAB': 'lat',
        '\u2AAC': 'smte',
        '\u2AAC︀': 'smtes',
        '\u2AAD': 'late',
        '\u2AAD︀': 'lates',
        '\u2AAE': 'bumpE',
        '\u2AAF': 'pre',
        '\u2AAF̸': 'npre',
        '\u2AB0': 'sce',
        '\u2AB0̸': 'nsce',
        '\u2AB3': 'prE',
        '\u2AB4': 'scE',
        '\u2AB5': 'prnE',
        '\u2AB6': 'scnE',
        '\u2AB7': 'prap',
        '\u2AB8': 'scap',
        '\u2AB9': 'prnap',
        '\u2ABA': 'scnap',
        '\u2ABB': 'Pr',
        '\u2ABC': 'Sc',
        '\u2ABD': 'subdot',
        '\u2ABE': 'supdot',
        '\u2ABF': 'subplus',
        '\u2AC0': 'supplus',
        '\u2AC1': 'submult',
        '\u2AC2': 'supmult',
        '\u2AC3': 'subedot',
        '\u2AC4': 'supedot',
        '\u2AC5': 'subE',
        '\u2AC5̸': 'nsubE',
        '\u2AC6': 'supE',
        '\u2AC6̸': 'nsupE',
        '\u2AC7': 'subsim',
        '\u2AC8': 'supsim',
        '\u2ACB︀': 'vsubnE',
        '\u2ACB': 'subnE',
        '\u2ACC︀': 'vsupnE',
        '\u2ACC': 'supnE',
        '\u2ACF': 'csub',
        '\u2AD0': 'csup',
        '\u2AD1': 'csube',
        '\u2AD2': 'csupe',
        '\u2AD3': 'subsup',
        '\u2AD4': 'supsub',
        '\u2AD5': 'subsub',
        '\u2AD6': 'supsup',
        '\u2AD7': 'suphsub',
        '\u2AD8': 'supdsub',
        '\u2AD9': 'forkv',
        '\u2ADA': 'topfork',
        '\u2ADB': 'mlcp',
        '\u2AE4': 'Dashv',
        '\u2AE6': 'Vdashl',
        '\u2AE7': 'Barv',
        '\u2AE8': 'vBar',
        '\u2AE9': 'vBarv',
        '\u2AEB': 'Vbar',
        '\u2AEC': 'Not',
        '\u2AED': 'bNot',
        '\u2AEE': 'rnmid',
        '\u2AEF': 'cirmid',
        '\u2AF0': 'midcir',
        '\u2AF1': 'topcir',
        '\u2AF2': 'nhpar',
        '\u2AF3': 'parsim',
        '\u2AFD': 'parsl',
        '\u2AFD⃥': 'nparsl',
        '\u266D': 'flat',
        '\u266E': 'natur',
        '\u266F': 'sharp',
        '\xA4': 'curren',
        '\xA2': 'cent',
        '$': 'dollar',
        '\xA3': 'pound',
        '\xA5': 'yen',
        '\u20AC': 'euro',
        '\xB9': 'sup1',
        '\xBD': 'half',
        '\u2153': 'frac13',
        '\xBC': 'frac14',
        '\u2155': 'frac15',
        '\u2159': 'frac16',
        '\u215B': 'frac18',
        '\xB2': 'sup2',
        '\u2154': 'frac23',
        '\u2156': 'frac25',
        '\xB3': 'sup3',
        '\xBE': 'frac34',
        '\u2157': 'frac35',
        '\u215C': 'frac38',
        '\u2158': 'frac45',
        '\u215A': 'frac56',
        '\u215D': 'frac58',
        '\u215E': 'frac78',
        '\uD835\uDCB6': 'ascr',
        '\uD835\uDD52': 'aopf',
        '\uD835\uDD1E': 'afr',
        '\uD835\uDD38': 'Aopf',
        '\uD835\uDD04': 'Afr',
        '\uD835\uDC9C': 'Ascr',
        'ª': 'ordf',
        'á': 'aacute',
        'Á': 'Aacute',
        'à': 'agrave',
        'À': 'Agrave',
        'ă': 'abreve',
        'Ă': 'Abreve',
        'â': 'acirc',
        'Â': 'Acirc',
        'å': 'aring',
        'Å': 'angst',
        'ä': 'auml',
        'Ä': 'Auml',
        'ã': 'atilde',
        'Ã': 'Atilde',
        'ą': 'aogon',
        'Ą': 'Aogon',
        'ā': 'amacr',
        'Ā': 'Amacr',
        'æ': 'aelig',
        'Æ': 'AElig',
        '\uD835\uDCB7': 'bscr',
        '\uD835\uDD53': 'bopf',
        '\uD835\uDD1F': 'bfr',
        '\uD835\uDD39': 'Bopf',
        'ℬ': 'Bscr',
        '\uD835\uDD05': 'Bfr',
        '\uD835\uDD20': 'cfr',
        '\uD835\uDCB8': 'cscr',
        '\uD835\uDD54': 'copf',
        'ℭ': 'Cfr',
        '\uD835\uDC9E': 'Cscr',
        'ℂ': 'Copf',
        'ć': 'cacute',
        'Ć': 'Cacute',
        'ĉ': 'ccirc',
        'Ĉ': 'Ccirc',
        'č': 'ccaron',
        'Č': 'Ccaron',
        'ċ': 'cdot',
        'Ċ': 'Cdot',
        'ç': 'ccedil',
        'Ç': 'Ccedil',
        '\u2105': 'incare',
        '\uD835\uDD21': 'dfr',
        'ⅆ': 'dd',
        '\uD835\uDD55': 'dopf',
        '\uD835\uDCB9': 'dscr',
        '\uD835\uDC9F': 'Dscr',
        '\uD835\uDD07': 'Dfr',
        'ⅅ': 'DD',
        '\uD835\uDD3B': 'Dopf',
        'ď': 'dcaron',
        'Ď': 'Dcaron',
        'đ': 'dstrok',
        'Đ': 'Dstrok',
        'ð': 'eth',
        'Ð': 'ETH',
        'ⅇ': 'ee',
        'ℯ': 'escr',
        '\uD835\uDD22': 'efr',
        '\uD835\uDD56': 'eopf',
        'ℰ': 'Escr',
        '\uD835\uDD08': 'Efr',
        '\uD835\uDD3C': 'Eopf',
        'é': 'eacute',
        'É': 'Eacute',
        'è': 'egrave',
        'È': 'Egrave',
        'ê': 'ecirc',
        'Ê': 'Ecirc',
        'ě': 'ecaron',
        'Ě': 'Ecaron',
        'ë': 'euml',
        'Ë': 'Euml',
        'ė': 'edot',
        'Ė': 'Edot',
        'ę': 'eogon',
        'Ę': 'Eogon',
        'ē': 'emacr',
        'Ē': 'Emacr',
        '\uD835\uDD23': 'ffr',
        '\uD835\uDD57': 'fopf',
        '\uD835\uDCBB': 'fscr',
        '\uD835\uDD09': 'Ffr',
        '\uD835\uDD3D': 'Fopf',
        'ℱ': 'Fscr',
        'ﬀ': 'fflig',
        'ﬃ': 'ffilig',
        'ﬄ': 'ffllig',
        'ﬁ': 'filig',
        'fj': 'fjlig',
        'ﬂ': 'fllig',
        'ƒ': 'fnof',
        'ℊ': 'gscr',
        '\uD835\uDD58': 'gopf',
        '\uD835\uDD24': 'gfr',
        '\uD835\uDCA2': 'Gscr',
        '\uD835\uDD3E': 'Gopf',
        '\uD835\uDD0A': 'Gfr',
        'ǵ': 'gacute',
        'ğ': 'gbreve',
        'Ğ': 'Gbreve',
        'ĝ': 'gcirc',
        'Ĝ': 'Gcirc',
        'ġ': 'gdot',
        'Ġ': 'Gdot',
        'Ģ': 'Gcedil',
        '\uD835\uDD25': 'hfr',
        'ℎ': 'planckh',
        '\uD835\uDCBD': 'hscr',
        '\uD835\uDD59': 'hopf',
        'ℋ': 'Hscr',
        'ℌ': 'Hfr',
        'ℍ': 'Hopf',
        'ĥ': 'hcirc',
        'Ĥ': 'Hcirc',
        'ℏ': 'hbar',
        'ħ': 'hstrok',
        'Ħ': 'Hstrok',
        '\uD835\uDD5A': 'iopf',
        '\uD835\uDD26': 'ifr',
        '\uD835\uDCBE': 'iscr',
        'ⅈ': 'ii',
        '\uD835\uDD40': 'Iopf',
        'ℐ': 'Iscr',
        'ℑ': 'Im',
        'í': 'iacute',
        'Í': 'Iacute',
        'ì': 'igrave',
        'Ì': 'Igrave',
        'î': 'icirc',
        'Î': 'Icirc',
        'ï': 'iuml',
        'Ï': 'Iuml',
        'ĩ': 'itilde',
        'Ĩ': 'Itilde',
        'İ': 'Idot',
        'į': 'iogon',
        'Į': 'Iogon',
        'ī': 'imacr',
        'Ī': 'Imacr',
        'ĳ': 'ijlig',
        'Ĳ': 'IJlig',
        'ı': 'imath',
        '\uD835\uDCBF': 'jscr',
        '\uD835\uDD5B': 'jopf',
        '\uD835\uDD27': 'jfr',
        '\uD835\uDCA5': 'Jscr',
        '\uD835\uDD0D': 'Jfr',
        '\uD835\uDD41': 'Jopf',
        'ĵ': 'jcirc',
        'Ĵ': 'Jcirc',
        'ȷ': 'jmath',
        '\uD835\uDD5C': 'kopf',
        '\uD835\uDCC0': 'kscr',
        '\uD835\uDD28': 'kfr',
        '\uD835\uDCA6': 'Kscr',
        '\uD835\uDD42': 'Kopf',
        '\uD835\uDD0E': 'Kfr',
        'ķ': 'kcedil',
        'Ķ': 'Kcedil',
        '\uD835\uDD29': 'lfr',
        '\uD835\uDCC1': 'lscr',
        'ℓ': 'ell',
        '\uD835\uDD5D': 'lopf',
        'ℒ': 'Lscr',
        '\uD835\uDD0F': 'Lfr',
        '\uD835\uDD43': 'Lopf',
        'ĺ': 'lacute',
        'Ĺ': 'Lacute',
        'ľ': 'lcaron',
        'Ľ': 'Lcaron',
        'ļ': 'lcedil',
        'Ļ': 'Lcedil',
        'ł': 'lstrok',
        'Ł': 'Lstrok',
        'ŀ': 'lmidot',
        'Ŀ': 'Lmidot',
        '\uD835\uDD2A': 'mfr',
        '\uD835\uDD5E': 'mopf',
        '\uD835\uDCC2': 'mscr',
        '\uD835\uDD10': 'Mfr',
        '\uD835\uDD44': 'Mopf',
        'ℳ': 'Mscr',
        '\uD835\uDD2B': 'nfr',
        '\uD835\uDD5F': 'nopf',
        '\uD835\uDCC3': 'nscr',
        'ℕ': 'Nopf',
        '\uD835\uDCA9': 'Nscr',
        '\uD835\uDD11': 'Nfr',
        'ń': 'nacute',
        'Ń': 'Nacute',
        'ň': 'ncaron',
        'Ň': 'Ncaron',
        'ñ': 'ntilde',
        'Ñ': 'Ntilde',
        'ņ': 'ncedil',
        'Ņ': 'Ncedil',
        '\u2116': 'numero',
        'ŋ': 'eng',
        'Ŋ': 'ENG',
        '\uD835\uDD60': 'oopf',
        '\uD835\uDD2C': 'ofr',
        'ℴ': 'oscr',
        '\uD835\uDCAA': 'Oscr',
        '\uD835\uDD12': 'Ofr',
        '\uD835\uDD46': 'Oopf',
        'º': 'ordm',
        'ó': 'oacute',
        'Ó': 'Oacute',
        'ò': 'ograve',
        'Ò': 'Ograve',
        'ô': 'ocirc',
        'Ô': 'Ocirc',
        'ö': 'ouml',
        'Ö': 'Ouml',
        'ő': 'odblac',
        'Ő': 'Odblac',
        'õ': 'otilde',
        'Õ': 'Otilde',
        'ø': 'oslash',
        'Ø': 'Oslash',
        'ō': 'omacr',
        'Ō': 'Omacr',
        'œ': 'oelig',
        'Œ': 'OElig',
        '\uD835\uDD2D': 'pfr',
        '\uD835\uDCC5': 'pscr',
        '\uD835\uDD61': 'popf',
        'ℙ': 'Popf',
        '\uD835\uDD13': 'Pfr',
        '\uD835\uDCAB': 'Pscr',
        '\uD835\uDD62': 'qopf',
        '\uD835\uDD2E': 'qfr',
        '\uD835\uDCC6': 'qscr',
        '\uD835\uDCAC': 'Qscr',
        '\uD835\uDD14': 'Qfr',
        'ℚ': 'Qopf',
        'ĸ': 'kgreen',
        '\uD835\uDD2F': 'rfr',
        '\uD835\uDD63': 'ropf',
        '\uD835\uDCC7': 'rscr',
        'ℛ': 'Rscr',
        'ℜ': 'Re',
        'ℝ': 'Ropf',
        'ŕ': 'racute',
        'Ŕ': 'Racute',
        'ř': 'rcaron',
        'Ř': 'Rcaron',
        'ŗ': 'rcedil',
        'Ŗ': 'Rcedil',
        '\uD835\uDD64': 'sopf',
        '\uD835\uDCC8': 'sscr',
        '\uD835\uDD30': 'sfr',
        '\uD835\uDD4A': 'Sopf',
        '\uD835\uDD16': 'Sfr',
        '\uD835\uDCAE': 'Sscr',
        '\u24C8': 'oS',
        'ś': 'sacute',
        'Ś': 'Sacute',
        'ŝ': 'scirc',
        'Ŝ': 'Scirc',
        'š': 'scaron',
        'Š': 'Scaron',
        'ş': 'scedil',
        'Ş': 'Scedil',
        'ß': 'szlig',
        '\uD835\uDD31': 'tfr',
        '\uD835\uDCC9': 'tscr',
        '\uD835\uDD65': 'topf',
        '\uD835\uDCAF': 'Tscr',
        '\uD835\uDD17': 'Tfr',
        '\uD835\uDD4B': 'Topf',
        'ť': 'tcaron',
        'Ť': 'Tcaron',
        'ţ': 'tcedil',
        'Ţ': 'Tcedil',
        '\u2122': 'trade',
        'ŧ': 'tstrok',
        'Ŧ': 'Tstrok',
        '\uD835\uDCCA': 'uscr',
        '\uD835\uDD66': 'uopf',
        '\uD835\uDD32': 'ufr',
        '\uD835\uDD4C': 'Uopf',
        '\uD835\uDD18': 'Ufr',
        '\uD835\uDCB0': 'Uscr',
        'ú': 'uacute',
        'Ú': 'Uacute',
        'ù': 'ugrave',
        'Ù': 'Ugrave',
        'ŭ': 'ubreve',
        'Ŭ': 'Ubreve',
        'û': 'ucirc',
        'Û': 'Ucirc',
        'ů': 'uring',
        'Ů': 'Uring',
        'ü': 'uuml',
        'Ü': 'Uuml',
        'ű': 'udblac',
        'Ű': 'Udblac',
        'ũ': 'utilde',
        'Ũ': 'Utilde',
        'ų': 'uogon',
        'Ų': 'Uogon',
        'ū': 'umacr',
        'Ū': 'Umacr',
        '\uD835\uDD33': 'vfr',
        '\uD835\uDD67': 'vopf',
        '\uD835\uDCCB': 'vscr',
        '\uD835\uDD19': 'Vfr',
        '\uD835\uDD4D': 'Vopf',
        '\uD835\uDCB1': 'Vscr',
        '\uD835\uDD68': 'wopf',
        '\uD835\uDCCC': 'wscr',
        '\uD835\uDD34': 'wfr',
        '\uD835\uDCB2': 'Wscr',
        '\uD835\uDD4E': 'Wopf',
        '\uD835\uDD1A': 'Wfr',
        'ŵ': 'wcirc',
        'Ŵ': 'Wcirc',
        '\uD835\uDD35': 'xfr',
        '\uD835\uDCCD': 'xscr',
        '\uD835\uDD69': 'xopf',
        '\uD835\uDD4F': 'Xopf',
        '\uD835\uDD1B': 'Xfr',
        '\uD835\uDCB3': 'Xscr',
        '\uD835\uDD36': 'yfr',
        '\uD835\uDCCE': 'yscr',
        '\uD835\uDD6A': 'yopf',
        '\uD835\uDCB4': 'Yscr',
        '\uD835\uDD1C': 'Yfr',
        '\uD835\uDD50': 'Yopf',
        'ý': 'yacute',
        'Ý': 'Yacute',
        'ŷ': 'ycirc',
        'Ŷ': 'Ycirc',
        'ÿ': 'yuml',
        'Ÿ': 'Yuml',
        '\uD835\uDCCF': 'zscr',
        '\uD835\uDD37': 'zfr',
        '\uD835\uDD6B': 'zopf',
        'ℨ': 'Zfr',
        'ℤ': 'Zopf',
        '\uD835\uDCB5': 'Zscr',
        'ź': 'zacute',
        'Ź': 'Zacute',
        'ž': 'zcaron',
        'Ž': 'Zcaron',
        'ż': 'zdot',
        'Ż': 'Zdot',
        'Ƶ': 'imped',
        'þ': 'thorn',
        'Þ': 'THORN',
        'ŉ': 'napos',
        'α': 'alpha',
        'Α': 'Alpha',
        'β': 'beta',
        'Β': 'Beta',
        'γ': 'gamma',
        'Γ': 'Gamma',
        'δ': 'delta',
        'Δ': 'Delta',
        'ε': 'epsi',
        'ϵ': 'epsiv',
        'Ε': 'Epsilon',
        'ϝ': 'gammad',
        'Ϝ': 'Gammad',
        'ζ': 'zeta',
        'Ζ': 'Zeta',
        'η': 'eta',
        'Η': 'Eta',
        'θ': 'theta',
        'ϑ': 'thetav',
        'Θ': 'Theta',
        'ι': 'iota',
        'Ι': 'Iota',
        'κ': 'kappa',
        'ϰ': 'kappav',
        'Κ': 'Kappa',
        'λ': 'lambda',
        'Λ': 'Lambda',
        'μ': 'mu',
        'µ': 'micro',
        'Μ': 'Mu',
        'ν': 'nu',
        'Ν': 'Nu',
        'ξ': 'xi',
        'Ξ': 'Xi',
        'ο': 'omicron',
        'Ο': 'Omicron',
        'π': 'pi',
        'ϖ': 'piv',
        'Π': 'Pi',
        'ρ': 'rho',
        'ϱ': 'rhov',
        'Ρ': 'Rho',
        'σ': 'sigma',
        'Σ': 'Sigma',
        'ς': 'sigmaf',
        'τ': 'tau',
        'Τ': 'Tau',
        'υ': 'upsi',
        'Υ': 'Upsilon',
        'ϒ': 'Upsi',
        'φ': 'phi',
        'ϕ': 'phiv',
        'Φ': 'Phi',
        'χ': 'chi',
        'Χ': 'Chi',
        'ψ': 'psi',
        'Ψ': 'Psi',
        'ω': 'omega',
        'Ω': 'ohm',
        'а': 'acy',
        'А': 'Acy',
        'б': 'bcy',
        'Б': 'Bcy',
        'в': 'vcy',
        'В': 'Vcy',
        'г': 'gcy',
        'Г': 'Gcy',
        'ѓ': 'gjcy',
        'Ѓ': 'GJcy',
        'д': 'dcy',
        'Д': 'Dcy',
        'ђ': 'djcy',
        'Ђ': 'DJcy',
        'е': 'iecy',
        'Е': 'IEcy',
        'ё': 'iocy',
        'Ё': 'IOcy',
        'є': 'jukcy',
        'Є': 'Jukcy',
        'ж': 'zhcy',
        'Ж': 'ZHcy',
        'з': 'zcy',
        'З': 'Zcy',
        'ѕ': 'dscy',
        'Ѕ': 'DScy',
        'и': 'icy',
        'И': 'Icy',
        'і': 'iukcy',
        'І': 'Iukcy',
        'ї': 'yicy',
        'Ї': 'YIcy',
        'й': 'jcy',
        'Й': 'Jcy',
        'ј': 'jsercy',
        'Ј': 'Jsercy',
        'к': 'kcy',
        'К': 'Kcy',
        'ќ': 'kjcy',
        'Ќ': 'KJcy',
        'л': 'lcy',
        'Л': 'Lcy',
        'љ': 'ljcy',
        'Љ': 'LJcy',
        'м': 'mcy',
        'М': 'Mcy',
        'н': 'ncy',
        'Н': 'Ncy',
        'њ': 'njcy',
        'Њ': 'NJcy',
        'о': 'ocy',
        'О': 'Ocy',
        'п': 'pcy',
        'П': 'Pcy',
        'р': 'rcy',
        'Р': 'Rcy',
        'с': 'scy',
        'С': 'Scy',
        'т': 'tcy',
        'Т': 'Tcy',
        'ћ': 'tshcy',
        'Ћ': 'TSHcy',
        'у': 'ucy',
        'У': 'Ucy',
        'ў': 'ubrcy',
        'Ў': 'Ubrcy',
        'ф': 'fcy',
        'Ф': 'Fcy',
        'х': 'khcy',
        'Х': 'KHcy',
        'ц': 'tscy',
        'Ц': 'TScy',
        'ч': 'chcy',
        'Ч': 'CHcy',
        'џ': 'dzcy',
        'Џ': 'DZcy',
        'ш': 'shcy',
        'Ш': 'SHcy',
        'щ': 'shchcy',
        'Щ': 'SHCHcy',
        'ъ': 'hardcy',
        'Ъ': 'HARDcy',
        'ы': 'ycy',
        'Ы': 'Ycy',
        'ь': 'softcy',
        'Ь': 'SOFTcy',
        'э': 'ecy',
        'Э': 'Ecy',
        'ю': 'yucy',
        'Ю': 'YUcy',
        'я': 'yacy',
        'Я': 'YAcy',
        'ℵ': 'aleph',
        'ℶ': 'beth',
        'ℷ': 'gimel',
        'ℸ': 'daleth'
    };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
        '>': '&gt;',
        '`': '&#x60;'
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;
    var decodeMap = {
        'aacute': 'á',
        'Aacute': 'Á',
        'abreve': 'ă',
        'Abreve': 'Ă',
        'ac': '\u223E',
        'acd': '\u223F',
        'acE': '\u223E̳',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'acy': 'а',
        'Acy': 'А',
        'aelig': 'æ',
        'AElig': 'Æ',
        'af': '\u2061',
        'afr': '\uD835\uDD1E',
        'Afr': '\uD835\uDD04',
        'agrave': 'à',
        'Agrave': 'À',
        'alefsym': 'ℵ',
        'aleph': 'ℵ',
        'alpha': 'α',
        'Alpha': 'Α',
        'amacr': 'ā',
        'Amacr': 'Ā',
        'amalg': '\u2A3F',
        'amp': '&',
        'AMP': '&',
        'and': '\u2227',
        'And': '\u2A53',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'ange': '\u29A4',
        'angle': '\u2220',
        'angmsd': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angst': 'Å',
        'angzarr': '\u237C',
        'aogon': 'ą',
        'Aogon': 'Ą',
        'aopf': '\uD835\uDD52',
        'Aopf': '\uD835\uDD38',
        'ap': '\u2248',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'apE': '\u2A70',
        'apid': '\u224B',
        'apos': '\'',
        'ApplyFunction': '\u2061',
        'approx': '\u2248',
        'approxeq': '\u224A',
        'aring': 'å',
        'Aring': 'Å',
        'ascr': '\uD835\uDCB6',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'ast': '*',
        'asymp': '\u2248',
        'asympeq': '\u224D',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'awconint': '\u2233',
        'awint': '\u2A11',
        'backcong': '\u224C',
        'backepsilon': '\u03F6',
        'backprime': '\u2035',
        'backsim': '\u223D',
        'backsimeq': '\u22CD',
        'Backslash': '\u2216',
        'Barv': '\u2AE7',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'Barwed': '\u2306',
        'barwedge': '\u2305',
        'bbrk': '\u23B5',
        'bbrktbrk': '\u23B6',
        'bcong': '\u224C',
        'bcy': 'б',
        'Bcy': 'Б',
        'bdquo': '\u201E',
        'becaus': '\u2235',
        'because': '\u2235',
        'Because': '\u2235',
        'bemptyv': '\u29B0',
        'bepsi': '\u03F6',
        'bernou': 'ℬ',
        'Bernoullis': 'ℬ',
        'beta': 'β',
        'Beta': 'Β',
        'beth': 'ℶ',
        'between': '\u226C',
        'bfr': '\uD835\uDD1F',
        'Bfr': '\uD835\uDD05',
        'bigcap': '\u22C2',
        'bigcirc': '\u25EF',
        'bigcup': '\u22C3',
        'bigodot': '\u2A00',
        'bigoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'bigsqcup': '\u2A06',
        'bigstar': '\u2605',
        'bigtriangledown': '\u25BD',
        'bigtriangleup': '\u25B3',
        'biguplus': '\u2A04',
        'bigvee': '\u22C1',
        'bigwedge': '\u22C0',
        'bkarow': '\u290D',
        'blacklozenge': '\u29EB',
        'blacksquare': '\u25AA',
        'blacktriangle': '\u25B4',
        'blacktriangledown': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'blacktriangleright': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '=⃥',
        'bnequiv': '\u2261⃥',
        'bnot': '\u2310',
        'bNot': '\u2AED',
        'bopf': '\uD835\uDD53',
        'Bopf': '\uD835\uDD39',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'bowtie': '\u22C8',
        'boxbox': '\u29C9',
        'boxdl': '\u2510',
        'boxdL': '\u2555',
        'boxDl': '\u2556',
        'boxDL': '\u2557',
        'boxdr': '\u250C',
        'boxdR': '\u2552',
        'boxDr': '\u2553',
        'boxDR': '\u2554',
        'boxh': '\u2500',
        'boxH': '\u2550',
        'boxhd': '\u252C',
        'boxhD': '\u2565',
        'boxHd': '\u2564',
        'boxHD': '\u2566',
        'boxhu': '\u2534',
        'boxhU': '\u2568',
        'boxHu': '\u2567',
        'boxHU': '\u2569',
        'boxminus': '\u229F',
        'boxplus': '\u229E',
        'boxtimes': '\u22A0',
        'boxul': '\u2518',
        'boxuL': '\u255B',
        'boxUl': '\u255C',
        'boxUL': '\u255D',
        'boxur': '\u2514',
        'boxuR': '\u2558',
        'boxUr': '\u2559',
        'boxUR': '\u255A',
        'boxv': '\u2502',
        'boxV': '\u2551',
        'boxvh': '\u253C',
        'boxvH': '\u256A',
        'boxVh': '\u256B',
        'boxVH': '\u256C',
        'boxvl': '\u2524',
        'boxvL': '\u2561',
        'boxVl': '\u2562',
        'boxVL': '\u2563',
        'boxvr': '\u251C',
        'boxvR': '\u255E',
        'boxVr': '\u255F',
        'boxVR': '\u2560',
        'bprime': '\u2035',
        'breve': '\u02D8',
        'Breve': '\u02D8',
        'brvbar': '\xA6',
        'bscr': '\uD835\uDCB7',
        'Bscr': 'ℬ',
        'bsemi': '\u204F',
        'bsim': '\u223D',
        'bsime': '\u22CD',
        'bsol': '\\',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bump': '\u224E',
        'bumpe': '\u224F',
        'bumpE': '\u2AAE',
        'bumpeq': '\u224F',
        'Bumpeq': '\u224E',
        'cacute': 'ć',
        'Cacute': 'Ć',
        'cap': '\u2229',
        'Cap': '\u22D2',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'CapitalDifferentialD': 'ⅅ',
        'caps': '\u2229︀',
        'caret': '\u2041',
        'caron': 'ˇ',
        'Cayleys': 'ℭ',
        'ccaps': '\u2A4D',
        'ccaron': 'č',
        'Ccaron': 'Č',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'ccirc': 'ĉ',
        'Ccirc': 'Ĉ',
        'Cconint': '\u2230',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': 'ċ',
        'Cdot': 'Ċ',
        'cedil': '\xB8',
        'Cedilla': '\xB8',
        'cemptyv': '\u29B2',
        'cent': '\xA2',
        'centerdot': '\xB7',
        'CenterDot': '\xB7',
        'cfr': '\uD835\uDD20',
        'Cfr': 'ℭ',
        'chcy': 'ч',
        'CHcy': 'Ч',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': 'χ',
        'Chi': 'Χ',
        'cir': '\u25CB',
        'circ': 'ˆ',
        'circeq': '\u2257',
        'circlearrowleft': '\u21BA',
        'circlearrowright': '\u21BB',
        'circledast': '\u229B',
        'circledcirc': '\u229A',
        'circleddash': '\u229D',
        'CircleDot': '\u2299',
        'circledR': '\xAE',
        'circledS': '\u24C8',
        'CircleMinus': '\u2296',
        'CirclePlus': '\u2295',
        'CircleTimes': '\u2297',
        'cire': '\u2257',
        'cirE': '\u29C3',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'ClockwiseContourIntegral': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': ':',
        'Colon': '\u2237',
        'colone': '\u2254',
        'Colone': '\u2A74',
        'coloneq': '\u2254',
        'comma': ',',
        'commat': '@',
        'comp': '\u2201',
        'compfn': '\u2218',
        'complement': '\u2201',
        'complexes': 'ℂ',
        'cong': '\u2245',
        'congdot': '\u2A6D',
        'Congruent': '\u2261',
        'conint': '\u222E',
        'Conint': '\u222F',
        'ContourIntegral': '\u222E',
        'copf': '\uD835\uDD54',
        'Copf': 'ℂ',
        'coprod': '\u2210',
        'Coproduct': '\u2210',
        'copy': '\xA9',
        'COPY': '\xA9',
        'copysr': '\u2117',
        'CounterClockwiseContourIntegral': '\u2233',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'Cross': '\u2A2F',
        'cscr': '\uD835\uDCB8',
        'Cscr': '\uD835\uDC9E',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'cuesc': '\u22DF',
        'cularr': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'Cup': '\u22D3',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'CupCap': '\u224D',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A︀',
        'curarr': '\u21B7',
        'curarrm': '\u293C',
        'curlyeqprec': '\u22DE',
        'curlyeqsucc': '\u22DF',
        'curlyvee': '\u22CE',
        'curlywedge': '\u22CF',
        'curren': '\xA4',
        'curvearrowleft': '\u21B6',
        'curvearrowright': '\u21B7',
        'cuvee': '\u22CE',
        'cuwed': '\u22CF',
        'cwconint': '\u2232',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'daleth': 'ℸ',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'Darr': '\u21A1',
        'dash': '\u2010',
        'dashv': '\u22A3',
        'Dashv': '\u2AE4',
        'dbkarow': '\u290F',
        'dblac': '\u02DD',
        'dcaron': 'ď',
        'Dcaron': 'Ď',
        'dcy': 'д',
        'Dcy': 'Д',
        'dd': 'ⅆ',
        'DD': 'ⅅ',
        'ddagger': '\u2021',
        'ddarr': '\u21CA',
        'DDotrahd': '\u2911',
        'ddotseq': '\u2A77',
        'deg': '\xB0',
        'Del': '\u2207',
        'delta': 'δ',
        'Delta': 'Δ',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'Dfr': '\uD835\uDD07',
        'dHar': '\u2965',
        'dharl': '\u21C3',
        'dharr': '\u21C2',
        'DiacriticalAcute': '\xB4',
        'DiacriticalDot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'DiacriticalGrave': '`',
        'DiacriticalTilde': '\u02DC',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'Diamond': '\u22C4',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'die': '\xA8',
        'DifferentialD': 'ⅆ',
        'digamma': 'ϝ',
        'disin': '\u22F2',
        'div': '\xF7',
        'divide': '\xF7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': 'ђ',
        'DJcy': 'Ђ',
        'dlcorn': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '$',
        'dopf': '\uD835\uDD55',
        'Dopf': '\uD835\uDD3B',
        'dot': '\u02D9',
        'Dot': '\xA8',
        'DotDot': '⃜',
        'doteq': '\u2250',
        'doteqdot': '\u2251',
        'DotEqual': '\u2250',
        'dotminus': '\u2238',
        'dotplus': '\u2214',
        'dotsquare': '\u22A1',
        'doublebarwedge': '\u2306',
        'DoubleContourIntegral': '\u222F',
        'DoubleDot': '\xA8',
        'DoubleDownArrow': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'DoubleLeftTee': '\u2AE4',
        'DoubleLongLeftArrow': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'downarrow': '\u2193',
        'Downarrow': '\u21D3',
        'DownArrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'DownBreve': '̑',
        'downdownarrows': '\u21CA',
        'downharpoonleft': '\u21C3',
        'downharpoonright': '\u21C2',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'drbkarow': '\u2910',
        'drcorn': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'Dscr': '\uD835\uDC9F',
        'dscy': 'ѕ',
        'DScy': 'Ѕ',
        'dsol': '\u29F6',
        'dstrok': 'đ',
        'Dstrok': 'Đ',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'dtrif': '\u25BE',
        'duarr': '\u21F5',
        'duhar': '\u296F',
        'dwangle': '\u29A6',
        'dzcy': 'џ',
        'DZcy': 'Џ',
        'dzigrarr': '\u27FF',
        'eacute': 'é',
        'Eacute': 'É',
        'easter': '\u2A6E',
        'ecaron': 'ě',
        'Ecaron': 'Ě',
        'ecir': '\u2256',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'ecolon': '\u2255',
        'ecy': 'э',
        'Ecy': 'Э',
        'eDDot': '\u2A77',
        'edot': 'ė',
        'eDot': '\u2251',
        'Edot': 'Ė',
        'ee': 'ⅇ',
        'efDot': '\u2252',
        'efr': '\uD835\uDD22',
        'Efr': '\uD835\uDD08',
        'eg': '\u2A9A',
        'egrave': 'è',
        'Egrave': 'È',
        'egs': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'Element': '\u2208',
        'elinters': '\u23E7',
        'ell': 'ℓ',
        'els': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': 'ē',
        'Emacr': 'Ē',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'EmptySmallSquare': '\u25FB',
        'emptyv': '\u2205',
        'EmptyVerySmallSquare': '\u25AB',
        'emsp': '\u2003',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'eng': 'ŋ',
        'ENG': 'Ŋ',
        'ensp': '\u2002',
        'eogon': 'ę',
        'Eogon': 'Ę',
        'eopf': '\uD835\uDD56',
        'Eopf': '\uD835\uDD3C',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': 'ε',
        'epsilon': 'ε',
        'Epsilon': 'Ε',
        'epsiv': 'ϵ',
        'eqcirc': '\u2256',
        'eqcolon': '\u2255',
        'eqsim': '\u2242',
        'eqslantgtr': '\u2A96',
        'eqslantless': '\u2A95',
        'Equal': '\u2A75',
        'equals': '=',
        'EqualTilde': '\u2242',
        'equest': '\u225F',
        'Equilibrium': '\u21CC',
        'equiv': '\u2261',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erarr': '\u2971',
        'erDot': '\u2253',
        'escr': 'ℯ',
        'Escr': 'ℰ',
        'esdot': '\u2250',
        'esim': '\u2242',
        'Esim': '\u2A73',
        'eta': 'η',
        'Eta': 'Η',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'euro': '\u20AC',
        'excl': '!',
        'exist': '\u2203',
        'Exists': '\u2203',
        'expectation': 'ℰ',
        'exponentiale': 'ⅇ',
        'ExponentialE': 'ⅇ',
        'fallingdotseq': '\u2252',
        'fcy': 'ф',
        'Fcy': 'Ф',
        'female': '\u2640',
        'ffilig': 'ﬃ',
        'fflig': 'ﬀ',
        'ffllig': 'ﬄ',
        'ffr': '\uD835\uDD23',
        'Ffr': '\uD835\uDD09',
        'filig': 'ﬁ',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'fjlig': 'fj',
        'flat': '\u266D',
        'fllig': 'ﬂ',
        'fltns': '\u25B1',
        'fnof': 'ƒ',
        'fopf': '\uD835\uDD57',
        'Fopf': '\uD835\uDD3D',
        'forall': '\u2200',
        'ForAll': '\u2200',
        'fork': '\u22D4',
        'forkv': '\u2AD9',
        'Fouriertrf': 'ℱ',
        'fpartint': '\u2A0D',
        'frac12': '\xBD',
        'frac13': '\u2153',
        'frac14': '\xBC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\xBE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'Fscr': 'ℱ',
        'gacute': 'ǵ',
        'gamma': 'γ',
        'Gamma': 'Γ',
        'gammad': 'ϝ',
        'Gammad': 'Ϝ',
        'gap': '\u2A86',
        'gbreve': 'ğ',
        'Gbreve': 'Ğ',
        'Gcedil': 'Ģ',
        'gcirc': 'ĝ',
        'Gcirc': 'Ĝ',
        'gcy': 'г',
        'Gcy': 'Г',
        'gdot': 'ġ',
        'Gdot': 'Ġ',
        'ge': '\u2265',
        'gE': '\u2267',
        'gel': '\u22DB',
        'gEl': '\u2A8C',
        'geq': '\u2265',
        'geqq': '\u2267',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB︀',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'Gfr': '\uD835\uDD0A',
        'gg': '\u226B',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'gimel': 'ℷ',
        'gjcy': 'ѓ',
        'GJcy': 'Ѓ',
        'gl': '\u2277',
        'gla': '\u2AA5',
        'glE': '\u2A92',
        'glj': '\u2AA4',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gnE': '\u2269',
        'gneq': '\u2A88',
        'gneqq': '\u2269',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'Gopf': '\uD835\uDD3E',
        'grave': '`',
        'GreaterEqual': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gscr': 'ℊ',
        'Gscr': '\uD835\uDCA2',
        'gsim': '\u2273',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gt': '>',
        'Gt': '\u226B',
        'GT': '>',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrapprox': '\u2A86',
        'gtrarr': '\u2978',
        'gtrdot': '\u22D7',
        'gtreqless': '\u22DB',
        'gtreqqless': '\u2A8C',
        'gtrless': '\u2277',
        'gtrsim': '\u2273',
        'gvertneqq': '\u2269︀',
        'gvnE': '\u2269︀',
        'Hacek': 'ˇ',
        'hairsp': '\u200A',
        'half': '\xBD',
        'hamilt': 'ℋ',
        'hardcy': 'ъ',
        'HARDcy': 'Ъ',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'Hat': '^',
        'hbar': 'ℏ',
        'hcirc': 'ĥ',
        'Hcirc': 'Ĥ',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'Hfr': 'ℌ',
        'HilbertSpace': 'ℋ',
        'hksearow': '\u2925',
        'hkswarow': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'hookrightarrow': '\u21AA',
        'hopf': '\uD835\uDD59',
        'Hopf': 'ℍ',
        'horbar': '\u2015',
        'HorizontalLine': '\u2500',
        'hscr': '\uD835\uDCBD',
        'Hscr': 'ℋ',
        'hslash': 'ℏ',
        'hstrok': 'ħ',
        'Hstrok': 'Ħ',
        'HumpDownHump': '\u224E',
        'HumpEqual': '\u224F',
        'hybull': '\u2043',
        'hyphen': '\u2010',
        'iacute': 'í',
        'Iacute': 'Í',
        'ic': '\u2063',
        'icirc': 'î',
        'Icirc': 'Î',
        'icy': 'и',
        'Icy': 'И',
        'Idot': 'İ',
        'iecy': 'е',
        'IEcy': 'Е',
        'iexcl': '\xA1',
        'iff': '\u21D4',
        'ifr': '\uD835\uDD26',
        'Ifr': 'ℑ',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'ii': 'ⅈ',
        'iiiint': '\u2A0C',
        'iiint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': 'ĳ',
        'IJlig': 'Ĳ',
        'Im': 'ℑ',
        'imacr': 'ī',
        'Imacr': 'Ī',
        'image': 'ℑ',
        'ImaginaryI': 'ⅈ',
        'imagline': 'ℐ',
        'imagpart': 'ℑ',
        'imath': 'ı',
        'imof': '\u22B7',
        'imped': 'Ƶ',
        'Implies': '\u21D2',
        'in': '\u2208',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'inodot': 'ı',
        'int': '\u222B',
        'Int': '\u222C',
        'intcal': '\u22BA',
        'integers': 'ℤ',
        'Integral': '\u222B',
        'intercal': '\u22BA',
        'Intersection': '\u22C2',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'InvisibleComma': '\u2063',
        'InvisibleTimes': '\u2062',
        'iocy': 'ё',
        'IOcy': 'Ё',
        'iogon': 'į',
        'Iogon': 'Į',
        'iopf': '\uD835\uDD5A',
        'Iopf': '\uD835\uDD40',
        'iota': 'ι',
        'Iota': 'Ι',
        'iprod': '\u2A3C',
        'iquest': '\xBF',
        'iscr': '\uD835\uDCBE',
        'Iscr': 'ℐ',
        'isin': '\u2208',
        'isindot': '\u22F5',
        'isinE': '\u22F9',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'isinv': '\u2208',
        'it': '\u2062',
        'itilde': 'ĩ',
        'Itilde': 'Ĩ',
        'iukcy': 'і',
        'Iukcy': 'І',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'jcirc': 'ĵ',
        'Jcirc': 'Ĵ',
        'jcy': 'й',
        'Jcy': 'Й',
        'jfr': '\uD835\uDD27',
        'Jfr': '\uD835\uDD0D',
        'jmath': 'ȷ',
        'jopf': '\uD835\uDD5B',
        'Jopf': '\uD835\uDD41',
        'jscr': '\uD835\uDCBF',
        'Jscr': '\uD835\uDCA5',
        'jsercy': 'ј',
        'Jsercy': 'Ј',
        'jukcy': 'є',
        'Jukcy': 'Є',
        'kappa': 'κ',
        'Kappa': 'Κ',
        'kappav': 'ϰ',
        'kcedil': 'ķ',
        'Kcedil': 'Ķ',
        'kcy': 'к',
        'Kcy': 'К',
        'kfr': '\uD835\uDD28',
        'Kfr': '\uD835\uDD0E',
        'kgreen': 'ĸ',
        'khcy': 'х',
        'KHcy': 'Х',
        'kjcy': 'ќ',
        'KJcy': 'Ќ',
        'kopf': '\uD835\uDD5C',
        'Kopf': '\uD835\uDD42',
        'kscr': '\uD835\uDCC0',
        'Kscr': '\uD835\uDCA6',
        'lAarr': '\u21DA',
        'lacute': 'ĺ',
        'Lacute': 'Ĺ',
        'laemptyv': '\u29B4',
        'lagran': 'ℒ',
        'lambda': 'λ',
        'Lambda': 'Λ',
        'lang': '\u27E8',
        'Lang': '\u27EA',
        'langd': '\u2991',
        'langle': '\u27E8',
        'lap': '\u2A85',
        'Laplacetrf': 'ℒ',
        'laquo': '\xAB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'Larr': '\u219E',
        'larrb': '\u21E4',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrhk': '\u21A9',
        'larrlp': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'lAtail': '\u291B',
        'late': '\u2AAD',
        'lates': '\u2AAD︀',
        'lbarr': '\u290C',
        'lBarr': '\u290E',
        'lbbrk': '\u2772',
        'lbrace': '{',
        'lbrack': '[',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': 'ľ',
        'Lcaron': 'Ľ',
        'lcedil': 'ļ',
        'Lcedil': 'Ļ',
        'lceil': '\u2308',
        'lcub': '{',
        'lcy': 'л',
        'Lcy': 'Л',
        'ldca': '\u2936',
        'ldquo': '\u201C',
        'ldquor': '\u201E',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'lE': '\u2266',
        'LeftAngleBracket': '\u27E8',
        'leftarrow': '\u2190',
        'Leftarrow': '\u21D0',
        'LeftArrow': '\u2190',
        'LeftArrowBar': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftarrowtail': '\u21A2',
        'LeftCeiling': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'leftharpoondown': '\u21BD',
        'leftharpoonup': '\u21BC',
        'leftleftarrows': '\u21C7',
        'leftrightarrow': '\u2194',
        'Leftrightarrow': '\u21D4',
        'LeftRightArrow': '\u2194',
        'leftrightarrows': '\u21C6',
        'leftrightharpoons': '\u21CB',
        'leftrightsquigarrow': '\u21AD',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'LeftTeeVector': '\u295A',
        'leftthreetimes': '\u22CB',
        'LeftTriangle': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'LeftVectorBar': '\u2952',
        'leg': '\u22DA',
        'lEg': '\u2A8B',
        'leq': '\u2264',
        'leqq': '\u2266',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA︀',
        'lesges': '\u2A93',
        'lessapprox': '\u2A85',
        'lessdot': '\u22D6',
        'lesseqgtr': '\u22DA',
        'lesseqqgtr': '\u2A8B',
        'LessEqualGreater': '\u22DA',
        'LessFullEqual': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'LessLess': '\u2AA1',
        'lesssim': '\u2272',
        'LessSlantEqual': '\u2A7D',
        'LessTilde': '\u2272',
        'lfisht': '\u297C',
        'lfloor': '\u230A',
        'lfr': '\uD835\uDD29',
        'Lfr': '\uD835\uDD0F',
        'lg': '\u2276',
        'lgE': '\u2A91',
        'lHar': '\u2962',
        'lhard': '\u21BD',
        'lharu': '\u21BC',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': 'љ',
        'LJcy': 'Љ',
        'll': '\u226A',
        'Ll': '\u22D8',
        'llarr': '\u21C7',
        'llcorner': '\u231E',
        'Lleftarrow': '\u21DA',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': 'ŀ',
        'Lmidot': 'Ŀ',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lnE': '\u2268',
        'lneq': '\u2A87',
        'lneqq': '\u2268',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'lobrk': '\u27E6',
        'longleftarrow': '\u27F5',
        'Longleftarrow': '\u27F8',
        'LongLeftArrow': '\u27F5',
        'longleftrightarrow': '\u27F7',
        'Longleftrightarrow': '\u27FA',
        'LongLeftRightArrow': '\u27F7',
        'longmapsto': '\u27FC',
        'longrightarrow': '\u27F6',
        'Longrightarrow': '\u27F9',
        'LongRightArrow': '\u27F6',
        'looparrowleft': '\u21AB',
        'looparrowright': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'Lopf': '\uD835\uDD43',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'lowbar': '_',
        'LowerLeftArrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lozf': '\u29EB',
        'lpar': '(',
        'lparlt': '\u2993',
        'lrarr': '\u21C6',
        'lrcorner': '\u231F',
        'lrhar': '\u21CB',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'Lscr': 'ℒ',
        'lsh': '\u21B0',
        'Lsh': '\u21B0',
        'lsim': '\u2272',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsqb': '[',
        'lsquo': '\u2018',
        'lsquor': '\u201A',
        'lstrok': 'ł',
        'Lstrok': 'Ł',
        'lt': '<',
        'Lt': '\u226A',
        'LT': '<',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltdot': '\u22D6',
        'lthree': '\u22CB',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltri': '\u25C3',
        'ltrie': '\u22B4',
        'ltrif': '\u25C2',
        'ltrPar': '\u2996',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268︀',
        'lvnE': '\u2268︀',
        'macr': '\xAF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'map': '\u21A6',
        'Map': '\u2905',
        'mapsto': '\u21A6',
        'mapstodown': '\u21A7',
        'mapstoleft': '\u21A4',
        'mapstoup': '\u21A5',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': 'м',
        'Mcy': 'М',
        'mdash': '\u2014',
        'mDDot': '\u223A',
        'measuredangle': '\u2221',
        'MediumSpace': '\u205F',
        'Mellintrf': 'ℳ',
        'mfr': '\uD835\uDD2A',
        'Mfr': '\uD835\uDD10',
        'mho': '\u2127',
        'micro': 'µ',
        'mid': '\u2223',
        'midast': '*',
        'midcir': '\u2AF0',
        'middot': '\xB7',
        'minus': '\u2212',
        'minusb': '\u229F',
        'minusd': '\u2238',
        'minusdu': '\u2A2A',
        'MinusPlus': '\u2213',
        'mlcp': '\u2ADB',
        'mldr': '\u2026',
        'mnplus': '\u2213',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'Mopf': '\uD835\uDD44',
        'mp': '\u2213',
        'mscr': '\uD835\uDCC2',
        'Mscr': 'ℳ',
        'mstpos': '\u223E',
        'mu': 'μ',
        'Mu': 'Μ',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nabla': '\u2207',
        'nacute': 'ń',
        'Nacute': 'Ń',
        'nang': '\u2220⃒',
        'nap': '\u2249',
        'napE': '\u2A70̸',
        'napid': '\u224B̸',
        'napos': 'ŉ',
        'napprox': '\u2249',
        'natur': '\u266E',
        'natural': '\u266E',
        'naturals': 'ℕ',
        'nbsp': '\xA0',
        'nbump': '\u224E̸',
        'nbumpe': '\u224F̸',
        'ncap': '\u2A43',
        'ncaron': 'ň',
        'Ncaron': 'Ň',
        'ncedil': 'ņ',
        'Ncedil': 'Ņ',
        'ncong': '\u2247',
        'ncongdot': '\u2A6D̸',
        'ncup': '\u2A42',
        'ncy': 'н',
        'Ncy': 'Н',
        'ndash': '\u2013',
        'ne': '\u2260',
        'nearhk': '\u2924',
        'nearr': '\u2197',
        'neArr': '\u21D7',
        'nearrow': '\u2197',
        'nedot': '\u2250̸',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'nequiv': '\u2262',
        'nesear': '\u2928',
        'nesim': '\u2242̸',
        'NestedGreaterGreater': '\u226B',
        'NestedLessLess': '\u226A',
        'NewLine': '\n',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'nfr': '\uD835\uDD2B',
        'Nfr': '\uD835\uDD11',
        'nge': '\u2271',
        'ngE': '\u2267̸',
        'ngeq': '\u2271',
        'ngeqq': '\u2267̸',
        'ngeqslant': '\u2A7E̸',
        'nges': '\u2A7E̸',
        'nGg': '\u22D9̸',
        'ngsim': '\u2275',
        'ngt': '\u226F',
        'nGt': '\u226B⃒',
        'ngtr': '\u226F',
        'nGtv': '\u226B̸',
        'nharr': '\u21AE',
        'nhArr': '\u21CE',
        'nhpar': '\u2AF2',
        'ni': '\u220B',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'niv': '\u220B',
        'njcy': 'њ',
        'NJcy': 'Њ',
        'nlarr': '\u219A',
        'nlArr': '\u21CD',
        'nldr': '\u2025',
        'nle': '\u2270',
        'nlE': '\u2266̸',
        'nleftarrow': '\u219A',
        'nLeftarrow': '\u21CD',
        'nleftrightarrow': '\u21AE',
        'nLeftrightarrow': '\u21CE',
        'nleq': '\u2270',
        'nleqq': '\u2266̸',
        'nleqslant': '\u2A7D̸',
        'nles': '\u2A7D̸',
        'nless': '\u226E',
        'nLl': '\u22D8̸',
        'nlsim': '\u2274',
        'nlt': '\u226E',
        'nLt': '\u226A⃒',
        'nltri': '\u22EA',
        'nltrie': '\u22EC',
        'nLtv': '\u226A̸',
        'nmid': '\u2224',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\xA0',
        'nopf': '\uD835\uDD5F',
        'Nopf': 'ℕ',
        'not': '\xAC',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'NotElement': '\u2209',
        'NotEqual': '\u2260',
        'NotEqualTilde': '\u2242̸',
        'NotExists': '\u2204',
        'NotGreater': '\u226F',
        'NotGreaterEqual': '\u2271',
        'NotGreaterFullEqual': '\u2267̸',
        'NotGreaterGreater': '\u226B̸',
        'NotGreaterLess': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E̸',
        'NotGreaterTilde': '\u2275',
        'NotHumpDownHump': '\u224E̸',
        'NotHumpEqual': '\u224F̸',
        'notin': '\u2209',
        'notindot': '\u22F5̸',
        'notinE': '\u22F9̸',
        'notinva': '\u2209',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'NotLeftTriangle': '\u22EA',
        'NotLeftTriangleBar': '\u29CF̸',
        'NotLeftTriangleEqual': '\u22EC',
        'NotLess': '\u226E',
        'NotLessEqual': '\u2270',
        'NotLessGreater': '\u2278',
        'NotLessLess': '\u226A̸',
        'NotLessSlantEqual': '\u2A7D̸',
        'NotLessTilde': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2̸',
        'NotNestedLessLess': '\u2AA1̸',
        'notni': '\u220C',
        'notniva': '\u220C',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'NotPrecedes': '\u2280',
        'NotPrecedesEqual': '\u2AAF̸',
        'NotPrecedesSlantEqual': '\u22E0',
        'NotReverseElement': '\u220C',
        'NotRightTriangle': '\u22EB',
        'NotRightTriangleBar': '\u29D0̸',
        'NotRightTriangleEqual': '\u22ED',
        'NotSquareSubset': '\u228F̸',
        'NotSquareSubsetEqual': '\u22E2',
        'NotSquareSuperset': '\u2290̸',
        'NotSquareSupersetEqual': '\u22E3',
        'NotSubset': '\u2282⃒',
        'NotSubsetEqual': '\u2288',
        'NotSucceeds': '\u2281',
        'NotSucceedsEqual': '\u2AB0̸',
        'NotSucceedsSlantEqual': '\u22E1',
        'NotSucceedsTilde': '\u227F̸',
        'NotSuperset': '\u2283⃒',
        'NotSupersetEqual': '\u2289',
        'NotTilde': '\u2241',
        'NotTildeEqual': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'NotTildeTilde': '\u2249',
        'NotVerticalBar': '\u2224',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nparsl': '\u2AFD⃥',
        'npart': '\u2202̸',
        'npolint': '\u2A14',
        'npr': '\u2280',
        'nprcue': '\u22E0',
        'npre': '\u2AAF̸',
        'nprec': '\u2280',
        'npreceq': '\u2AAF̸',
        'nrarr': '\u219B',
        'nrArr': '\u21CF',
        'nrarrc': '\u2933̸',
        'nrarrw': '\u219D̸',
        'nrightarrow': '\u219B',
        'nRightarrow': '\u21CF',
        'nrtri': '\u22EB',
        'nrtrie': '\u22ED',
        'nsc': '\u2281',
        'nsccue': '\u22E1',
        'nsce': '\u2AB0̸',
        'nscr': '\uD835\uDCC3',
        'Nscr': '\uD835\uDCA9',
        'nshortmid': '\u2224',
        'nshortparallel': '\u2226',
        'nsim': '\u2241',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'nsmid': '\u2224',
        'nspar': '\u2226',
        'nsqsube': '\u22E2',
        'nsqsupe': '\u22E3',
        'nsub': '\u2284',
        'nsube': '\u2288',
        'nsubE': '\u2AC5̸',
        'nsubset': '\u2282⃒',
        'nsubseteq': '\u2288',
        'nsubseteqq': '\u2AC5̸',
        'nsucc': '\u2281',
        'nsucceq': '\u2AB0̸',
        'nsup': '\u2285',
        'nsupe': '\u2289',
        'nsupE': '\u2AC6̸',
        'nsupset': '\u2283⃒',
        'nsupseteq': '\u2289',
        'nsupseteqq': '\u2AC6̸',
        'ntgl': '\u2279',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'ntlg': '\u2278',
        'ntriangleleft': '\u22EA',
        'ntrianglelefteq': '\u22EC',
        'ntriangleright': '\u22EB',
        'ntrianglerighteq': '\u22ED',
        'nu': 'ν',
        'Nu': 'Ν',
        'num': '#',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvap': '\u224D⃒',
        'nvdash': '\u22AC',
        'nvDash': '\u22AD',
        'nVdash': '\u22AE',
        'nVDash': '\u22AF',
        'nvge': '\u2265⃒',
        'nvgt': '>⃒',
        'nvHarr': '\u2904',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264⃒',
        'nvlt': '<⃒',
        'nvltrie': '\u22B4⃒',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5⃒',
        'nvsim': '\u223C⃒',
        'nwarhk': '\u2923',
        'nwarr': '\u2196',
        'nwArr': '\u21D6',
        'nwarrow': '\u2196',
        'nwnear': '\u2927',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'oast': '\u229B',
        'ocir': '\u229A',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ocy': 'о',
        'Ocy': 'О',
        'odash': '\u229D',
        'odblac': 'ő',
        'Odblac': 'Ő',
        'odiv': '\u2A38',
        'odot': '\u2299',
        'odsold': '\u29BC',
        'oelig': 'œ',
        'OElig': 'Œ',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'Ofr': '\uD835\uDD12',
        'ogon': '\u02DB',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'ohm': 'Ω',
        'oint': '\u222E',
        'olarr': '\u21BA',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'oline': '\u203E',
        'olt': '\u29C0',
        'omacr': 'ō',
        'Omacr': 'Ō',
        'omega': 'ω',
        'Omega': 'Ω',
        'omicron': 'ο',
        'Omicron': 'Ο',
        'omid': '\u29B6',
        'ominus': '\u2296',
        'oopf': '\uD835\uDD60',
        'Oopf': '\uD835\uDD46',
        'opar': '\u29B7',
        'OpenCurlyDoubleQuote': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'operp': '\u29B9',
        'oplus': '\u2295',
        'or': '\u2228',
        'Or': '\u2A54',
        'orarr': '\u21BB',
        'ord': '\u2A5D',
        'order': 'ℴ',
        'orderof': 'ℴ',
        'ordf': 'ª',
        'ordm': 'º',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oS': '\u24C8',
        'oscr': 'ℴ',
        'Oscr': '\uD835\uDCAA',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'osol': '\u2298',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'otimes': '\u2297',
        'Otimes': '\u2A37',
        'otimesas': '\u2A36',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'ovbar': '\u233D',
        'OverBar': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'OverParenthesis': '\u23DC',
        'par': '\u2225',
        'para': '\xB6',
        'parallel': '\u2225',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'part': '\u2202',
        'PartialD': '\u2202',
        'pcy': 'п',
        'Pcy': 'П',
        'percnt': '%',
        'period': '.',
        'permil': '\u2030',
        'perp': '\u22A5',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'Pfr': '\uD835\uDD13',
        'phi': 'φ',
        'Phi': 'Φ',
        'phiv': 'ϕ',
        'phmmat': 'ℳ',
        'phone': '\u260E',
        'pi': 'π',
        'Pi': 'Π',
        'pitchfork': '\u22D4',
        'piv': 'ϖ',
        'planck': 'ℏ',
        'planckh': 'ℎ',
        'plankv': 'ℏ',
        'plus': '+',
        'plusacir': '\u2A23',
        'plusb': '\u229E',
        'pluscir': '\u2A22',
        'plusdo': '\u2214',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'PlusMinus': '\xB1',
        'plusmn': '\xB1',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pm': '\xB1',
        'Poincareplane': 'ℌ',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'Popf': 'ℙ',
        'pound': '\xA3',
        'pr': '\u227A',
        'Pr': '\u2ABB',
        'prap': '\u2AB7',
        'prcue': '\u227C',
        'pre': '\u2AAF',
        'prE': '\u2AB3',
        'prec': '\u227A',
        'precapprox': '\u2AB7',
        'preccurlyeq': '\u227C',
        'Precedes': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'PrecedesTilde': '\u227E',
        'preceq': '\u2AAF',
        'precnapprox': '\u2AB9',
        'precneqq': '\u2AB5',
        'precnsim': '\u22E8',
        'precsim': '\u227E',
        'prime': '\u2032',
        'Prime': '\u2033',
        'primes': 'ℙ',
        'prnap': '\u2AB9',
        'prnE': '\u2AB5',
        'prnsim': '\u22E8',
        'prod': '\u220F',
        'Product': '\u220F',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prop': '\u221D',
        'Proportion': '\u2237',
        'Proportional': '\u221D',
        'propto': '\u221D',
        'prsim': '\u227E',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'Pscr': '\uD835\uDCAB',
        'psi': 'ψ',
        'Psi': 'Ψ',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'Qfr': '\uD835\uDD14',
        'qint': '\u2A0C',
        'qopf': '\uD835\uDD62',
        'Qopf': 'ℚ',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'Qscr': '\uD835\uDCAC',
        'quaternions': 'ℍ',
        'quatint': '\u2A16',
        'quest': '?',
        'questeq': '\u225F',
        'quot': '"',
        'QUOT': '"',
        'rAarr': '\u21DB',
        'race': '\u223Ḏ',
        'racute': 'ŕ',
        'Racute': 'Ŕ',
        'radic': '\u221A',
        'raemptyv': '\u29B3',
        'rang': '\u27E9',
        'Rang': '\u27EB',
        'rangd': '\u2992',
        'range': '\u29A5',
        'rangle': '\u27E9',
        'raquo': '\xBB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'Rarr': '\u21A0',
        'rarrap': '\u2975',
        'rarrb': '\u21E5',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrhk': '\u21AA',
        'rarrlp': '\u21AC',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'Rarrtl': '\u2916',
        'rarrw': '\u219D',
        'ratail': '\u291A',
        'rAtail': '\u291C',
        'ratio': '\u2236',
        'rationals': 'ℚ',
        'rbarr': '\u290D',
        'rBarr': '\u290F',
        'RBarr': '\u2910',
        'rbbrk': '\u2773',
        'rbrace': '}',
        'rbrack': ']',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': 'ř',
        'Rcaron': 'Ř',
        'rcedil': 'ŗ',
        'Rcedil': 'Ŗ',
        'rceil': '\u2309',
        'rcub': '}',
        'rcy': 'р',
        'Rcy': 'Р',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'rdsh': '\u21B3',
        'Re': 'ℜ',
        'real': 'ℜ',
        'realine': 'ℛ',
        'realpart': 'ℜ',
        'reals': 'ℝ',
        'rect': '\u25AD',
        'reg': '\xAE',
        'REG': '\xAE',
        'ReverseElement': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'rfisht': '\u297D',
        'rfloor': '\u230B',
        'rfr': '\uD835\uDD2F',
        'Rfr': 'ℜ',
        'rHar': '\u2964',
        'rhard': '\u21C1',
        'rharu': '\u21C0',
        'rharul': '\u296C',
        'rho': 'ρ',
        'Rho': 'Ρ',
        'rhov': 'ϱ',
        'RightAngleBracket': '\u27E9',
        'rightarrow': '\u2192',
        'Rightarrow': '\u21D2',
        'RightArrow': '\u2192',
        'RightArrowBar': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightarrowtail': '\u21A3',
        'RightCeiling': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rightharpoondown': '\u21C1',
        'rightharpoonup': '\u21C0',
        'rightleftarrows': '\u21C4',
        'rightleftharpoons': '\u21CC',
        'rightrightarrows': '\u21C9',
        'rightsquigarrow': '\u219D',
        'RightTee': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'RightTeeVector': '\u295B',
        'rightthreetimes': '\u22CC',
        'RightTriangle': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'RightVectorBar': '\u2953',
        'ring': '\u02DA',
        'risingdotseq': '\u2253',
        'rlarr': '\u21C4',
        'rlhar': '\u21CC',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'robrk': '\u27E7',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'Ropf': 'ℝ',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'RoundImplies': '\u2970',
        'rpar': ')',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rrarr': '\u21C9',
        'Rrightarrow': '\u21DB',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'Rscr': 'ℛ',
        'rsh': '\u21B1',
        'Rsh': '\u21B1',
        'rsqb': ']',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'rthree': '\u22CC',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'rtrie': '\u22B5',
        'rtrif': '\u25B8',
        'rtriltri': '\u29CE',
        'RuleDelayed': '\u29F4',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': 'ś',
        'Sacute': 'Ś',
        'sbquo': '\u201A',
        'sc': '\u227B',
        'Sc': '\u2ABC',
        'scap': '\u2AB8',
        'scaron': 'š',
        'Scaron': 'Š',
        'sccue': '\u227D',
        'sce': '\u2AB0',
        'scE': '\u2AB4',
        'scedil': 'ş',
        'Scedil': 'Ş',
        'scirc': 'ŝ',
        'Scirc': 'Ŝ',
        'scnap': '\u2ABA',
        'scnE': '\u2AB6',
        'scnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scsim': '\u227F',
        'scy': 'с',
        'Scy': 'С',
        'sdot': '\u22C5',
        'sdotb': '\u22A1',
        'sdote': '\u2A66',
        'searhk': '\u2925',
        'searr': '\u2198',
        'seArr': '\u21D8',
        'searrow': '\u2198',
        'sect': '\xA7',
        'semi': ';',
        'seswar': '\u2929',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'Sfr': '\uD835\uDD16',
        'sfrown': '\u2322',
        'sharp': '\u266F',
        'shchcy': 'щ',
        'SHCHcy': 'Щ',
        'shcy': 'ш',
        'SHcy': 'Ш',
        'ShortDownArrow': '\u2193',
        'ShortLeftArrow': '\u2190',
        'shortmid': '\u2223',
        'shortparallel': '\u2225',
        'ShortRightArrow': '\u2192',
        'ShortUpArrow': '\u2191',
        'shy': '\xAD',
        'sigma': 'σ',
        'Sigma': 'Σ',
        'sigmaf': 'ς',
        'sigmav': 'ς',
        'sim': '\u223C',
        'simdot': '\u2A6A',
        'sime': '\u2243',
        'simeq': '\u2243',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'slarr': '\u2190',
        'SmallCircle': '\u2218',
        'smallsetminus': '\u2216',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smid': '\u2223',
        'smile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC︀',
        'softcy': 'ь',
        'SOFTcy': 'Ь',
        'sol': '/',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'Sopf': '\uD835\uDD4A',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'spar': '\u2225',
        'sqcap': '\u2293',
        'sqcaps': '\u2293︀',
        'sqcup': '\u2294',
        'sqcups': '\u2294︀',
        'Sqrt': '\u221A',
        'sqsub': '\u228F',
        'sqsube': '\u2291',
        'sqsubset': '\u228F',
        'sqsubseteq': '\u2291',
        'sqsup': '\u2290',
        'sqsupe': '\u2292',
        'sqsupset': '\u2290',
        'sqsupseteq': '\u2292',
        'squ': '\u25A1',
        'square': '\u25A1',
        'Square': '\u25A1',
        'SquareIntersection': '\u2293',
        'SquareSubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'SquareSuperset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'SquareUnion': '\u2294',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'srarr': '\u2192',
        'sscr': '\uD835\uDCC8',
        'Sscr': '\uD835\uDCAE',
        'ssetmn': '\u2216',
        'ssmile': '\u2323',
        'sstarf': '\u22C6',
        'star': '\u2606',
        'Star': '\u22C6',
        'starf': '\u2605',
        'straightepsilon': 'ϵ',
        'straightphi': 'ϕ',
        'strns': '\xAF',
        'sub': '\u2282',
        'Sub': '\u22D0',
        'subdot': '\u2ABD',
        'sube': '\u2286',
        'subE': '\u2AC5',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subne': '\u228A',
        'subnE': '\u2ACB',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subset': '\u2282',
        'Subset': '\u22D0',
        'subseteq': '\u2286',
        'subseteqq': '\u2AC5',
        'SubsetEqual': '\u2286',
        'subsetneq': '\u228A',
        'subsetneqq': '\u2ACB',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'succ': '\u227B',
        'succapprox': '\u2AB8',
        'succcurlyeq': '\u227D',
        'Succeeds': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'SucceedsTilde': '\u227F',
        'succeq': '\u2AB0',
        'succnapprox': '\u2ABA',
        'succneqq': '\u2AB6',
        'succnsim': '\u22E9',
        'succsim': '\u227F',
        'SuchThat': '\u220B',
        'sum': '\u2211',
        'Sum': '\u2211',
        'sung': '\u266A',
        'sup': '\u2283',
        'Sup': '\u22D1',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supe': '\u2287',
        'supE': '\u2AC6',
        'supedot': '\u2AC4',
        'Superset': '\u2283',
        'SupersetEqual': '\u2287',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supne': '\u228B',
        'supnE': '\u2ACC',
        'supplus': '\u2AC0',
        'supset': '\u2283',
        'Supset': '\u22D1',
        'supseteq': '\u2287',
        'supseteqq': '\u2AC6',
        'supsetneq': '\u228B',
        'supsetneqq': '\u2ACC',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swarhk': '\u2926',
        'swarr': '\u2199',
        'swArr': '\u21D9',
        'swarrow': '\u2199',
        'swnwar': '\u292A',
        'szlig': 'ß',
        'Tab': '\t',
        'target': '\u2316',
        'tau': 'τ',
        'Tau': 'Τ',
        'tbrk': '\u23B4',
        'tcaron': 'ť',
        'Tcaron': 'Ť',
        'tcedil': 'ţ',
        'Tcedil': 'Ţ',
        'tcy': 'т',
        'Tcy': 'Т',
        'tdot': '⃛',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'Tfr': '\uD835\uDD17',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Therefore': '\u2234',
        'theta': 'θ',
        'Theta': 'Θ',
        'thetasym': 'ϑ',
        'thetav': 'ϑ',
        'thickapprox': '\u2248',
        'thicksim': '\u223C',
        'ThickSpace': '\u205F\u200A',
        'thinsp': '\u2009',
        'ThinSpace': '\u2009',
        'thkap': '\u2248',
        'thksim': '\u223C',
        'thorn': 'þ',
        'THORN': 'Þ',
        'tilde': '\u02DC',
        'Tilde': '\u223C',
        'TildeEqual': '\u2243',
        'TildeFullEqual': '\u2245',
        'TildeTilde': '\u2248',
        'times': '\xD7',
        'timesb': '\u22A0',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'tint': '\u222D',
        'toea': '\u2928',
        'top': '\u22A4',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'Topf': '\uD835\uDD4B',
        'topfork': '\u2ADA',
        'tosa': '\u2929',
        'tprime': '\u2034',
        'trade': '\u2122',
        'TRADE': '\u2122',
        'triangle': '\u25B5',
        'triangledown': '\u25BF',
        'triangleleft': '\u25C3',
        'trianglelefteq': '\u22B4',
        'triangleq': '\u225C',
        'triangleright': '\u25B9',
        'trianglerighteq': '\u22B5',
        'tridot': '\u25EC',
        'trie': '\u225C',
        'triminus': '\u2A3A',
        'TripleDot': '⃛',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'Tscr': '\uD835\uDCAF',
        'tscy': 'ц',
        'TScy': 'Ц',
        'tshcy': 'ћ',
        'TSHcy': 'Ћ',
        'tstrok': 'ŧ',
        'Tstrok': 'Ŧ',
        'twixt': '\u226C',
        'twoheadleftarrow': '\u219E',
        'twoheadrightarrow': '\u21A0',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'ubrcy': 'ў',
        'Ubrcy': 'Ў',
        'ubreve': 'ŭ',
        'Ubreve': 'Ŭ',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ucy': 'у',
        'Ucy': 'У',
        'udarr': '\u21C5',
        'udblac': 'ű',
        'Udblac': 'Ű',
        'udhar': '\u296E',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'Ufr': '\uD835\uDD18',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uHar': '\u2963',
        'uharl': '\u21BF',
        'uharr': '\u21BE',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': 'ū',
        'Umacr': 'Ū',
        'uml': '\xA8',
        'UnderBar': '_',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'UnionPlus': '\u228E',
        'uogon': 'ų',
        'Uogon': 'Ų',
        'uopf': '\uD835\uDD66',
        'Uopf': '\uD835\uDD4C',
        'uparrow': '\u2191',
        'Uparrow': '\u21D1',
        'UpArrow': '\u2191',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'updownarrow': '\u2195',
        'Updownarrow': '\u21D5',
        'UpDownArrow': '\u2195',
        'UpEquilibrium': '\u296E',
        'upharpoonleft': '\u21BF',
        'upharpoonright': '\u21BE',
        'uplus': '\u228E',
        'UpperLeftArrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'upsi': 'υ',
        'Upsi': 'ϒ',
        'upsih': 'ϒ',
        'upsilon': 'υ',
        'Upsilon': 'Υ',
        'UpTee': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'upuparrows': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': 'ů',
        'Uring': 'Ů',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'Uscr': '\uD835\uDCB0',
        'utdot': '\u22F0',
        'utilde': 'ũ',
        'Utilde': 'Ũ',
        'utri': '\u25B5',
        'utrif': '\u25B4',
        'uuarr': '\u21C8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'uwangle': '\u29A7',
        'vangrt': '\u299C',
        'varepsilon': 'ϵ',
        'varkappa': 'ϰ',
        'varnothing': '\u2205',
        'varphi': 'ϕ',
        'varpi': 'ϖ',
        'varpropto': '\u221D',
        'varr': '\u2195',
        'vArr': '\u21D5',
        'varrho': 'ϱ',
        'varsigma': 'ς',
        'varsubsetneq': '\u228A︀',
        'varsubsetneqq': '\u2ACB︀',
        'varsupsetneq': '\u228B︀',
        'varsupsetneqq': '\u2ACC︀',
        'vartheta': 'ϑ',
        'vartriangleleft': '\u22B2',
        'vartriangleright': '\u22B3',
        'vBar': '\u2AE8',
        'Vbar': '\u2AEB',
        'vBarv': '\u2AE9',
        'vcy': 'в',
        'Vcy': 'В',
        'vdash': '\u22A2',
        'vDash': '\u22A8',
        'Vdash': '\u22A9',
        'VDash': '\u22AB',
        'Vdashl': '\u2AE6',
        'vee': '\u2228',
        'Vee': '\u22C1',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'verbar': '|',
        'Verbar': '\u2016',
        'vert': '|',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'VerticalLine': '|',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'VeryThinSpace': '\u200A',
        'vfr': '\uD835\uDD33',
        'Vfr': '\uD835\uDD19',
        'vltri': '\u22B2',
        'vnsub': '\u2282⃒',
        'vnsup': '\u2283⃒',
        'vopf': '\uD835\uDD67',
        'Vopf': '\uD835\uDD4D',
        'vprop': '\u221D',
        'vrtri': '\u22B3',
        'vscr': '\uD835\uDCCB',
        'Vscr': '\uD835\uDCB1',
        'vsubne': '\u228A︀',
        'vsubnE': '\u2ACB︀',
        'vsupne': '\u228B︀',
        'vsupnE': '\u2ACC︀',
        'Vvdash': '\u22AA',
        'vzigzag': '\u299A',
        'wcirc': 'ŵ',
        'Wcirc': 'Ŵ',
        'wedbar': '\u2A5F',
        'wedge': '\u2227',
        'Wedge': '\u22C0',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wfr': '\uD835\uDD34',
        'Wfr': '\uD835\uDD1A',
        'wopf': '\uD835\uDD68',
        'Wopf': '\uD835\uDD4E',
        'wp': '\u2118',
        'wr': '\u2240',
        'wreath': '\u2240',
        'wscr': '\uD835\uDCCC',
        'Wscr': '\uD835\uDCB2',
        'xcap': '\u22C2',
        'xcirc': '\u25EF',
        'xcup': '\u22C3',
        'xdtri': '\u25BD',
        'xfr': '\uD835\uDD35',
        'Xfr': '\uD835\uDD1B',
        'xharr': '\u27F7',
        'xhArr': '\u27FA',
        'xi': 'ξ',
        'Xi': 'Ξ',
        'xlarr': '\u27F5',
        'xlArr': '\u27F8',
        'xmap': '\u27FC',
        'xnis': '\u22FB',
        'xodot': '\u2A00',
        'xopf': '\uD835\uDD69',
        'Xopf': '\uD835\uDD4F',
        'xoplus': '\u2A01',
        'xotime': '\u2A02',
        'xrarr': '\u27F6',
        'xrArr': '\u27F9',
        'xscr': '\uD835\uDCCD',
        'Xscr': '\uD835\uDCB3',
        'xsqcup': '\u2A06',
        'xuplus': '\u2A04',
        'xutri': '\u25B3',
        'xvee': '\u22C1',
        'xwedge': '\u22C0',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yacy': 'я',
        'YAcy': 'Я',
        'ycirc': 'ŷ',
        'Ycirc': 'Ŷ',
        'ycy': 'ы',
        'Ycy': 'Ы',
        'yen': '\xA5',
        'yfr': '\uD835\uDD36',
        'Yfr': '\uD835\uDD1C',
        'yicy': 'ї',
        'YIcy': 'Ї',
        'yopf': '\uD835\uDD6A',
        'Yopf': '\uD835\uDD50',
        'yscr': '\uD835\uDCCE',
        'Yscr': '\uD835\uDCB4',
        'yucy': 'ю',
        'YUcy': 'Ю',
        'yuml': 'ÿ',
        'Yuml': 'Ÿ',
        'zacute': 'ź',
        'Zacute': 'Ź',
        'zcaron': 'ž',
        'Zcaron': 'Ž',
        'zcy': 'з',
        'Zcy': 'З',
        'zdot': 'ż',
        'Zdot': 'Ż',
        'zeetrf': 'ℨ',
        'ZeroWidthSpace': '\u200B',
        'zeta': 'ζ',
        'Zeta': 'Ζ',
        'zfr': '\uD835\uDD37',
        'Zfr': 'ℨ',
        'zhcy': 'ж',
        'ZHcy': 'Ж',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'Zopf': 'ℤ',
        'zscr': '\uD835\uDCCF',
        'Zscr': '\uD835\uDCB5',
        'zwj': '‍',
        'zwnj': '‌'
    };
    var decodeMapLegacy = {
        'aacute': 'á',
        'Aacute': 'Á',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'aelig': 'æ',
        'AElig': 'Æ',
        'agrave': 'à',
        'Agrave': 'À',
        'amp': '&',
        'AMP': '&',
        'aring': 'å',
        'Aring': 'Å',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'brvbar': '\xA6',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'cedil': '\xB8',
        'cent': '\xA2',
        'copy': '\xA9',
        'COPY': '\xA9',
        'curren': '\xA4',
        'deg': '\xB0',
        'divide': '\xF7',
        'eacute': 'é',
        'Eacute': 'É',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'egrave': 'è',
        'Egrave': 'È',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'frac12': '\xBD',
        'frac14': '\xBC',
        'frac34': '\xBE',
        'gt': '>',
        'GT': '>',
        'iacute': 'í',
        'Iacute': 'Í',
        'icirc': 'î',
        'Icirc': 'Î',
        'iexcl': '\xA1',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'iquest': '\xBF',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'laquo': '\xAB',
        'lt': '<',
        'LT': '<',
        'macr': '\xAF',
        'micro': 'µ',
        'middot': '\xB7',
        'nbsp': '\xA0',
        'not': '\xAC',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ordf': 'ª',
        'ordm': 'º',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'para': '\xB6',
        'plusmn': '\xB1',
        'pound': '\xA3',
        'quot': '"',
        'QUOT': '"',
        'raquo': '\xBB',
        'reg': '\xAE',
        'REG': '\xAE',
        'sect': '\xA7',
        'shy': '\xAD',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'szlig': 'ß',
        'thorn': 'þ',
        'THORN': 'Þ',
        'times': '\xD7',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uml': '\xA8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yen': '\xA5',
        'yuml': 'ÿ'
    };
    var decodeMapNumeric = {
        '0': '\uFFFD',
        '128': '\u20AC',
        '130': '\u201A',
        '131': 'ƒ',
        '132': '\u201E',
        '133': '\u2026',
        '134': '\u2020',
        '135': '\u2021',
        '136': 'ˆ',
        '137': '\u2030',
        '138': 'Š',
        '139': '\u2039',
        '140': 'Œ',
        '142': 'Ž',
        '145': '\u2018',
        '146': '\u2019',
        '147': '\u201C',
        '148': '\u201D',
        '149': '\u2022',
        '150': '\u2013',
        '151': '\u2014',
        '152': '\u02DC',
        '153': '\u2122',
        '154': 'š',
        '155': '\u203A',
        '156': 'œ',
        '158': 'ž',
        '159': 'Ÿ'
    };
    var invalidReferenceCodePoints = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        64976,
        64977,
        64978,
        64979,
        64980,
        64981,
        64982,
        64983,
        64984,
        64985,
        64986,
        64987,
        64988,
        64989,
        64990,
        64991,
        64992,
        64993,
        64994,
        64995,
        64996,
        64997,
        64998,
        64999,
        65000,
        65001,
        65002,
        65003,
        65004,
        65005,
        65006,
        65007,
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
    ];
    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
    };
    var contains = function (array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
            if (array[index] == value) {
                return true;
            }
        }
        return false;
    };
    var merge = function (options, defaults) {
        if (!options) {
            return defaults;
        }
        var result = {};
        var key;
        for (key in defaults) {
            result[key] = has(options, key) ? options[key] : defaults[key];
        }
        return result;
    };
    var codePointToSymbol = function (codePoint, strict) {
        var output = '';
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
            if (strict) {
                parseError('character reference outside the permissible Unicode range');
            }
            return '\uFFFD';
        }
        if (has(decodeMapNumeric, codePoint)) {
            if (strict) {
                parseError('disallowed character reference');
            }
            return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
            parseError('disallowed character reference');
        }
        if (codePoint > 65535) {
            codePoint -= 65536;
            output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
    };
    var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
    };
    var decEscape = function (codePoint) {
        return '&#' + codePoint + ';';
    };
    var parseError = function (message) {
        throw Error('Parse error: ' + message);
    };
    var encode = function (string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
            parseError('forbidden code point');
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function (symbol) {
            return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
            string = string.replace(regexAsciiWhitelist, function (symbol) {
                if (useNamedReferences && has(encodeMap, symbol)) {
                    return '&' + encodeMap[symbol] + ';';
                }
                return escapeBmpSymbol(symbol);
            });
            if (useNamedReferences) {
                string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
            }
            if (useNamedReferences) {
                string = string.replace(regexEncodeNonAscii, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
        } else if (useNamedReferences) {
            if (!allowUnsafeSymbols) {
                string = string.replace(regexEscape, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
            string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;');
            string = string.replace(regexEncodeNonAscii, function (string) {
                return '&' + encodeMap[string] + ';';
            });
        } else if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function ($0) {
            var high = $0.charCodeAt(0);
            var low = $0.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
    };
    var decode = function (html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
            parseError('malformed character reference');
        }
        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7) {
            var codePoint;
            var semicolon;
            var decDigits;
            var hexDigits;
            var reference;
            var next;
            if ($1) {
                decDigits = $1;
                semicolon = $2;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(decDigits, 10);
                return codePointToSymbol(codePoint, strict);
            }
            if ($3) {
                hexDigits = $3;
                semicolon = $4;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(hexDigits, 16);
                return codePointToSymbol(codePoint, strict);
            }
            if ($5) {
                reference = $5;
                if (has(decodeMap, reference)) {
                    return decodeMap[reference];
                } else {
                    if (strict) {
                        parseError('named character reference was not terminated by a semicolon');
                    }
                    return $0;
                }
            }
            reference = $6;
            next = $7;
            if (next && options.isAttributeValue) {
                if (strict && next == '=') {
                    parseError('`&` did not start a character reference');
                }
                return $0;
            } else {
                if (strict) {
                    parseError('named character reference was not terminated by a semicolon');
                }
                return decodeMapLegacy[reference] + (next || '');
            }
        });
    };
    decode.options = {
        'isAttributeValue': false,
        'strict': false
    };
    var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
            return escapeMap[$0];
        });
    };
    var he = {
        'version': '1.1.1',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
    };
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('he@1.1.1#he', function () {
            return he;
        });
    } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
            freeModule.exports = he;
        } else {
            for (var key in he) {
                has(he, key) && (freeExports[key] = he[key]);
            }
        }
    } else {
        root.he = he;
    }
}(this));
/*can-simple-dom@1.6.2#lib/html-parser*/
define('can-simple-dom@1.6.2#lib/html-parser', [
    'require',
    'exports',
    'module',
    'he'
], function (require, exports, module) {
    var he = require('he');
    function HTMLParser(tokenize, document, voidMap) {
        this.tokenize = tokenize;
        this.document = document;
        this.voidMap = voidMap;
        this.parentStack = [];
    }
    HTMLParser.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLParser.prototype.pushElement = function (token) {
        var el = this.document.createElement(token.tagName);
        for (var i = 0; i < token.attributes.length; i++) {
            var attr = token.attributes[i];
            if (attr[0] !== 'href' && attr[0] !== 'src') {
                attr[1] = he.encode(attr[1]);
            }
            el.setAttribute(attr[0], attr[1]);
        }
        if (this.isVoid(el) || token.selfClosing) {
            return this.appendChild(el);
        }
        this.parentStack.push(el);
    };
    HTMLParser.prototype.popElement = function (token) {
        var el = this.parentStack.pop();
        if (el.nodeName !== token.tagName.toUpperCase()) {
            throw new Error('unbalanced tag');
        }
        this.appendChild(el);
    };
    HTMLParser.prototype.appendText = function (token) {
        var text = this.document.createTextNode(token.chars);
        this.appendChild(text);
    };
    HTMLParser.prototype.appendComment = function (token) {
        var comment = this.document.createComment(token.chars);
        this.appendChild(comment);
    };
    HTMLParser.prototype.appendChild = function (node) {
        var parentNode = this.parentStack[this.parentStack.length - 1];
        parentNode.appendChild(node);
    };
    HTMLParser.prototype.parse = function (html) {
        var fragment = this.document.createDocumentFragment();
        this.parentStack.push(fragment);
        var tokens = this.tokenize(html);
        for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            switch (token.type) {
            case 'StartTag':
                this.pushElement(token);
                break;
            case 'EndTag':
                this.popElement(token);
                break;
            case 'Chars':
                this.appendText(token);
                break;
            case 'Comment':
                this.appendComment(token);
                break;
            }
        }
        return this.parentStack.pop();
    };
    module.exports = HTMLParser;
});
/*can-simple-dom@1.6.2#lib/html-serializer*/
define('can-simple-dom@1.6.2#lib/html-serializer', function (require, exports, module) {
    var REG_ESCAPE_ALL = /[<>&]/g;
    var REG_ESCAPE_PRESERVE_ENTITIES = /[<>]|&(?:#?[a-zA-Z0-9]+;)?/g;
    function HTMLSerializer(voidMap) {
        this.voidMap = voidMap;
    }
    HTMLSerializer.prototype.openTag = function (element) {
        return '<' + element.nodeName.toLowerCase() + this.attributes(element.attributes) + '>';
    };
    HTMLSerializer.prototype.closeTag = function (element) {
        return '</' + element.nodeName.toLowerCase() + '>';
    };
    HTMLSerializer.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLSerializer.prototype.attributes = function (namedNodeMap) {
        var buffer = '';
        for (var i = 0, l = namedNodeMap.length; i < l; i++) {
            buffer += this.attr(namedNodeMap[i]);
        }
        return buffer;
    };
    HTMLSerializer.prototype.escapeAttrValue = function (attrValue) {
        return attrValue.replace(/"|&(?:#?[a-zA-Z0-9]+;)?/g, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '"':
                return '&quot;';
            default:
                return match;
            }
        });
    };
    HTMLSerializer.prototype.attr = function (attr) {
        if (!attr.specified) {
            return '';
        }
        if (attr.value) {
            if (attr.name === 'href' || attr.name === 'src') {
                return ' ' + attr.name + '="' + attr.value + '"';
            }
            return ' ' + attr.name + '="' + this.escapeAttrValue(attr.value) + '"';
        }
        return ' ' + attr.name;
    };
    HTMLSerializer.prototype.escapeText = function (textNodeValue, escapeAll) {
        return textNodeValue.replace(escapeAll ? REG_ESCAPE_ALL : REG_ESCAPE_PRESERVE_ENTITIES, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            default:
                return match;
            }
        });
    };
    var metadataContentTags = {
        style: true,
        script: true,
        template: true
    };
    function isMetadataTag(elem) {
        return !!elem && metadataContentTags[elem.nodeName.toLowerCase()];
    }
    HTMLSerializer.prototype.text = function (text) {
        if (isMetadataTag(text.parentNode)) {
            return text.nodeValue;
        }
        return this.escapeText(text.nodeValue);
    };
    HTMLSerializer.prototype.comment = function (comment) {
        return '<!--' + comment.nodeValue + '-->';
    };
    HTMLSerializer.prototype.serialize = function (node) {
        var buffer = '';
        var next;
        switch (node.nodeType) {
        case 1:
            buffer += this.openTag(node);
            break;
        case 3:
            buffer += this.text(node);
            break;
        case 8:
            buffer += this.comment(node);
            break;
        default:
            break;
        }
        next = node.firstChild;
        if (next) {
            while (next) {
                buffer += this.serialize(next);
                next = next.nextSibling;
            }
        } else if (node.nodeType === 1 && node.textContent) {
            buffer += this.escapeText(node.textContent, true);
        }
        if (node.nodeType === 1 && !this.isVoid(node)) {
            buffer += this.closeTag(node);
        }
        return buffer;
    };
    module.exports = HTMLSerializer;
});
/*can-simple-dom@1.6.2#lib/void-map*/
define('can-simple-dom@1.6.2#lib/void-map', function (require, exports, module) {
    module.exports = {
        AREA: true,
        BASE: true,
        BR: true,
        COL: true,
        COMMAND: true,
        EMBED: true,
        HR: true,
        IMG: true,
        INPUT: true,
        KEYGEN: true,
        LINK: true,
        META: true,
        PARAM: true,
        SOURCE: true,
        TRACK: true,
        WBR: true
    };
});
/*can-simple-dom@1.6.2#lib/dom*/
define('can-simple-dom@1.6.2#lib/dom', [
    'require',
    'exports',
    'module',
    './document/node',
    './document/element',
    './document',
    './event',
    './html-parser',
    './html-serializer',
    './void-map'
], function (require, exports, module) {
    var Node = require('./document/node').Node;
    var Element = require('./document/element');
    var Document = require('./document');
    var Event = require('./event');
    var HTMLParser = require('./html-parser');
    var HTMLSerializer = require('./html-serializer');
    var voidMap = require('./void-map');
    function createDocument(serializer, parser) {
        var doc = new Document();
        doc.__serializer = serializer;
        doc.__parser = parser;
        return doc;
    }
    exports.Node = Node;
    exports.Element = Element;
    exports.Document = Document;
    exports.Event = Event;
    exports.HTMLParser = HTMLParser;
    exports.HTMLSerializer = HTMLSerializer;
    exports.voidMap = voidMap;
    exports.createDocument = createDocument;
});
/*can-simple-dom@1.6.2#can-simple-dom*/
define('can-simple-dom@1.6.2#can-simple-dom', [
    'require',
    'exports',
    'module',
    './lib/dom'
], function (require, exports, module) {
    var SimpleDOM = require('./lib/dom');
    if (typeof window !== 'undefined') {
        window.SimpleDOM = SimpleDOM;
    }
    exports = module.exports = SimpleDOM.Document;
    exports.Node = SimpleDOM.Node;
    exports.Element = SimpleDOM.Element;
    exports.Document = SimpleDOM.Document;
    exports.Event = SimpleDOM.Event;
    exports.HTMLParser = SimpleDOM.HTMLParser;
    exports.HTMLSerializer = SimpleDOM.HTMLSerializer;
    exports.voidMap = SimpleDOM.voidMap;
    exports.createDocument = SimpleDOM.createDocument;
});
/*can-log@1.0.1#can-log*/
define('can-log@1.0.1#can-log', function (require, exports, module) {
    'use strict';
    exports.warnTimeout = 5000;
    exports.logLevel = 0;
    exports.warn = function () {
        var ll = this.logLevel;
        if (ll < 2) {
            if (typeof console !== 'undefined' && console.warn) {
                this._logger('warn', Array.prototype.slice.call(arguments));
            } else if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports.log = function () {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports.error = function () {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.error) {
                this._logger('error', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports._logger = function (type, arr) {
        try {
            console[type].apply(console, arr);
        } catch (e) {
            console[type](arr);
        }
    };
});
/*can-log@1.0.1#dev/dev*/
define('can-log@1.0.1#dev/dev', [
    'require',
    'exports',
    'module',
    '../can-log'
], function (require, exports, module) {
    'use strict';
    var canLog = require('../can-log');
    module.exports = {
        warnTimeout: 5000,
        logLevel: 0,
        stringify: function (value) {
            var flagUndefined = function flagUndefined(key, value) {
                return value === undefined ? '/* void(undefined) */' : value;
            };
            return JSON.stringify(value, flagUndefined, '  ').replace(/"\/\* void\(undefined\) \*\/"/g, 'undefined');
        },
        warn: function () {
        },
        log: function () {
        },
        error: function () {
        },
        _logger: canLog._logger
    };
});
/*can-attribute-encoder@1.1.4#can-attribute-encoder*/
define('can-attribute-encoder@1.1.4#can-attribute-encoder', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var dev = require('can-log/dev/dev');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    var caseMattersAttributes = makeMap('allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector,controlsList');
    function camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {
        return lowerCaseChar + '-' + upperCaseChar.toLowerCase();
    }
    function startsWith(allOfIt, startsWith) {
        return allOfIt.indexOf(startsWith) === 0;
    }
    function endsWith(allOfIt, endsWith) {
        return allOfIt.length - allOfIt.lastIndexOf(endsWith) === endsWith.length;
    }
    var regexes = {
        leftParens: /\(/g,
        rightParens: /\)/g,
        leftBrace: /\{/g,
        rightBrace: /\}/g,
        camelCase: /([a-z]|[0-9]|^)([A-Z])/g,
        forwardSlash: /\//g,
        space: /\s/g,
        uppercase: /[A-Z]/g,
        uppercaseDelimiterThenChar: /:u:([a-z])/g,
        caret: /\^/g,
        dollar: /\$/g,
        at: /@/g
    };
    var delimiters = {
        prependUppercase: ':u:',
        replaceSpace: ':s:',
        replaceForwardSlash: ':f:',
        replaceLeftParens: ':lp:',
        replaceRightParens: ':rp:',
        replaceLeftBrace: ':lb:',
        replaceRightBrace: ':rb:',
        replaceCaret: ':c:',
        replaceDollar: ':d:',
        replaceAt: ':at:'
    };
    var encoder = {};
    encoder.encode = function (name) {
        var encoded = name;
        if (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {
            if (startsWith(encoded, 'on:') || endsWith(encoded, ':to') || endsWith(encoded, ':from') || endsWith(encoded, ':bind') || endsWith(encoded, ':raw')) {
                encoded = encoded.replace(regexes.uppercase, function (char) {
                    return delimiters.prependUppercase + char.toLowerCase();
                });
            } else if (startsWith(encoded, '(') || startsWith(encoded, '{')) {
                encoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);
            }
        }
        encoded = encoded.replace(regexes.space, delimiters.replaceSpace).replace(regexes.forwardSlash, delimiters.replaceForwardSlash).replace(regexes.leftParens, delimiters.replaceLeftParens).replace(regexes.rightParens, delimiters.replaceRightParens).replace(regexes.leftBrace, delimiters.replaceLeftBrace).replace(regexes.rightBrace, delimiters.replaceRightBrace).replace(regexes.caret, delimiters.replaceCaret).replace(regexes.dollar, delimiters.replaceDollar).replace(regexes.at, delimiters.replaceAt);
        return encoded;
    };
    encoder.decode = function (name) {
        var decoded = name;
        if (!caseMattersAttributes[decoded] && regexes.uppercaseDelimiterThenChar.test(decoded)) {
            if (startsWith(decoded, 'on:') || endsWith(decoded, ':to') || endsWith(decoded, ':from') || endsWith(decoded, ':bind') || endsWith(decoded, ':raw')) {
                decoded = decoded.replace(regexes.uppercaseDelimiterThenChar, function (match, char) {
                    return char.toUpperCase();
                });
            }
        }
        decoded = decoded.replace(delimiters.replaceLeftParens, '(').replace(delimiters.replaceRightParens, ')').replace(delimiters.replaceLeftBrace, '{').replace(delimiters.replaceRightBrace, '}').replace(delimiters.replaceForwardSlash, '/').replace(delimiters.replaceSpace, ' ').replace(delimiters.replaceCaret, '^').replace(delimiters.replaceDollar, '$').replace(delimiters.replaceAt, '@');
        return decoded;
    };
    if (namespace.encoder) {
        throw new Error('You can\'t have two versions of can-attribute-encoder, check your dependencies');
    } else {
        module.exports = namespace.encoder = encoder;
    }
});
/*can-view-parser@4.1.3#can-view-parser*/
define('can-view-parser@4.1.3#can-view-parser', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev',
    'can-attribute-encoder'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace'), dev = require('can-log/dev/dev'), encoder = require('can-attribute-encoder');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    function handleIntermediate(intermediate, handler) {
        for (var i = 0, len = intermediate.length; i < len; i++) {
            var item = intermediate[i];
            handler[item.tokenType].apply(handler, item.args);
        }
        return intermediate;
    }
    var alphaNumeric = 'A-Za-z0-9', alphaNumericHU = '-:_' + alphaNumeric, magicStart = '{{', endTag = new RegExp('^<\\/([' + alphaNumericHU + ']+)[^>]*>'), magicMatch = new RegExp('\\{\\{(![\\s\\S]*?!|[\\s\\S]*?)\\}\\}\\}?', 'g'), space = /\s/, alphaRegex = new RegExp('[' + alphaNumeric + ']'), attributeRegexp = new RegExp('[' + alphaNumericHU + ']+s*=s*("[^"]*"|\'[^\']*\')');
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    var caseMattersElements = makeMap('altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath');
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    var special = makeMap('script');
    var tokenTypes = 'start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done'.split(',');
    var startOppositesMap = {
        '{': '}',
        '(': ')'
    };
    var fn = function () {
    };
    var HTMLParser = function (html, handler, returnIntermediate) {
        if (typeof html === 'object') {
            return handleIntermediate(html, handler);
        }
        var intermediate = [];
        handler = handler || {};
        if (returnIntermediate) {
            each(tokenTypes, function (name) {
                var callback = handler[name] || fn;
                handler[name] = function () {
                    if (callback.apply(this, arguments) !== false) {
                        var end = arguments.length;
                        if (arguments[end - 1] === undefined) {
                            end = arguments.length - 1;
                        }
                        intermediate.push({
                            tokenType: name,
                            args: [].slice.call(arguments, 0, end)
                        });
                    }
                };
            });
        }
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
            if (closeSelf[tagName] && stack.last() === tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            handler.start(tagName, unary, lineNo);
            if (!unary) {
                stack.push(tagName);
            }
            HTMLParser.parseAttrs(rest, handler, lineNo);
            handler.end(tagName, unary, lineNo);
            if (tagName === 'html') {
                skipChars = true;
            }
        }
        function parseEndTag(tag, tagName) {
            var pos;
            if (!tagName) {
                pos = 0;
            } else {
                tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] === tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (handler.close) {
                        handler.close(stack[i], lineNo);
                    }
                }
                stack.length = pos;
                if (tagName === 'body') {
                    skipChars = true;
                }
            }
        }
        function parseMustache(mustache, inside) {
            if (handler.special) {
                handler.special(inside, lineNo);
            }
        }
        var callChars = function () {
            if (charsText && !skipChars) {
                if (handler.chars) {
                    handler.chars(charsText, lineNo);
                }
            }
            skipChars = false;
            charsText = '';
        };
        var index, chars, skipChars, match, lineNo, stack = [], last = html, charsText = '';
        stack.last = function () {
            return this[this.length - 1];
        };
        while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
                if (html.indexOf('<!--') === 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        callChars();
                        if (handler.comment) {
                            handler.comment(html.substring(4, index), lineNo);
                        }
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') === 0) {
                    match = html.match(endTag);
                    if (match) {
                        callChars();
                        match[0].replace(endTag, parseEndTag);
                        html = html.substring(match[0].length);
                        chars = false;
                    }
                } else if (html.indexOf('<') === 0) {
                    var res = HTMLParser.searchStartTag(html);
                    if (res) {
                        callChars();
                        parseStartTag.apply(null, res.match);
                        html = res.html;
                        chars = false;
                    }
                } else if (html.indexOf(magicStart) === 0) {
                    match = html.match(magicMatch);
                    if (match) {
                        callChars();
                        match[0].replace(magicMatch, parseMustache);
                        html = html.substring(match[0].length);
                    }
                }
                if (chars) {
                    index = findBreak(html, magicStart);
                    if (index === 0 && html === last) {
                        charsText += html.charAt(0);
                        html = html.substr(1);
                        index = findBreak(html, magicStart);
                    }
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (text) {
                        charsText += text;
                    }
                }
            } else {
                html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
                    if (handler.chars) {
                        handler.chars(text, lineNo);
                    }
                    return '';
                });
                parseEndTag('', stack.last());
            }
            if (html === last) {
                throw new Error('Parse Error: ' + html);
            }
            last = html;
        }
        callChars();
        parseEndTag();
        handler.done(lineNo);
        return intermediate;
    };
    var callAttrStart = function (state, curIndex, handler, rest, lineNo) {
        var attrName = rest.substring(typeof state.nameStart === 'number' ? state.nameStart : curIndex, curIndex), newAttrName = encoder.encode(attrName);
        state.attrStart = newAttrName;
        handler.attrStart(state.attrStart, lineNo);
        state.inName = false;
    };
    var callAttrEnd = function (state, curIndex, handler, rest, lineNo) {
        if (state.valueStart !== undefined && state.valueStart < curIndex) {
            var val = rest.substring(state.valueStart, curIndex);
            handler.attrValue(val, lineNo);
        }
        handler.attrEnd(state.attrStart, lineNo);
        state.attrStart = undefined;
        state.valueStart = undefined;
        state.inValue = false;
        state.inName = false;
        state.lookingForEq = false;
        state.inQuote = false;
        state.lookingForName = true;
    };
    var findBreak = function (str, magicStart) {
        var magicLength = magicStart.length;
        for (var i = 0, len = str.length; i < len; i++) {
            if (str[i] === '<' || str.substr(i, magicLength) === magicStart) {
                return i;
            }
        }
        return -1;
    };
    HTMLParser.parseAttrs = function (rest, handler, lineNo) {
        if (!rest) {
            return;
        }
        var i = 0;
        var curIndex;
        var state = {
            inName: false,
            nameStart: undefined,
            inValue: false,
            valueStart: undefined,
            inQuote: false,
            attrStart: undefined,
            lookingForName: true,
            lookingForValue: false,
            lookingForEq: false
        };
        while (i < rest.length) {
            curIndex = i;
            var cur = rest.charAt(i);
            i++;
            if (magicStart === rest.substr(curIndex, magicStart.length)) {
                if (state.inValue && curIndex > state.valueStart) {
                    handler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);
                } else if (state.inName && state.nameStart < curIndex) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                } else if (state.lookingForValue) {
                    state.inValue = true;
                } else if (state.lookingForEq && state.attrStart) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
                magicMatch.lastIndex = curIndex;
                var match = magicMatch.exec(rest);
                if (match) {
                    handler.special(match[1], lineNo);
                    i = curIndex + match[0].length;
                    if (state.inValue) {
                        state.valueStart = curIndex + match[0].length;
                    }
                }
            } else if (state.inValue) {
                if (state.inQuote) {
                    if (cur === state.inQuote) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                } else if (space.test(cur)) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            } else if (cur === '=' && (state.lookingForEq || state.lookingForName || state.inName)) {
                if (!state.attrStart) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                }
                state.lookingForValue = true;
                state.lookingForEq = false;
                state.lookingForName = false;
            } else if (state.inName) {
                var started = rest[state.nameStart], otherStart, otherOpposite;
                if (startOppositesMap[started] === cur) {
                    otherStart = started === '{' ? '(' : '{';
                    otherOpposite = startOppositesMap[otherStart];
                    if (rest[curIndex + 1] === otherOpposite) {
                        callAttrStart(state, curIndex + 2, handler, rest, lineNo);
                        i++;
                    } else {
                        callAttrStart(state, curIndex + 1, handler, rest, lineNo);
                    }
                    state.lookingForEq = true;
                } else if (space.test(cur) && started !== '{' && started !== '(') {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    state.lookingForEq = true;
                }
            } else if (state.lookingForName) {
                if (!space.test(cur)) {
                    if (state.attrStart) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                    state.nameStart = curIndex;
                    state.inName = true;
                }
            } else if (state.lookingForValue) {
                if (!space.test(cur)) {
                    state.lookingForValue = false;
                    state.inValue = true;
                    if (cur === '\'' || cur === '"') {
                        state.inQuote = cur;
                        state.valueStart = curIndex + 1;
                    } else {
                        state.valueStart = curIndex;
                    }
                } else if (i === rest.length) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            }
        }
        if (state.inName) {
            callAttrStart(state, curIndex + 1, handler, rest, lineNo);
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        } else if (state.lookingForEq || state.lookingForValue || state.inValue) {
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        }
        magicMatch.lastIndex = 0;
    };
    HTMLParser.searchStartTag = function (html) {
        var closingIndex = html.indexOf('>');
        var attributeRange = attributeRegexp.exec(html.substring(1));
        var afterAttributeOffset = 1;
        while (attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {
            afterAttributeOffset += attributeRange.index + attributeRange[0].length;
            while (closingIndex < afterAttributeOffset) {
                closingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;
            }
            attributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));
        }
        if (closingIndex === -1 || !alphaRegex.test(html[1])) {
            return null;
        }
        var tagName, tagContent, match, rest = '', unary = '';
        var startTag = html.substring(0, closingIndex + 1);
        var isUnary = startTag[startTag.length - 2] === '/';
        var spaceIndex = startTag.search(space);
        if (isUnary) {
            unary = '/';
            tagContent = startTag.substring(1, startTag.length - 2).trim();
        } else {
            tagContent = startTag.substring(1, startTag.length - 1).trim();
        }
        if (spaceIndex === -1) {
            tagName = tagContent;
        } else {
            spaceIndex--;
            tagName = tagContent.substring(0, spaceIndex);
            rest = tagContent.substring(spaceIndex);
        }
        match = [
            startTag,
            tagName,
            rest,
            unary
        ];
        return {
            match: match,
            html: html.substring(startTag.length)
        };
    };
    module.exports = namespace.HTMLParser = HTMLParser;
});
/*can-vdom@4.4.1#make-parser/make-parser*/
define('can-vdom@4.4.1#make-parser/make-parser', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-simple-dom'
], function (require, exports, module) {
    'use strict';
    var canParser = require('can-view-parser');
    var simpleDOM = require('can-simple-dom');
    module.exports = function (document) {
        return new simpleDOM.HTMLParser(function (string) {
            var tokens = [];
            var currentTag, currentAttr;
            canParser(string, {
                start: function (tagName, unary) {
                    currentTag = {
                        type: 'StartTag',
                        attributes: [],
                        tagName: tagName
                    };
                },
                end: function (tagName, unary) {
                    tokens.push(currentTag);
                    currentTag = undefined;
                },
                close: function (tagName) {
                    tokens.push({
                        type: 'EndTag',
                        tagName: tagName
                    });
                },
                attrStart: function (attrName) {
                    currentAttr = [
                        attrName,
                        ''
                    ];
                    currentTag.attributes.push(currentAttr);
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (value) {
                    currentAttr[1] += value;
                },
                chars: function (value) {
                    tokens.push({
                        type: 'Chars',
                        chars: value
                    });
                },
                comment: function (value) {
                    tokens.push({
                        type: 'Comment',
                        chars: value
                    });
                },
                special: function (value) {
                },
                done: function () {
                }
            });
            return tokens;
        }, document, simpleDOM.voidMap);
    };
});
/*can-vdom@4.4.1#make-document/make-document*/
define('can-vdom@4.4.1#make-document/make-document', [
    'require',
    'exports',
    'module',
    'can-simple-dom',
    '../make-parser/make-parser'
], function (require, exports, module) {
    'use strict';
    var simpleDOM = require('can-simple-dom');
    var makeParser = require('../make-parser/make-parser');
    function CanSimpleDocument() {
        simpleDOM.Document.apply(this, arguments);
        var serializer = new simpleDOM.HTMLSerializer(simpleDOM.voidMap);
        var parser = makeParser(this);
        this.__addSerializerAndParser(serializer, parser);
    }
    CanSimpleDocument.prototype = new simpleDOM.Document();
    CanSimpleDocument.prototype.constructor = CanSimpleDocument;
    module.exports = function () {
        return new CanSimpleDocument();
    };
});
/*can-dom-mutate@1.3.7#test/can-dom-mutate-test*/
define('can-dom-mutate@1.3.7#test/can-dom-mutate-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../can-dom-mutate',
    'can-globals/document/document',
    '../node',
    './test-utils',
    'can-globals',
    'can-globals/mutation-observer/mutation-observer',
    'can-vdom/make-document/make-document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var unit = require('steal-qunit');
        var domMutate = require('../can-dom-mutate');
        var DOCUMENT = require('can-globals/document/document');
        var node = require('../node');
        var testUtils = require('./test-utils');
        var globals = require('can-globals');
        var MUTATION_OBSERVER = require('can-globals/mutation-observer/mutation-observer');
        var makeSimpleDocument = require('can-vdom/make-document/make-document');
        var test = unit.test;
        var moduleMutationObserver = testUtils.moduleMutationObserver;
        function mutationObserverTests() {
            test('onNodeConnected should be called when that node is inserted', function (assert) {
                var done = assert.async();
                var doc = globals.getKeyValue('document');
                var parent = testUtils.getFixture();
                var child = doc.createElement('div');
                var undo = domMutate.onNodeConnected(child, function (mutation) {
                    var node = mutation.target;
                    assert.equal(node, child, 'Node should be the inserted child');
                    undo();
                    done();
                });
                node.appendChild.call(parent, child);
            });
            test('onNodeDisconnected should be called when that node is removed', function (assert) {
                var done = assert.async();
                var doc = globals.getKeyValue('document');
                var parent = testUtils.getFixture();
                var child = doc.createElement('div');
                var undo = domMutate.onNodeDisconnected(child, function (mutation) {
                    var node = mutation.target;
                    assert.equal(node, child, 'Node should be the removed child');
                    undo();
                    done();
                });
                parent.appendChild(child);
                node.removeChild.call(parent, child);
            });
            test('onNodeAttributeChange should be called when that node\'s attributes change', function (assert) {
                var done = assert.async();
                var doc = globals.getKeyValue('document');
                var child = doc.createElement('div');
                var attributeName = 'foo';
                child.setAttribute(attributeName, 'bar');
                var undo = domMutate.onNodeAttributeChange(child, function (mutation) {
                    assert.equal(mutation.target, child, 'Node should be the removed child');
                    assert.equal(mutation.attributeName, attributeName);
                    assert.equal(mutation.oldValue, 'bar');
                    undo();
                    done();
                });
                node.setAttribute.call(child, attributeName, 'baz');
            });
            test('onInserted should be called when any node is inserted', function (assert) {
                var done = assert.async();
                var parent = testUtils.getFixture();
                var doc = globals.getKeyValue('document');
                var child = doc.createElement('div');
                var undo = domMutate.onConnected(doc.documentElement, function (mutation) {
                    assert.equal(mutation.target, child, 'Node should be the inserted child');
                    undo();
                    done();
                });
                node.appendChild.call(parent, child);
            });
            test('onInserted should be called with inserted fragment subtree', function (assert) {
                assert.expect(3);
                var done = assert.async();
                var parent = testUtils.getFixture();
                var doc = globals.getKeyValue('document');
                var fragment = doc.createDocumentFragment();
                var child1 = doc.createElement('div');
                child1.id = 'child1';
                var child2 = doc.createElement('div');
                child2.id = 'child2';
                var grandchild = doc.createElement('div');
                grandchild.id = 'grandchild';
                fragment.appendChild(child1);
                fragment.appendChild(child2);
                child2.appendChild(grandchild);
                var dispatchCount = 0;
                var nodes = [
                    child1,
                    child2,
                    grandchild
                ];
                var undo = domMutate.onConnected(doc.documentElement, function (mutation) {
                    var target = mutation.target;
                    if (nodes.indexOf(target) !== -1) {
                        dispatchCount++;
                        if (target === child1) {
                            assert.ok(true, 'child1 dispatched');
                        }
                        if (target === child2) {
                            assert.ok(true, 'child2 dispatched');
                        }
                        if (target === grandchild) {
                            assert.ok(true, 'grandchild dispatched');
                        }
                        if (dispatchCount >= nodes.length) {
                            undo();
                            done();
                        }
                    }
                });
                node.appendChild.call(parent, fragment);
            });
            test('onDisconnected should be called when any node is removed', function (assert) {
                var done = assert.async();
                var doc = globals.getKeyValue('document');
                var parent = testUtils.getFixture();
                var child = doc.createElement('div');
                var undo = domMutate.onDisconnected(doc.documentElement, function (mutation) {
                    assert.equal(mutation.target, child, 'Node should be the removed child');
                    undo();
                    done();
                });
                parent.appendChild(child);
                node.removeChild.call(parent, child);
            });
            test('onNodeConnected should be called when that node is inserted into a different document', function (assert) {
                var done = assert.async();
                var doc = globals.getKeyValue('document');
                var parent = testUtils.getFixture();
                var doc1 = doc.implementation.createHTMLDocument('doc1');
                var child = doc1.createElement('div');
                var undo = domMutate.onNodeConnected(child, function (mutation) {
                    var node = mutation.target;
                    assert.equal(node, child, 'Node should be the inserted child');
                    undo();
                    done();
                });
                node.appendChild.call(parent, child);
            });
            test('onNodeDisconnected does not leak when given a document fragment', function (assert) {
                var doc = globals.getKeyValue('document');
                var doc1 = doc.implementation.createHTMLDocument('doc1');
                var frag = doc1.createDocumentFragment();
                frag.appendChild(doc1.createElement('div'));
                var getListenerCount = function () {
                    return globals.eventHandlers.MutationObserver.length;
                };
                var previousListenerCount = getListenerCount();
                DOCUMENT(doc1);
                domMutate.onNodeDisconnected(frag, function () {
                });
                DOCUMENT(doc);
                assert.equal(getListenerCount(), previousListenerCount, 'No new listeners added for this fragment');
            });
            test('onNodeConnected should be called when textNode is inserted within a parent', function (assert) {
                var done = assert.async();
                var doc = globals.getKeyValue('document');
                var parent = testUtils.getFixture();
                var child = doc.createTextNode('Hello World');
                var wrapper = doc.createElement('div');
                wrapper.appendChild(child);
                var undo = domMutate.onNodeConnected(child, function (mutation) {
                    var node = mutation.target;
                    assert.equal(node, child, 'Node should be the inserted child');
                    undo();
                    done();
                });
                node.appendChild.call(parent, wrapper);
            });
            test('flushRecords works', function (assert) {
                var done = assert.async();
                var doc = globals.getKeyValue('document');
                var parent = testUtils.getFixture();
                var wrapper = doc.createElement('div');
                var called = false;
                domMutate.onNodeConnected(wrapper, function () {
                    called = true;
                });
                node.appendChild.call(parent, wrapper);
                domMutate.flushRecords();
                assert.ok(called, 'insertion run immediately');
                setTimeout(done, 1);
            });
        }
        moduleMutationObserver('can-dom-mutate with real document', DOCUMENT(), mutationObserverTests);
        testUtils.moduleWithMutationObserver('can-dom-mutate with real document', function () {
            test('changing the MutationObserver tears down the mutation observer', function (assert) {
                assert.expect(2);
                var doc = globals.getKeyValue('document');
                var done = assert.async();
                var parent = testUtils.getFixture();
                var wrapper = doc.createElement('div');
                var undoA = domMutate.onNodeConnected(wrapper, function () {
                    assert.ok(true, 'this will still be called b/c it\'s on the document');
                    undoA();
                });
                MUTATION_OBSERVER(MUTATION_OBSERVER());
                var undoB = domMutate.onNodeConnected(wrapper, function (mutation) {
                    var node = mutation.target;
                    assert.equal(node, wrapper, 'Node should be the inserted child');
                    undoB();
                    done();
                });
                node.appendChild.call(parent, wrapper);
            });
        });
        moduleMutationObserver('can-dom-mutate with SimpleDocument', makeSimpleDocument(), mutationObserverTests);
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-events@1.3.10#helpers/util*/
define('can-dom-events@1.3.10#helpers/util', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/is-browser-window/is-browser-window'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getCurrentDocument = require('can-globals/document/document');
        var isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
        function getTargetDocument(target) {
            return target.ownerDocument || getCurrentDocument();
        }
        function createEvent(target, eventData, bubbles, cancelable) {
            var doc = getTargetDocument(target);
            var event = doc.createEvent('HTMLEvents');
            var eventType;
            if (typeof eventData === 'string') {
                eventType = eventData;
            } else {
                eventType = eventData.type;
                for (var prop in eventData) {
                    if (event[prop] === undefined) {
                        event[prop] = eventData[prop];
                    }
                }
            }
            if (bubbles === undefined) {
                bubbles = true;
            }
            event.initEvent(eventType, bubbles, cancelable);
            return event;
        }
        function isDomEventTarget(obj) {
            if (!(obj && obj.nodeName)) {
                return obj === window;
            }
            var nodeType = obj.nodeType;
            return nodeType === 1 || nodeType === 9 || nodeType === 11;
        }
        function addDomContext(context, args) {
            if (isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                args.unshift(context);
            }
            return args;
        }
        function removeDomContext(context, args) {
            if (!isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                context = args.shift();
            }
            return {
                context: context,
                args: args
            };
        }
        var fixSyntheticEventsOnDisabled = false;
        (function () {
            if (!isBrowserWindow()) {
                return;
            }
            var testEventName = 'fix_synthetic_events_on_disabled_test';
            var input = document.createElement('input');
            input.disabled = true;
            var timer = setTimeout(function () {
                fixSyntheticEventsOnDisabled = true;
            }, 50);
            var onTest = function onTest() {
                clearTimeout(timer);
                input.removeEventListener(testEventName, onTest);
            };
            input.addEventListener(testEventName, onTest);
            try {
                var event = document.create('HTMLEvents');
                event.initEvent(testEventName, false);
                input.dispatchEvent(event);
            } catch (e) {
                onTest();
                fixSyntheticEventsOnDisabled = true;
            }
        }());
        function isDispatchingOnDisabled(element, event) {
            var eventType = event.type;
            var isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';
            var isDisabled = !!element.disabled;
            return isInsertedOrRemoved && isDisabled;
        }
        function forceEnabledForDispatch(element, event) {
            return fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);
        }
        module.exports = {
            createEvent: createEvent,
            addDomContext: addDomContext,
            removeDomContext: removeDomContext,
            isDomEventTarget: isDomEventTarget,
            getTargetDocument: getTargetDocument,
            forceEnabledForDispatch: forceEnabledForDispatch
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-events@1.3.10#helpers/make-event-registry*/
define('can-dom-events@1.3.10#helpers/make-event-registry', function (require, exports, module) {
    'use strict';
    function EventRegistry() {
        this._registry = {};
    }
    module.exports = function makeEventRegistry() {
        return new EventRegistry();
    };
    EventRegistry.prototype.has = function (eventType) {
        return !!this._registry[eventType];
    };
    EventRegistry.prototype.get = function (eventType) {
        return this._registry[eventType];
    };
    EventRegistry.prototype.add = function (event, eventType) {
        if (!event) {
            throw new Error('An EventDefinition must be provided');
        }
        if (typeof event.addEventListener !== 'function') {
            throw new TypeError('EventDefinition addEventListener must be a function');
        }
        if (typeof event.removeEventListener !== 'function') {
            throw new TypeError('EventDefinition removeEventListener must be a function');
        }
        eventType = eventType || event.defaultEventType;
        if (typeof eventType !== 'string') {
            throw new TypeError('Event type must be a string, not ' + eventType);
        }
        if (this.has(eventType)) {
            throw new Error('Event "' + eventType + '" is already registered');
        }
        this._registry[eventType] = event;
        var self = this;
        return function remove() {
            self._registry[eventType] = undefined;
        };
    };
});
/*can-key-tree@1.2.1#can-key-tree*/
define('can-key-tree@1.2.1#can-key-tree', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var reflect = require('can-reflect');
    function isBuiltInPrototype(obj) {
        if (obj === Object.prototype) {
            return true;
        }
        var protoString = Object.prototype.toString.call(obj);
        var isNotObjObj = protoString !== '[object Object]';
        var isObjSomething = protoString.indexOf('[object ') !== -1;
        return isNotObjObj && isObjSomething;
    }
    function getDeepSize(root, level) {
        if (level === 0) {
            return reflect.size(root);
        } else if (reflect.size(root) === 0) {
            return 0;
        } else {
            var count = 0;
            reflect.each(root, function (value) {
                count += getDeepSize(value, level - 1);
            });
            return count;
        }
    }
    function getDeep(node, items, depth, maxDepth) {
        if (!node) {
            return;
        }
        if (maxDepth === depth) {
            if (reflect.isMoreListLikeThanMapLike(node)) {
                reflect.addValues(items, reflect.toArray(node));
            } else {
                throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');
            }
        } else {
            reflect.each(node, function (value) {
                getDeep(value, items, depth + 1, maxDepth);
            });
        }
    }
    function clearDeep(node, keys, maxDepth, deleteHandler) {
        if (maxDepth === keys.length) {
            if (reflect.isMoreListLikeThanMapLike(node)) {
                var valuesToRemove = reflect.toArray(node);
                if (deleteHandler) {
                    valuesToRemove.forEach(function (value) {
                        deleteHandler.apply(null, keys.concat(value));
                    });
                }
                reflect.removeValues(node, valuesToRemove);
            } else {
                throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');
            }
        } else {
            reflect.each(node, function (value, key) {
                clearDeep(value, keys.concat(key), maxDepth, deleteHandler);
                reflect.deleteKeyValue(node, key);
            });
        }
    }
    var KeyTree = function (treeStructure, callbacks) {
        var FirstConstructor = treeStructure[0];
        if (reflect.isConstructorLike(FirstConstructor)) {
            this.root = new FirstConstructor();
        } else {
            this.root = FirstConstructor;
        }
        this.callbacks = callbacks || {};
        this.treeStructure = treeStructure;
        this.empty = true;
    };
    reflect.assign(KeyTree.prototype, {
        add: function (keys) {
            if (keys.length > this.treeStructure.length) {
                throw new Error('can-key-tree: Can not add path deeper than tree.');
            }
            var place = this.root;
            var rootWasEmpty = this.empty === true;
            for (var i = 0; i < keys.length - 1; i++) {
                var key = keys[i];
                var childNode = reflect.getKeyValue(place, key);
                if (!childNode) {
                    var Constructor = this.treeStructure[i + 1];
                    if (isBuiltInPrototype(Constructor.prototype)) {
                        childNode = new Constructor();
                    } else {
                        childNode = new Constructor(key);
                    }
                    reflect.setKeyValue(place, key, childNode);
                }
                place = childNode;
            }
            if (reflect.isMoreListLikeThanMapLike(place)) {
                reflect.addValues(place, [keys[keys.length - 1]]);
            } else {
                throw new Error('can-key-tree: Map types are not supported yet.');
            }
            if (rootWasEmpty) {
                this.empty = false;
                if (this.callbacks.onFirst) {
                    this.callbacks.onFirst.call(this);
                }
            }
            return this;
        },
        getNode: function (keys) {
            var node = this.root;
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                node = reflect.getKeyValue(node, key);
                if (!node) {
                    return;
                }
            }
            return node;
        },
        get: function (keys) {
            var node = this.getNode(keys);
            if (this.treeStructure.length === keys.length) {
                return node;
            } else {
                var Type = this.treeStructure[this.treeStructure.length - 1];
                var items = new Type();
                getDeep(node, items, keys.length, this.treeStructure.length - 1);
                return items;
            }
        },
        delete: function (keys, deleteHandler) {
            var parentNode = this.root, path = [this.root], lastKey = keys[keys.length - 1];
            for (var i = 0; i < keys.length - 1; i++) {
                var key = keys[i];
                var childNode = reflect.getKeyValue(parentNode, key);
                if (childNode === undefined) {
                    return false;
                } else {
                    path.push(childNode);
                }
                parentNode = childNode;
            }
            if (!keys.length) {
                clearDeep(parentNode, [], this.treeStructure.length - 1, deleteHandler);
            } else if (keys.length === this.treeStructure.length) {
                if (reflect.isMoreListLikeThanMapLike(parentNode)) {
                    if (deleteHandler) {
                        deleteHandler.apply(null, keys.concat(lastKey));
                    }
                    reflect.removeValues(parentNode, [lastKey]);
                } else {
                    throw new Error('can-key-tree: Map types are not supported yet.');
                }
            } else {
                var nodeToRemove = reflect.getKeyValue(parentNode, lastKey);
                if (nodeToRemove !== undefined) {
                    clearDeep(nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler);
                    reflect.deleteKeyValue(parentNode, lastKey);
                } else {
                    return false;
                }
            }
            for (i = path.length - 2; i >= 0; i--) {
                if (reflect.size(parentNode) === 0) {
                    parentNode = path[i];
                    reflect.deleteKeyValue(parentNode, keys[i]);
                } else {
                    break;
                }
            }
            if (reflect.size(this.root) === 0) {
                this.empty = true;
                if (this.callbacks.onEmpty) {
                    this.callbacks.onEmpty.call(this);
                }
            }
            return true;
        },
        size: function () {
            return getDeepSize(this.root, this.treeStructure.length - 1);
        },
        isEmpty: function () {
            return this.empty;
        }
    });
    module.exports = KeyTree;
});
/*can-dom-events@1.3.10#helpers/-make-delegate-event-tree*/
define('can-dom-events@1.3.10#helpers/-make-delegate-event-tree', [
    'require',
    'exports',
    'module',
    'can-key-tree',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var KeyTree = require('can-key-tree');
    var canReflect = require('can-reflect');
    var useCapture = function (eventType) {
        return eventType === 'focus' || eventType === 'blur';
    };
    function makeDelegator(domEvents) {
        var Delegator = function Delegator(parentKey) {
            this.element = parentKey;
            this.events = {};
            this.delegated = {};
        };
        canReflect.assignSymbols(Delegator.prototype, {
            'can.setKeyValue': function (eventType, handlersBySelector) {
                var handler = this.delegated[eventType] = function (ev) {
                    var cur = ev.target;
                    var propagate = true;
                    var origStopPropagation = ev.stopPropagation;
                    ev.stopPropagation = function () {
                        origStopPropagation.apply(this, arguments);
                        propagate = false;
                    };
                    var origStopImmediatePropagation = ev.stopImmediatePropagation;
                    ev.stopImmediatePropagation = function () {
                        origStopImmediatePropagation.apply(this, arguments);
                        propagate = false;
                    };
                    do {
                        var el = cur === document ? document.documentElement : cur;
                        var matches = el.matches || el.msMatchesSelector;
                        canReflect.each(handlersBySelector, function (handlers, selector) {
                            if (matches && matches.call(el, selector)) {
                                handlers.forEach(function (handler) {
                                    handler.call(el, ev);
                                });
                            }
                        });
                        cur = cur.parentNode;
                    } while (cur && cur !== ev.currentTarget && propagate);
                };
                this.events[eventType] = handlersBySelector;
                domEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));
            },
            'can.getKeyValue': function (eventType) {
                return this.events[eventType];
            },
            'can.deleteKeyValue': function (eventType) {
                domEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));
                delete this.delegated[eventType];
                delete this.events[eventType];
            },
            'can.getOwnEnumerableKeys': function () {
                return Object.keys(this.events);
            }
        });
        return Delegator;
    }
    module.exports = function makeDelegateEventTree(domEvents) {
        var Delegator = makeDelegator(domEvents);
        return new KeyTree([
            Map,
            Delegator,
            Object,
            Array
        ]);
    };
});
/*can-dom-events@1.3.10#can-dom-events*/
define('can-dom-events@1.3.10#can-dom-events', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './helpers/util',
    './helpers/make-event-registry',
    './helpers/-make-delegate-event-tree'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var util = require('./helpers/util');
        var makeEventRegistry = require('./helpers/make-event-registry');
        var makeDelegateEventTree = require('./helpers/-make-delegate-event-tree');
        var domEvents = {
            _eventRegistry: makeEventRegistry(),
            addEvent: function (event, eventType) {
                return this._eventRegistry.add(event, eventType);
            },
            addEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.addEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.addEventListener.apply(target, eventArgs);
            },
            removeEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.removeEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.removeEventListener.apply(target, eventArgs);
            },
            addDelegateListener: function (root, eventType, selector, handler) {
                domEvents._eventTree.add([
                    root,
                    eventType,
                    selector,
                    handler
                ]);
            },
            removeDelegateListener: function (target, eventType, selector, handler) {
                domEvents._eventTree.delete([
                    target,
                    eventType,
                    selector,
                    handler
                ]);
            },
            dispatch: function (target, eventData, bubbles, cancelable) {
                var event = util.createEvent(target, eventData, bubbles, cancelable);
                var enableForDispatch = util.forceEnabledForDispatch(target, event);
                if (enableForDispatch) {
                    target.disabled = false;
                }
                var ret = target.dispatchEvent(event);
                if (enableForDispatch) {
                    target.disabled = true;
                }
                return ret;
            }
        };
        domEvents._eventTree = makeDelegateEventTree(domEvents);
        module.exports = namespace.domEvents = domEvents;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.7#events/events*/
define('can-dom-mutate@1.3.7#events/events', [
    'require',
    'exports',
    'module',
    '../can-dom-mutate',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var domMutate = require('../can-dom-mutate');
    var namespace = require('can-namespace');
    function makeMutationEvent(defaultEventType, subscription, bubbles) {
        var elementSubscriptions = new Map();
        return {
            _subscriptions: elementSubscriptions,
            defaultEventType: defaultEventType,
            addEventListener: function (target, eventType, handler) {
                var dispatch = this.dispatch;
                var data = elementSubscriptions.get(target);
                if (!data) {
                    data = {
                        removeListener: null,
                        listeners: new Set()
                    };
                    elementSubscriptions.set(target, data);
                }
                if (data.listeners.size === 0) {
                    data.removeListener = subscription(target, function (mutation) {
                        var eventData = { type: eventType };
                        for (var key in mutation) {
                            eventData[key] = mutation[key];
                        }
                        dispatch(target, eventData, bubbles !== false);
                    });
                }
                data.listeners.add(handler);
                target.addEventListener(eventType, handler);
            },
            removeEventListener: function (target, eventType, handler) {
                target.removeEventListener(eventType, handler);
                var data = elementSubscriptions.get(target);
                if (data) {
                    data.listeners['delete'](handler);
                    if (data.listeners.size === 0) {
                        data.removeListener();
                        elementSubscriptions['delete'](target);
                    }
                }
            }
        };
    }
    module.exports = namespace.domMutateDomEvents = {
        attributes: makeMutationEvent('attributes', domMutate.onNodeAttributeChange),
        inserted: makeMutationEvent('inserted', domMutate.onNodeConnected, false),
        removed: makeMutationEvent('removed', domMutate.onNodeDisconnected)
    };
});
/*can-dom-mutate@1.3.7#events/events-test*/
define('can-dom-mutate@1.3.7#events/events-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-dom-events',
    '../can-dom-mutate',
    './events',
    '../node/node',
    '../test/test-utils'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var domEvents = require('can-dom-events');
    var domMutate = require('../can-dom-mutate');
    var domMutateDomEvents = require('./events');
    var node = require('../node/node');
    var testUtils = require('../test/test-utils');
    var test = unit.test;
    testUtils.moduleWithMutationObserver('can-dom-mutate/dom-events', function () {
        QUnit.test('inserted', function (assert) {
            domMutate.flushRecords();
            var done = assert.async();
            var fixture = testUtils.getFixture();
            var parent = document.createElement('div');
            var child = document.createElement('p');
            var parentInsertedHandler, childInsertedHandler, removeonConnectedHandler;
            domEvents.addEvent(domMutateDomEvents.inserted);
            var cleanup = function () {
                domEvents.removeEventListener(parent, 'inserted', parentInsertedHandler);
                domEvents.removeEventListener(child, 'inserted', childInsertedHandler);
                removeonConnectedHandler();
                delete domEvents._eventRegistry._registry.inserted;
                done();
            };
            var insertedEventCount = 0;
            parentInsertedHandler = function () {
                insertedEventCount++;
            };
            domEvents.addEventListener(parent, 'inserted', parentInsertedHandler);
            childInsertedHandler = function () {
            };
            domEvents.addEventListener(child, 'inserted', childInsertedHandler);
            var onNodeConnectedCount = 0;
            removeonConnectedHandler = domMutate.onConnected(document.documentElement, function (arg) {
                switch (onNodeConnectedCount) {
                case 0:
                    assert.equal(insertedEventCount, 1, 'inserted event should trigger for event.currentTarget');
                    node.appendChild.call(parent, child);
                    break;
                case 1:
                    assert.equal(insertedEventCount, 1, 'inserted event should NOT trigger for child of event.currentTarget');
                    setTimeout(cleanup, 100);
                    break;
                }
                onNodeConnectedCount++;
            });
            node.appendChild.call(fixture, parent);
        });
    });
});
/*can-dom-mutate@1.3.7#node/node-test*/
define('can-dom-mutate@1.3.7#node/node-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../can-dom-mutate',
    'can-globals/document/document',
    './node',
    '../test/test-utils',
    'can-vdom/make-document/make-document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var unit = require('steal-qunit');
        var domMutate = require('../can-dom-mutate');
        var getDocument = require('can-globals/document/document');
        var node = require('./node');
        var testUtils = require('../test/test-utils');
        var makeSimpleDocument = require('can-vdom/make-document/make-document');
        var test = unit.test;
        var moduleWithMutationObserver = testUtils.moduleWithMutationObserver;
        var moduleWithoutMutationObserver = testUtils.moduleWithoutMutationObserver;
        var moduleMutationObserver = testUtils.moduleMutationObserver;
        var mock = testUtils.mock;
        function neverCall(assert, obj, methodName) {
            return mock(obj, methodName, function () {
                assert.ok(false, methodName + ' should not be called');
            });
        }
        function onNodeRemovedTest() {
            test('removeChild dispatches onNodeRemoved', function (assert) {
                var done = assert.async();
                var parent = testUtils.getFixture();
                var child = document.createElement('div');
                parent.appendChild(child);
                var undo = domMutate.onNodeRemoved(child, function () {
                    assert.ok(true, 'this was called');
                    undo();
                    done();
                });
                node.removeChild.call(parent, child);
            });
        }
        moduleMutationObserver('can-dom-mutate/node with real document', getDocument(), onNodeRemovedTest);
        moduleMutationObserver('can-dom-mutate/node with SimpleDocument', makeSimpleDocument(), onNodeRemovedTest);
        moduleWithMutationObserver('can-dom-mutate/node', function () {
            QUnit.test('appendChild should not call domMutate.dispatchNodeInsertion', function (assert) {
                var parent = testUtils.getFixture();
                var child = document.createElement('div');
                var undo = neverCall(assert, domMutate, 'dispatchNodeInsertion');
                node.appendChild.call(parent, child);
                undo();
                assert.ok(parent.contains(child), 'child should be in parent');
            });
            QUnit.test('insertBefore should not call domMutate.dispatchNodeInsertion', function (assert) {
                var parent = testUtils.getFixture();
                var sibling = document.createElement('span');
                var child = document.createElement('div');
                var undo = neverCall(assert, domMutate, 'dispatchNodeInsertion');
                parent.appendChild(sibling);
                node.insertBefore.call(parent, child, sibling);
                undo();
                assert.ok(parent.contains(child), 'child should be in parent');
            });
            QUnit.test('removeChild should not call domMutate.dispatchNodeRemoval', function (assert) {
                var parent = testUtils.getFixture();
                var child = document.createElement('div');
                var undo = neverCall(assert, domMutate, 'dispatchNodeRemoval');
                parent.appendChild(child);
                node.removeChild.call(parent, child);
                undo();
                assert.ok(!parent.contains(child), 'child should not be in parent');
            });
            QUnit.test('replaceChild should not call domMutate.dispatchNodeRemoval+Insertion', function (assert) {
                var parent = testUtils.getFixture();
                var sibling = document.createElement('span');
                var child = document.createElement('div');
                var undoRemoval = neverCall(assert, domMutate, 'dispatchNodeRemoval');
                var undoInsertion = neverCall(assert, domMutate, 'dispatchNodeInsertion');
                parent.appendChild(sibling);
                node.replaceChild.call(parent, child, sibling);
                undoRemoval();
                undoInsertion();
                assert.ok(!parent.contains(sibling), 'sibling should not be in parent');
                assert.ok(parent.contains(child), 'child should be in parent');
            });
            QUnit.test('setAttribute should not call domMutate.dispatchNodeAttributeChange', function (assert) {
                var parent = testUtils.getFixture();
                var element = document.createElement('div');
                var undo = neverCall(assert, domMutate, 'dispatchNodeAttributeChange');
                parent.appendChild(element);
                node.setAttribute.call(element, 'data-foo', 'bar');
                undo();
                assert.equal(element.getAttribute('data-foo'), 'bar', 'Attribute should be set');
            });
            QUnit.test('removeAttribute should not call domMutate.dispatchNodeAttributeChange', function (assert) {
                var parent = testUtils.getFixture();
                var element = document.createElement('div');
                var undo = neverCall(assert, domMutate, 'dispatchNodeAttributeChange');
                parent.appendChild(element);
                node.removeAttribute.call(element, 'data-foo');
                node.setAttribute.call(element, 'data-foo', 'bar');
                node.removeAttribute.call(element, 'data-foo');
                undo();
                assert.equal(element.getAttribute('data-foo'), null, 'Attribute should not be set');
            });
        });
        function withoutMutationObserverTests() {
            QUnit.test('appendChild should call domMutate.dispatchNodeInsertion', function (assert) {
                var doc = getDocument();
                var done = assert.async();
                var parent = testUtils.getFixture();
                var child = doc.createElement('div');
                var undo = mock(domMutate, 'dispatchNodeInsertion', function (node, callback) {
                    assert.equal(node, child, 'Should pass the child being appended');
                    assert.equal(callback, undefined, 'Should not pass a callback');
                    assert.ok(parent.contains(node), 'Node should be in parent before dispatch is called');
                    undo();
                    done();
                });
                node.appendChild.call(parent, child);
            });
            function getFragmentInsertionTest() {
                var doc = getDocument();
                var fragment = doc.createDocumentFragment();
                var child1 = doc.createElement('div');
                var child2 = doc.createElement('div');
                var grandchild = doc.createElement('div');
                fragment.appendChild(child1);
                fragment.appendChild(child2);
                child2.appendChild(grandchild);
                return {
                    fragment: fragment,
                    check: function (assert) {
                        var nodes = [
                            child1,
                            child2
                        ];
                        var dispatches = 0;
                        var undoInsertion = mock(domMutate, 'dispatchNodeInsertion', function (node) {
                            dispatches++;
                            assert.ok(nodes.indexOf(node) !== -1, 'child node added');
                            if (dispatches >= nodes.length) {
                                undoInsertion();
                            }
                        });
                    }
                };
            }
            QUnit.test('appendChild should dispatch fragment children to dispatchNodeInserted', function (assert) {
                assert.expect(2);
                var parent = testUtils.getFixture();
                var fragTest = getFragmentInsertionTest();
                fragTest.check(assert);
                node.appendChild.call(parent, fragTest.fragment);
            });
            QUnit.test('insertBefore should call domMutate.dispatchNodeInsertion', function (assert) {
                var done = assert.async();
                var doc = getDocument();
                var parent = testUtils.getFixture();
                var sibling = doc.createElement('span');
                var child = doc.createElement('div');
                var undo = mock(domMutate, 'dispatchNodeInsertion', function (node, callback) {
                    assert.equal(node, child, 'Should pass the child being appended');
                    assert.equal(callback, undefined, 'Should not pass a callback');
                    assert.ok(parent.contains(node), 'Node should be in parent before dispatch is called');
                    undo();
                    done();
                });
                parent.appendChild(sibling);
                node.insertBefore.call(parent, child, sibling);
            });
            QUnit.test('insertBefore should dispatch fragment children to dispatchNodeInserted', function (assert) {
                assert.expect(2);
                var doc = getDocument();
                var parent = testUtils.getFixture();
                var sibling = doc.createElement('div');
                parent.appendChild(sibling);
                var fragTest = getFragmentInsertionTest();
                fragTest.check(assert);
                node.insertBefore.call(parent, fragTest.fragment, sibling);
            });
            QUnit.test('removeChild should call domMutate.dispatchNodeRemoval', function (assert) {
                var done = assert.async();
                var doc = getDocument();
                var parent = testUtils.getFixture();
                var child = doc.createElement('div');
                var undo = mock(domMutate, 'dispatchNodeRemoval', function (node, callback) {
                    assert.equal(node, child, 'Should pass the child being removed');
                    assert.equal(callback, undefined, 'Should not pass a callback');
                    assert.ok(!parent.contains(node), 'Node should be removed before dispatch is called');
                    undo();
                    done();
                });
                parent.appendChild(child);
                node.removeChild.call(parent, child);
            });
            QUnit.test('replaceChild should call domMutate.dispatchNodeRemoval+Insertion', function (assert) {
                var done = assert.async();
                var doc = getDocument();
                var parent = testUtils.getFixture();
                var sibling = doc.createElement('span');
                var child = doc.createElement('div');
                var isSiblingRemoved = false;
                var undoRemoval = mock(domMutate, 'dispatchNodeRemoval', function (node, callback) {
                    assert.equal(node, sibling, 'Should pass the sibling being removed');
                    assert.equal(callback, undefined, 'Should not pass a callback');
                    assert.ok(!parent.contains(node), 'Node should be removed before dispatch is called');
                    undoRemoval();
                    isSiblingRemoved = true;
                });
                var undoInsertion = mock(domMutate, 'dispatchNodeInsertion', function (node, callback) {
                    assert.ok(isSiblingRemoved, 'Sibling should be removed before the child is inserted (as far as dispatch order is concerned)');
                    assert.equal(node, child, 'Should pass the child being inserted');
                    assert.equal(callback, undefined, 'Should not pass a callback');
                    assert.ok(parent.contains(node), 'Node should be inserted before dispatch is called');
                    undoInsertion();
                    done();
                });
                parent.appendChild(sibling);
                node.replaceChild.call(parent, child, sibling);
            });
            QUnit.test('replaceChild should dispatch fragment children to dispatchNodeInserted', function (assert) {
                assert.expect(3);
                var doc = getDocument();
                var parent = testUtils.getFixture();
                var sibling = doc.createElement('div');
                parent.appendChild(sibling);
                var fragTest = getFragmentInsertionTest();
                fragTest.check(assert);
                var undoRemoval = mock(domMutate, 'dispatchNodeRemoval', function (node) {
                    assert.equal(node, sibling, 'sibling should be removed');
                    undoRemoval();
                });
                node.replaceChild.call(parent, fragTest.fragment, sibling);
            });
            QUnit.test('setAttribute should call domMutate.dispatchNodeAttributeChange', function (assert) {
                var done = assert.async();
                var doc = getDocument();
                var element = doc.createElement('div');
                element.setAttribute('data-foo', 'bar');
                var undo = mock(domMutate, 'dispatchNodeAttributeChange', function (node, attributeName, oldAttributeValue, callback) {
                    assert.equal(node, element, 'Should pass the element whose attribute is changing');
                    assert.equal(attributeName, 'data-foo', 'Should pass the changed attribute name');
                    assert.equal(oldAttributeValue, 'bar', 'Should pass the old attribute value');
                    assert.equal(callback, undefined, 'Should not pass a callback');
                    assert.equal(element.getAttribute('data-foo'), 'baz', 'Node should have the new attribute value');
                    undo();
                    done();
                });
                node.setAttribute.call(element, 'data-foo', 'baz');
            });
            QUnit.test('removeAttribute should call domMutate.dispatchNodeAttributeChange', function (assert) {
                var done = assert.async();
                var doc = getDocument();
                var element = doc.createElement('div');
                element.setAttribute('data-foo', 'bar');
                var undo = mock(domMutate, 'dispatchNodeAttributeChange', function (node, attributeName, oldAttributeValue, callback) {
                    assert.equal(node, element, 'Should pass the element whose attribute is changing');
                    assert.equal(attributeName, 'data-foo', 'Should pass the changed attribute name');
                    assert.equal(oldAttributeValue, 'bar', 'Should pass the old attribute value');
                    assert.equal(callback, undefined, 'Should not pass a callback');
                    assert.equal(element.getAttribute('data-foo'), null, 'Node attribute value should have been removed');
                    undo();
                    done();
                });
                node.removeAttribute.call(element, 'data-foo');
            });
        }
        ;
        moduleWithoutMutationObserver('can-dom-mutate/node with real document', getDocument(), withoutMutationObserverTests);
        moduleWithoutMutationObserver('can-dom-mutate/node with SimpleDocument', makeSimpleDocument(), withoutMutationObserverTests);
        function notInDocumentTests() {
            QUnit.test('appendChild should not call dispatchNodeInsertion', function (assert) {
                assert.expect(1);
                var doc = getDocument();
                var fragment = doc.createDocumentFragment();
                var child = doc.createElement('div');
                var undo = mock(domMutate, 'dispatchNodeInsertion', function (el, callback, dispatchConnected) {
                    assert.equal(dispatchConnected, false, 'We should not dispatch connected things');
                });
                node.appendChild.call(fragment, child);
                undo();
            });
            QUnit.test('insertBefore should not call dispatchNodeInsertion', function (assert) {
                assert.expect(1);
                var doc = getDocument();
                var fragment = doc.createDocumentFragment();
                var child = doc.createElement('div');
                var reference = doc.createElement('span');
                fragment.appendChild(reference);
                var undo = mock(domMutate, 'dispatchNodeInsertion', function (el, callback, dispatchConnected) {
                    assert.equal(dispatchConnected, false, 'We should not dispatch connected things');
                });
                node.insertBefore.call(fragment, child, reference);
                undo();
            });
            QUnit.test('removeChild should not call dispatchNodeRemoval', function (assert) {
                assert.expect(1);
                var doc = getDocument();
                var fragment = doc.createDocumentFragment();
                var child = doc.createElement('div');
                fragment.appendChild(child);
                var undo = mock(domMutate, 'dispatchNodeRemoval', function (el, callback, dispatchConnected) {
                    assert.equal(dispatchConnected, false, 'We should not dispatch connected things');
                });
                node.removeChild.call(fragment, child);
                undo();
            });
            QUnit.test('replaceChild should not call dispatchNodeRemoval+Insertion', function (assert) {
                assert.expect(2);
                var doc = getDocument();
                var fragment = doc.createDocumentFragment();
                var child = doc.createElement('div');
                var oldChild = doc.createElement('span');
                fragment.appendChild(oldChild);
                var undoRemoval = mock(domMutate, 'dispatchNodeRemoval', function (el, callback, dispatchConnected) {
                    assert.equal(dispatchConnected, false, 'We should not dispatch connected things');
                });
                var undoInsertion = mock(domMutate, 'dispatchNodeInsertion', function (el, callback, dispatchConnected) {
                    assert.equal(dispatchConnected, false, 'We should not dispatch connected things');
                });
                node.replaceChild.call(fragment, child, oldChild);
                undoRemoval();
                undoInsertion();
            });
            QUnit.test('removeChild on the documentElement', function (assert) {
                var done = assert.async();
                var doc = getDocument();
                var doc1 = doc.implementation.createHTMLDocument('doc1');
                getDocument(doc1);
                var undo = domMutate.onNodeDisconnected(doc1.documentElement, function () {
                    assert.ok(true, 'this was called');
                    undo();
                    done();
                });
                node.removeChild.call(doc1, doc1.documentElement);
                getDocument(doc);
            });
        }
        moduleWithoutMutationObserver('can-dom-mutate/node (not in real document)', getDocument(), notInDocumentTests);
        moduleWithoutMutationObserver('can-dom-mutate/node (not in SimpleDocument)', makeSimpleDocument(), notInDocumentTests);
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.3.7#test*/
define('can-dom-mutate@1.3.7#test', [
    './test/can-dom-mutate-test',
    './events/events-test',
    './node/node-test'
], function () {
    'use strict';
});