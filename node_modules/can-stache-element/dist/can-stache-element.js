"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var namespace = require("can-namespace");

var mixinLifecycleMethods = require("./mixin-lifecycle-methods");

var mixinProps = require("./mixin-props");

var mixinStacheView = require("./mixin-stache-view");

var mixinViewModelSymbol = require("./mixin-viewmodel-symbol");

var mixinBindings = require("./mixin-bindings");

var mixinInitializeBindings = require("./mixin-initialize-bindings");

var mixinBindBehaviour = require("./mixin-bind-behaviour");

var _require = require("./mixin-bind-behaviour"),
    initializeObservedAttributes = _require.initializeObservedAttributes;

var canStacheBindings = require("can-stache-bindings");

var _require2 = require("can-observable-mixin"),
    createConstructorFunction = _require2.createConstructorFunction;

var initializeSymbol = Symbol.for("can.initialize");
var teardownHandlersSymbol = Symbol.for("can.teardownHandlers");
var isViewSymbol = Symbol.for("can.isView");

var Scope = require("can-view-scope"); // Calling a renderer like {{foo()}} gets the template scope
// added no matter what. This checks for that condition.
// https://github.com/canjs/can-stache/issues/719


function rendererWasCalledWithData(scope) {
  return scope instanceof Scope && scope._parent && scope._parent._context instanceof Scope.TemplateContext;
}

function addContext(rawRenderer, tagData) {
  function renderer(data) {
    if (rendererWasCalledWithData(data)) {
      return rawRenderer(tagData.scope.addLetContext(data._context));
    } else {
      // if it was called programmatically (not in stache), just add the data
      return rawRenderer(tagData.scope.addLetContext(data));
    }
  } // Marking as a view will add the template scope ... but it should
  // already be present in `tagData.scope`.
  // However, I mark this as a renderer because that is what it is.


  renderer[isViewSymbol] = true;
  return renderer;
}

function DeriveElement() {
  var BaseElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HTMLElement;

  var StacheElement = /*#__PURE__*/function (_mixinLifecycleMethod) {
    _inherits(StacheElement, _mixinLifecycleMethod);

    var _super = _createSuper(StacheElement);

    function StacheElement() {
      _classCallCheck(this, StacheElement);

      return _super.apply(this, arguments);
    }

    _createClass(StacheElement, [{
      key: initializeSymbol,
      value: function value(el, tagData) {
        var teardownBindings = canStacheBindings.behaviors.viewModel(el, tagData, function makeViewModel(initialViewmodelData) {
          for (var prop in tagData.templates) {
            // It's ok to modify the argument. The argument is created
            // just for what gets passed into creating the VM.
            initialViewmodelData[prop] = addContext(tagData.templates[prop], tagData);
          }

          el.render(initialViewmodelData);
          return el;
        });

        if (el[teardownHandlersSymbol]) {
          el[teardownHandlersSymbol].push(teardownBindings);
        }
      }
    }]);

    return StacheElement;
  }( // add lifecycle methods
  // this needs to happen after other mixins that implement these methods
  // so that this.<lifecycleMethod> is the actual lifecycle method which
  // controls whether the methods farther "down" the chain are called
  mixinLifecycleMethods( // mixin .bindings() method and behavior
  mixinBindings( // Find all prop definitions and extract `{ bind: () => {} }` for binding initialization
  mixinBindBehaviour( // Initialize the bindings
  mixinInitializeBindings( // mix in viewModel symbol used by can-stache-bindings
  mixinViewModelSymbol( // mix in stache renderer from `static view` property
  mixinStacheView( // add getters/setters from `static props` property
  mixinProps(BaseElement))))))));

  var StacheElementConstructorFunction = createConstructorFunction(StacheElement); // Initialize the `observedAttributes`

  initializeObservedAttributes(StacheElementConstructorFunction);
  return StacheElementConstructorFunction;
}

module.exports = namespace.StacheElement = DeriveElement();