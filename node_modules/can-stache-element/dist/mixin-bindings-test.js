"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var QUnit = require("steal-qunit");

var StacheElement = require("./can-stache-element");

var value = require("can-value");

var SimpleObservable = require("can-simple-observable");

var testHelpers = require("../test/helpers");

var browserSupports = testHelpers.browserSupports;

var canReflect = require("can-reflect");

var fixture;
QUnit.module("can-stache-element - mixin-bindings", {
  beforeEach: function beforeEach() {
    fixture = document.querySelector("#qunit-fixture");
  }
});

if (browserSupports.customElements) {
  QUnit.test("basics work", function (assert) {
    var done = assert.async();

    var BasicBindingsElement = /*#__PURE__*/function (_StacheElement) {
      _inherits(BasicBindingsElement, _StacheElement);

      var _super = _createSuper(BasicBindingsElement);

      function BasicBindingsElement() {
        _classCallCheck(this, BasicBindingsElement);

        return _super.apply(this, arguments);
      }

      _createClass(BasicBindingsElement, null, [{
        key: "view",
        get: function get() {
          return "<h1>{{message}}</h1>";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            message: {
              type: String,
              default: "Hi"
            }
          };
        }
      }]);

      return BasicBindingsElement;
    }(StacheElement);

    customElements.define("basic-bindings", BasicBindingsElement);
    var basicBindingsElement = new BasicBindingsElement();
    var messageObservable = value.with("Hello");
    basicBindingsElement.bindings({
      message: messageObservable
    });
    assert.equal(basicBindingsElement.message, "Hi", "properties initialized later"); //-> The binding should really only happen once inserted ...
    // -> Folks could call `var el = new Element().bindings({}).initialize()`
    // INSERT ELEMENT

    fixture.appendChild(basicBindingsElement);
    testHelpers.afterMutation(function () {
      assert.equal(basicBindingsElement.message, "Hello", "properties initialized");
      assert.equal(basicBindingsElement.innerHTML, "<h1>Hello</h1>", "template rendered"); // UPDATE observable

      messageObservable.value = "HOWDY";
      assert.equal(basicBindingsElement.message, "HOWDY", "element property value changed");
      assert.equal(basicBindingsElement.innerHTML, "<h1>HOWDY</h1>", "html updated");
      testHelpers.afterMutation(function () {
        // UPDATE element
        basicBindingsElement.message = "Hola!";
        assert.equal(messageObservable.value, "Hola!", "observable updated via two-way binding"); // REMOVE ELEMENT

        fixture.removeChild(basicBindingsElement);
        testHelpers.afterMutation(function () {
          //basicBindingsElement[state].isInitialized //-> false

          /* Question 2: Should we blow away the innerHTML?
           *  + It won't be live anymore
           *  - It will be unnecessarily expensive to do this
           * */
          assert.equal(canReflect.isBound(messageObservable), false, "the observable is not bound");
          assert.equal(canReflect.isBound(basicBindingsElement), false, "the element is not bound"); // INSERT ELEMENT AGAIN

          messageObservable.value = "GOODBYE";
          fixture.appendChild(basicBindingsElement);
          testHelpers.afterMutation(function () {
            assert.equal(basicBindingsElement.message, "GOODBYE", "properties initialized after re-insertion");
            assert.equal(basicBindingsElement.innerHTML, "<h1>GOODBYE</h1>", "template rendered");
            done();
          });
        });
      });
    });
  });
  QUnit.test("Everything is properly torn down", function (assert) {
    var done = assert.async();
    var oneId = 0,
        twoId = 0;

    var One = /*#__PURE__*/function (_StacheElement2) {
      _inherits(One, _StacheElement2);

      var _super2 = _createSuper(One);

      function One() {
        _classCallCheck(this, One);

        return _super2.apply(this, arguments);
      }

      _createClass(One, [{
        key: "setId",
        value: function setId(val) {
          oneId = val;
        }
      }], [{
        key: "view",
        get: function get() {
          return "\n\t\t\t\t\t{{this.setId(id)}}\n\t\t\t\t\t<p id=\"oneid\">{{id}}</p>\n\t\t\t\t";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            id: Number
          };
        }
      }]);

      return One;
    }(StacheElement);

    customElements.define("o-ne", One);

    var Two = /*#__PURE__*/function (_StacheElement3) {
      _inherits(Two, _StacheElement3);

      var _super3 = _createSuper(Two);

      function Two() {
        _classCallCheck(this, Two);

        return _super3.apply(this, arguments);
      }

      _createClass(Two, [{
        key: "setId",
        value: function setId(val) {
          twoId = val;
        }
      }], [{
        key: "view",
        get: function get() {
          return "\n\t\t\t\t\t{{this.setId(id)}}\n\t\t\t\t\t<p id=\"twoid\">{{id}}</p>\n\t\t\t\t";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            id: Number
          };
        }
      }]);

      return Two;
    }(StacheElement);

    customElements.define("t-wo", Two);

    var App = /*#__PURE__*/function (_StacheElement4) {
      _inherits(App, _StacheElement4);

      var _super4 = _createSuper(App);

      function App() {
        _classCallCheck(this, App);

        return _super4.apply(this, arguments);
      }

      _createClass(App, [{
        key: "increment",
        value: function increment() {
          this.id++;
        }
      }], [{
        key: "view",
        get: function get() {
          return "\n\t\t\t\t\t<p>\n\t\t\t\t\t\t{{#if(elementPromise.isResolved)}}\n\t\t\t\t\t\t\t{{{element}}}\n\t\t\t\t\t\t{{/if}}\n\t\t\t\t\t</p>\n\n\t\t\t\t\t<button on:click=\"increment()\">+1</button>\n\t\t\t\t";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            id: 1,
            elementPromise: {
              get: function get() {
                var _this = this;

                return new Promise(function (resolve) {
                  var child = _this.id === 1 ? new One() : new Two();
                  child.bindings({
                    id: value.from(_this, "id")
                  });
                  child.connect();
                  resolve(child);
                });
              }
            },
            element: {
              async: function async(resolve) {
                this.elementPromise.then(resolve);
              }
            }
          };
        }
      }]);

      return App;
    }(StacheElement);

    customElements.define("a-pp", App);
    var app = new App();
    app.connect();
    app.on('element', function onFirst() {
      app.off('element', onFirst);
      app.on('element', function onSecond() {
        app.off('element', onSecond);
        assert.equal(oneId, 1, "<o-ne> Has its original id");
        assert.equal(twoId, 2, "<t-wo> Has its own id");
        done();
      });
      var oneEl = app.querySelector('o-ne');
      app.increment();
      assert.equal(oneEl.querySelector('#oneid').textContent, "1", "<o-ne> Has not changed");
    });
  });
  QUnit.test("All bindings are torn down", function (assert) {
    var BindingsTeardownElement = /*#__PURE__*/function (_StacheElement5) {
      _inherits(BindingsTeardownElement, _StacheElement5);

      var _super5 = _createSuper(BindingsTeardownElement);

      function BindingsTeardownElement() {
        _classCallCheck(this, BindingsTeardownElement);

        return _super5.apply(this, arguments);
      }

      _createClass(BindingsTeardownElement, null, [{
        key: "view",
        get: function get() {
          return "<h1>{{greeting}} {{object}}</h1>";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            greeting: {
              type: String,
              default: "Hi"
            },
            object: {
              type: String,
              default: "person"
            }
          };
        }
      }]);

      return BindingsTeardownElement;
    }(StacheElement);

    customElements.define("bindings-teardown-element", BindingsTeardownElement);
    var teardownElement = new BindingsTeardownElement();
    var greetingObservable = value.with("Hello");
    var objectObservable = value.with("world");
    teardownElement.bindings({
      greeting: greetingObservable,
      object: objectObservable
    });
    teardownElement.connect();
    var h1 = teardownElement.firstElementChild;
    assert.equal(teardownElement.greeting, "Hello", "greetingObservable set up correctly");
    assert.equal(teardownElement.object, "world", "objectObservable set up correctly");
    assert.equal(h1.innerHTML, "Hello world", "view rendered");
    teardownElement.disconnect();
    greetingObservable.value = "Howdy";
    objectObservable.value = "Mars";
    assert.equal(teardownElement.greeting, "Hello", "greetingObservable torn down correctly");
    assert.equal(teardownElement.object, "world", "objectObservable torn down correctly");
    assert.equal(h1.innerHTML, "Hello world", "view not updated");
  });
  QUnit.test("Lifecycle methods return the element", function (assert) {
    var BindingsMethodsElement = /*#__PURE__*/function (_StacheElement6) {
      _inherits(BindingsMethodsElement, _StacheElement6);

      var _super6 = _createSuper(BindingsMethodsElement);

      function BindingsMethodsElement() {
        _classCallCheck(this, BindingsMethodsElement);

        return _super6.apply(this, arguments);
      }

      return BindingsMethodsElement;
    }(StacheElement);

    customElements.define("bindings-methods-element", BindingsMethodsElement);
    var obj = new BindingsMethodsElement().bindings().initialize().render().connect().disconnect();
    assert.ok(obj instanceof BindingsMethodsElement, "initialize, render, connect, disconnect");
  });
  QUnit.test("bindings work after being torn down and re-initialized", function (assert) {
    var ReInitializeBindingsEl = /*#__PURE__*/function (_StacheElement7) {
      _inherits(ReInitializeBindingsEl, _StacheElement7);

      var _super7 = _createSuper(ReInitializeBindingsEl);

      function ReInitializeBindingsEl() {
        _classCallCheck(this, ReInitializeBindingsEl);

        return _super7.apply(this, arguments);
      }

      _createClass(ReInitializeBindingsEl, null, [{
        key: "view",
        get: function get() {
          return "\n\t\t\t\t<p>Child {{ this.show }}</p>\n\t\t\t  ";
        }
      }, {
        key: "props",
        get: function get() {
          return {
            show: false
          };
        }
      }]);

      return ReInitializeBindingsEl;
    }(StacheElement);

    customElements.define("reinitialize-bindings-el", ReInitializeBindingsEl);
    var parent = new SimpleObservable(true);
    var el = new ReInitializeBindingsEl().bindings({
      show: parent
    }).connect();
    assert.equal(el.show, true, "el.show === true by default");
    el.show = false;
    assert.equal(el.show, false, "el.show toggled to false");
    assert.equal(parent.value, false, "parent.value changed to false");
    parent.value = true;
    assert.equal(el.show, true, "el.show toggled to true");
    assert.equal(parent.value, true, "parent.value changed to true"); // tear down and re-initialize bindings

    el.disconnect().connect();
    el.show = false;
    assert.equal(el.show, false, "el.show toggled to false again");
    assert.equal(parent.value, false, "parent.value changed to false again");
  });
}